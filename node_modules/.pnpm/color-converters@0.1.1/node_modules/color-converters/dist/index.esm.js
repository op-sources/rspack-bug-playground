function assertRange(val) {
    var pass;
    if (typeof val === "number") {
        pass = 0 <= val && val <= 255;
    }
    else {
        pass = val.every(function (v) { return 0 <= v && v <= 255; });
    }
    if (!pass) {
        throw new RangeError("RGB channel value shoud be in range [0, 255].");
    }
}

var ε = 1e-6;
function clamp(val, max, min) {
    if (min === void 0) { min = 0; }
    return Math.min(Math.max(val, min), max);
}
function clampRgb(rgb) {
    return rgb.map(function (ch) { return clamp(ch, 255); });
}

function patchHsl(_a) {
    var h = _a[0], s = _a[1], l = _a[2];
    if (s < ε) {
        h = s = 0;
    }
    if (l < ε) {
        h = s = l = 0;
    }
    else if (1 - l < ε) {
        l = 1;
        h = s = 0;
    }
    return [h, s, l];
}

function rgbToHsl (rgb) {
    assertRange(rgb);
    var _a = rgb.map(function (ch) { return ch / 255; }), r = _a[0], g = _a[1], b = _a[2];
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var diff = max - min;
    var sum = max + min;
    var h;
    var s;
    var l = sum / 2;
    if (max === min) {
        h = 0;
    }
    else if (max === r && g >= b) {
        h = (60 * (g - b)) / diff + 0;
    }
    else if (max === r && g < b) {
        h = (60 * (g - b)) / diff + 360;
    }
    else if (max === g) {
        h = (60 * (b - r)) / diff + 120;
    }
    else {
        // max === b
        h = (60 * (r - g)) / diff + 240;
    }
    if (l === 0 || max === min) {
        s = 0;
    }
    else if (0 < l && l <= 0.5) {
        s = diff / sum;
    }
    else {
        // l > 0.5
        s = diff / (2 - sum);
    }
    return patchHsl([h, s, l]);
}

function patchHsv(_a) {
    var h = _a[0], s = _a[1], v = _a[2];
    if (s < ε) {
        h = s = 0;
    }
    if (v < ε) {
        h = s = 0;
    }
    return [h, s, v];
}

function rgbToHsv (rgb) {
    assertRange(rgb);
    var _a = rgb.map(function (ch) { return ch / 255; }), r = _a[0], g = _a[1], b = _a[2];
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var diff = max - min;
    var h;
    var s;
    if (max === min) {
        h = 0;
    }
    else if (max === r && g >= b) {
        h = (60 * (g - b)) / diff + 0;
    }
    else if (max === r && g < b) {
        h = (60 * (g - b)) / diff + 360;
    }
    else if (max === g) {
        h = (60 * (b - r)) / diff + 120;
    }
    else {
        // max === b
        h = (60 * (r - g)) / diff + 240;
    }
    if (max === 0) {
        s = 0;
    }
    else {
        s = diff / max;
    }
    var v = max;
    return patchHsv([h, s, v]);
}

var κ = 24389 / 27; // 29^3/3^3
var ε$1 = 216 / 24389; // 6^3/29^3
var white = [0.96422, 1.0, 0.82521]; // D50 reference white

var pow = Math.pow, cbrt = Math.cbrt;
function rgbToLab (rgb) {
    assertRange(rgb);
    return xyz50toLab(toXyz50(rgb));
}
function toXyz50(rgb) {
    var _a = toLrgb(rgb), r = _a[0], g = _a[1], b = _a[2];
    /**
     * Convert linear sRGB to XYZ. Instead of linear sRGB -> XYZ D65 -> XYZ D50,
     * we use linear sRGB -> XYZ D50 to calculate faster.
     * See https://www.w3.org/TR/css-color-4/#color-conversion-code
     * See http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
     */
    return [
        0.4360747 * r + 0.3850649 * g + 0.1430804 * b,
        0.2225045 * r + 0.7168786 * g + 0.0606169 * b,
        0.0139322 * r + 0.0971045 * g + 0.7141733 * b,
    ];
}
function toLrgb(rgb) {
    return rgb.map(function (ch) {
        var val = ch / 255;
        if (val < 0.04045) {
            return val / 12.92;
        }
        return pow((val + 0.055) / 1.055, 2.4);
    });
}
// See https://www.w3.org/TR/css-color-4/#color-conversion-code
function xyz50toLab(xyz) {
    // compute xyz, which is XYZ scaled relative to reference white
    var scaledXyz = xyz.map(function (val, i) { return val / white[i]; });
    var f = scaledXyz.map(function (val) {
        return val > ε$1 ? cbrt(val) : (κ * val + 16) / 116;
    });
    return [
        116 * f[1] - 16,
        500 * (f[0] - f[1]),
        200 * (f[1] - f[2]),
    ];
}

function assertHue(val) {
    if (val < 0 || val >= 360) {
        throw new RangeError("Hue channel value shoud be in range [0, 360).");
    }
}
function assertUnit(val, channelName) {
    if (val < 0 || val > 1) {
        throw new RangeError(upperFirst(channelName) + " channel value shoud be in range [0, 1].");
    }
}
function upperFirst(str) {
    if (str.length === 0) {
        return str;
    }
    return str.charAt(0).toUpperCase() + str.slice(1);
}
function assertCIELightness(val) {
    if (val < 0) {
        throw new RangeError("CIE lightness channel value shoud be positive.");
    }
}

var atan2 = Math.atan2, PI = Math.PI, sqrt = Math.sqrt, pow$1 = Math.pow;
function labToLch (_a) {
    var l = _a[0], a = _a[1], b = _a[2];
    assertCIELightness(l);
    var h = (atan2(b, a) * 180) / PI;
    return [
        l,
        sqrt(pow$1(a, 2) + pow$1(b, 2)),
        h >= 0 ? h : h + 360,
    ];
}

function rgbToLch (rgb) {
    return labToLch(rgbToLab(rgb));
}

var round = Math.round;
function toHex (rgb) {
    return "#" + rgb.map(convert).join("");
}
function convert(ch) {
    assertRange(ch);
    var str = round(ch).toString(16);
    return str.length == 1 ? "0" + str : str;
}

var hexRe = /^#(?:[0-9a-f]{3}){1,2}$/i;
function fromHex (hex) {
    if (!hexRe.test(hex)) {
        throw new Error("Invalid format for hex color value: " + hex);
    }
    var val = hex.slice(1);
    if (val.length === 3) {
        val = val
            .split("")
            .map(function (c) { return c + c; })
            .join("");
    }
    var num = parseInt(val, 16);
    return [num >> 16, (num >> 8) & 255, num & 255];
}

function hslToRgb (_a) {
    var h = _a[0], s = _a[1], l = _a[2];
    assertHue(h);
    assertUnit(s, "satuation");
    assertUnit(l, "lightness");
    // https://www.w3.org/TR/css-color-4/#hsl-to-rgb
    var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var t1 = l * 2 - t2;
    var r = hueToRgb(t1, t2, h + 120);
    var g = hueToRgb(t1, t2, h);
    var b = hueToRgb(t1, t2, h - 120);
    return [r * 255, g * 255, b * 255];
}
function hueToRgb(t1, t2, h) {
    h = (h + 360) % 360;
    if (h < 60) {
        return ((t2 - t1) * h) / 60 + t1;
    }
    else if (h < 180) {
        return t2;
    }
    else if (h < 240) {
        return ((t2 - t1) * (240 - h)) / 60 + t1;
    }
    else {
        return t1;
    }
}

var min = Math.min;
function toHsv (_a) {
    var h = _a[0], s = _a[1], l = _a[2];
    assertHue(h);
    assertUnit(s, "satuation");
    assertUnit(l, "lightness");
    var hv = h;
    var v = l + s * min(l, 1 - l);
    var sv = v === 0 ? 0 : 2 * (1 - l / v);
    return patchHsv([hv, sv, v]);
}

function toLab (hsl) {
    return rgbToLab(hslToRgb(hsl));
}

function toLch (hsl) {
    return rgbToLch(hslToRgb(hsl));
}

function toHsl (_a) {
    var h = _a[0], s = _a[1], v = _a[2];
    assertHue(h);
    assertUnit(s, "satuation");
    assertUnit(v, "value");
    var l = (2 - s) * v;
    var sl = s * v;
    sl /= l <= 1 ? l : 2 - l;
    sl = sl || 0;
    l /= 2;
    return patchHsl([h, sl, l]);
}

var floor = Math.floor;
function hsvToRgb (_a) {
    var h = _a[0], s = _a[1], v = _a[2];
    assertHue(h);
    assertUnit(s, "satuation");
    assertUnit(v, "value");
    var hi = floor(h / 60);
    var f = h / 60 - hi;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var rgb1;
    switch (hi) {
        case 0:
            rgb1 = [v, t, p];
            break;
        case 1:
            rgb1 = [q, v, p];
            break;
        case 2:
            rgb1 = [p, v, t];
            break;
        case 3:
            rgb1 = [p, q, v];
            break;
        case 4:
            rgb1 = [t, p, v];
            break;
        case 5:
            rgb1 = [v, p, q];
            break;
        default:
            rgb1 = [0, 0, 0];
    }
    return rgb1.map(function (ch) { return ch * 255; });
}

function toLab$1 (hsv) {
    return rgbToLab(hsvToRgb(hsv));
}

function toLch$1 (hsv) {
    return rgbToLch(hsvToRgb(hsv));
}

var cos = Math.cos, sin = Math.sin, PI$1 = Math.PI;
function lchToLab (_a) {
    var l = _a[0], c = _a[1], h = _a[2];
    assertHue(h);
    return [
        l,
        c * cos((h * PI$1) / 180),
        c * sin((h * PI$1) / 180),
    ];
}

var pow$2 = Math.pow;
function labToRgb (lab) {
    assertCIELightness(lab[0]);
    return clampRgb(lrgbToRgb(xyz50toLrgb(toXyz50$1(lab))));
}
function toXyz50$1(_a) {
    var l = _a[0], a = _a[1], b = _a[2];
    // compute f, starting with the luminance-related term
    var f1 = (l + 16) / 116;
    var f0 = a / 500 + f1;
    var f2 = f1 - b / 200;
    // compute xyz
    var xyz = [
        pow$2(f0, 3) > ε$1 ? pow$2(f0, 3) : (116 * f0 - 16) / κ,
        l > κ * ε$1 ? pow$2((l + 16) / 116, 3) : l / κ,
        pow$2(f2, 3) > ε$1 ? pow$2(f2, 3) : (116 * f2 - 16) / κ,
    ];
    // Compute XYZ by scaling xyz by reference white
    return xyz.map(function (val, i) { return val * white[i]; });
}
function xyz50toLrgb(_a) {
    var x = _a[0], y = _a[1], z = _a[2];
    return [
        3.1338561 * x + -1.6168667 * y + -0.4906146 * z,
        -0.9787684 * x + 1.9161415 * y + 0.033454 * z,
        0.0719453 * x + -0.2289914 * y + 1.4052427 * z,
    ];
}
function lrgbToRgb(rgb) {
    return rgb.map(function (val) {
        return (val > 0.0031308 ? 1.055 * pow$2(val, 1 / 2.4) - 0.055 : 12.92 * val) * 255;
    });
}

function lchToRgb (lch) {
    assertHue(lch[2]);
    return labToRgb(lchToLab(lch));
}

function toHsl$1 (lch) {
    assertHue(lch[2]);
    return rgbToHsl(lchToRgb(lch));
}

function toHsv$1 (lch) {
    assertHue(lch[2]);
    return rgbToHsv(lchToRgb(lch));
}

function toHsl$2 (lab) {
    return rgbToHsl(labToRgb(lab));
}

function toHsv$2 (lab) {
    return rgbToHsv(labToRgb(lab));
}

export { fromHex as hexToRgb, toHsv as hslToHsv, toLab as hslToLab, toLch as hslToLch, hslToRgb, toHsl as hsvToHsl, toLab$1 as hsvToLab, toLch$1 as hsvToLch, hsvToRgb, toHsl$2 as labToHsl, toHsv$2 as labToHsv, labToLch, labToRgb, toHsl$1 as lchToHsl, toHsv$1 as lchToHsv, lchToLab, lchToRgb, toHex as rgbToHex, rgbToHsl, rgbToHsv, rgbToLab, rgbToLch };
//# sourceMappingURL=index.esm.js.map
