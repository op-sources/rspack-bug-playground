{"version":3,"file":"index.cjs.min.js","sources":["../src/rgb/assert.ts","../src/common.ts","../src/hsl/patch.ts","../src/rgb/to-hsl.ts","../src/hsv/patch.ts","../src/rgb/to-hsv.ts","../src/lab/consts.ts","../src/rgb/to-lab.ts","../src/assert.ts","../src/lab/to-lch.ts","../src/rgb/to-lch.ts","../src/rgb/to-hex.ts","../src/rgb/from-hex.ts","../src/hsl/to-rgb.ts","../src/hsl/to-hsv.ts","../src/hsv/to-rgb.ts","../src/lch/to-lab.ts","../src/lab/to-rgb.ts","../src/lch/to-rgb.ts","../src/hsl/to-lab.ts","../src/hsl/to-lch.ts","../src/hsv/to-hsl.ts","../src/hsv/to-lab.ts","../src/hsv/to-lch.ts","../src/lab/to-hsl.ts","../src/lab/to-hsv.ts","../src/lch/to-hsl.ts","../src/lch/to-hsv.ts"],"sourcesContent":["import { Channels } from \"../common\";\n\nexport function assertRange(val: number | Channels): void {\n  let pass;\n  if (typeof val === \"number\") {\n    pass = 0 <= val && val <= 255;\n  } else {\n    pass = val.every((v) => 0 <= v && v <= 255);\n  }\n  if (!pass) {\n    throw new RangeError(\"RGB channel value shoud be in range [0, 255].\");\n  }\n}\n","export type Channels = [number, number, number];\n\nexport const ε = 1e-6;\n\nfunction clamp(val: number, max: number, min = 0): number {\n  return Math.min(Math.max(val, min), max);\n}\n\nexport function clampRgb(rgb: Channels): Channels {\n  return rgb.map((ch) => clamp(ch, 255)) as Channels;\n}\n","import { Channels } from \"../common\";\nimport { ε } from \"../common\";\n\nexport function patchHsl([h, s, l]: Channels): Channels {\n  if (s < ε) {\n    h = s = 0;\n  }\n  if (l < ε) {\n    h = s = l = 0;\n  } else if (1 - l < ε) {\n    l = 1;\n    h = s = 0;\n  }\n  return [h, s, l];\n}\n","import { Channels } from \"../common\";\nimport { assertRange } from \"./assert\";\nimport { patchHsl } from \"../hsl/patch\";\n\nexport default function (rgb: Channels): Channels {\n  assertRange(rgb);\n\n  const [r, g, b] = rgb.map((ch) => ch / 255);\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const diff = max - min;\n  const sum = max + min;\n\n  let h;\n  let s;\n  const l = sum / 2;\n\n  if (max === min) {\n    h = 0;\n  } else if (max === r && g >= b) {\n    h = (60 * (g - b)) / diff + 0;\n  } else if (max === r && g < b) {\n    h = (60 * (g - b)) / diff + 360;\n  } else if (max === g) {\n    h = (60 * (b - r)) / diff + 120;\n  } else {\n    // max === b\n    h = (60 * (r - g)) / diff + 240;\n  }\n\n  if (l === 0 || max === min) {\n    s = 0;\n  } else if (0 < l && l <= 0.5) {\n    s = diff / sum;\n  } else {\n    // l > 0.5\n    s = diff / (2 - sum);\n  }\n\n  return patchHsl([h, s, l]);\n}\n","import { Channels } from \"../common\";\nimport { ε } from \"../common\";\n\nexport function patchHsv([h, s, v]: Channels): Channels {\n  if (s < ε) {\n    h = s = 0;\n  }\n\n  if (v < ε) {\n    h = s = 0;\n  }\n\n  return [h, s, v];\n}\n","import { Channels } from \"../common\";\nimport { assertRange } from \"./assert\";\nimport { patchHsv } from \"../hsv/patch\";\n\nexport default function (rgb: Channels): Channels {\n  assertRange(rgb);\n\n  const [r, g, b] = rgb.map((ch) => ch / 255);\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const diff = max - min;\n\n  let h;\n  let s;\n\n  if (max === min) {\n    h = 0;\n  } else if (max === r && g >= b) {\n    h = (60 * (g - b)) / diff + 0;\n  } else if (max === r && g < b) {\n    h = (60 * (g - b)) / diff + 360;\n  } else if (max === g) {\n    h = (60 * (b - r)) / diff + 120;\n  } else {\n    // max === b\n    h = (60 * (r - g)) / diff + 240;\n  }\n\n  if (max === 0) {\n    s = 0;\n  } else {\n    s = diff / max;\n  }\n\n  const v = max;\n  return patchHsv([h, s, v]);\n}\n","export const κ = 24389 / 27; // 29^3/3^3\nexport const ε = 216 / 24389; // 6^3/29^3\nexport const white = [0.96422, 1.0, 0.82521]; // D50 reference white\n","import { Channels } from \"../common\";\nimport { assertRange } from \"./assert\";\nimport { ε, κ, white } from \"../lab/consts\";\n\nconst { pow, cbrt } = Math;\n\nexport default function (rgb: Channels): Channels {\n  assertRange(rgb);\n\n  return xyz50toLab(toXyz50(rgb));\n}\n\nfunction toXyz50(rgb: Channels): Channels {\n  const [r, g, b] = toLrgb(rgb);\n\n  /**\n   * Convert linear sRGB to XYZ. Instead of linear sRGB -> XYZ D65 -> XYZ D50,\n   * we use linear sRGB -> XYZ D50 to calculate faster.\n   * See https://www.w3.org/TR/css-color-4/#color-conversion-code\n   * See http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   */\n  return [\n    0.4360747 * r + 0.3850649 * g + 0.1430804 * b,\n    0.2225045 * r + 0.7168786 * g + 0.0606169 * b,\n    0.0139322 * r + 0.0971045 * g + 0.7141733 * b,\n  ];\n}\n\nfunction toLrgb(rgb: Channels): Channels {\n  return rgb.map((ch) => {\n    const val = ch / 255;\n\n    if (val < 0.04045) {\n      return val / 12.92;\n    }\n\n    return pow((val + 0.055) / 1.055, 2.4);\n  }) as Channels;\n}\n\n// See https://www.w3.org/TR/css-color-4/#color-conversion-code\nfunction xyz50toLab(xyz: Channels): Channels {\n  // compute xyz, which is XYZ scaled relative to reference white\n  const scaledXyz = xyz.map((val, i) => val / white[i]);\n\n  const f = scaledXyz.map((val) =>\n    val > ε ? cbrt(val) : (κ * val + 16) / 116\n  );\n\n  return [\n    116 * f[1] - 16, // L\n    500 * (f[0] - f[1]), // a\n    200 * (f[1] - f[2]), // b\n  ];\n}\n","export function assertHue(val: number): void {\n  if (val < 0 || val >= 360) {\n    throw new RangeError(\"Hue channel value shoud be in range [0, 360).\");\n  }\n}\n\nexport function assertUnit(val: number, channelName: string): void {\n  if (val < 0 || val > 1) {\n    throw new RangeError(\n      `${upperFirst(channelName)} channel value shoud be in range [0, 1].`\n    );\n  }\n}\n\nfunction upperFirst(str: string): string {\n  if (str.length === 0) {\n    return str;\n  }\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function assertCIELightness(val: number): void {\n  if (val < 0) {\n    throw new RangeError(`CIE lightness channel value shoud be positive.`);\n  }\n}\n","import { Channels } from \"../common\";\nimport { assertCIELightness } from \"../assert\";\n\nconst { atan2, PI, sqrt, pow } = Math;\n\nexport default function ([l, a, b]: Channels): Channels {\n  assertCIELightness(l);\n\n  const h = (atan2(b, a) * 180) / PI;\n  return [\n    l, // L is still L\n    sqrt(pow(a, 2) + pow(b, 2)), // Chroma\n    h >= 0 ? h : h + 360, // hue, in degrees [0 to 360)\n  ];\n}\n","import { Channels } from \"../common\";\nimport rgbToLab from \"./to-lab\";\nimport labToLch from \"../lab/to-lch\";\n\nexport default function (rgb: Channels): Channels {\n  return labToLch(rgbToLab(rgb));\n}\n","import { Channels } from \"../common\";\nimport { assertRange } from \"./assert\";\n\nconst { round } = Math;\n\nexport default function (rgb: Channels): string {\n  return \"#\" + rgb.map(convert).join(\"\");\n}\n\nfunction convert(ch: number): string {\n  assertRange(ch);\n\n  const str = round(ch).toString(16);\n  return str.length == 1 ? `0${str}` : str;\n}\n","import { Channels } from \"../common\";\n\nconst hexRe = /^#(?:[0-9a-f]{3}){1,2}$/i;\n\nexport default function (hex: string): Channels {\n  if (!hexRe.test(hex)) {\n    throw new Error(`Invalid format for hex color value: ${hex}`);\n  }\n\n  let val = hex.slice(1);\n\n  if (val.length === 3) {\n    val = val\n      .split(\"\")\n      .map((c) => c + c)\n      .join(\"\");\n  }\n\n  const num = parseInt(val, 16);\n\n  return [num >> 16, (num >> 8) & 255, num & 255];\n}\n","import { Channels } from \"../common\";\nimport { assertHue, assertUnit } from \"../assert\";\n\nexport default function ([h, s, l]: Channels): Channels {\n  assertHue(h);\n  assertUnit(s, \"satuation\");\n  assertUnit(l, \"lightness\");\n\n  // https://www.w3.org/TR/css-color-4/#hsl-to-rgb\n  const t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  const t1 = l * 2 - t2;\n  const r = hueToRgb(t1, t2, h + 120);\n  const g = hueToRgb(t1, t2, h);\n  const b = hueToRgb(t1, t2, h - 120);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hueToRgb(t1: number, t2: number, h: number): number {\n  h = (h + 360) % 360;\n\n  if (h < 60) {\n    return ((t2 - t1) * h) / 60 + t1;\n  } else if (h < 180) {\n    return t2;\n  } else if (h < 240) {\n    return ((t2 - t1) * (240 - h)) / 60 + t1;\n  } else {\n    return t1;\n  }\n}\n","import { Channels } from \"../common\";\nimport { assertHue, assertUnit } from \"../assert\";\nimport { patchHsv } from \"../hsv/patch\";\n\nconst { min } = Math;\n\nexport default function ([h, s, l]: Channels): Channels {\n  assertHue(h);\n  assertUnit(s, \"satuation\");\n  assertUnit(l, \"lightness\");\n\n  const hv = h;\n  const v = l + s * min(l, 1 - l);\n  const sv = v === 0 ? 0 : 2 * (1 - l / v);\n\n  return patchHsv([hv, sv, v]);\n}\n","import { Channels } from \"../common\";\nimport { assertHue, assertUnit } from \"../assert\";\n\nconst { floor } = Math;\n\nexport default function ([h, s, v]: Channels): Channels {\n  assertHue(h);\n  assertUnit(s, \"satuation\");\n  assertUnit(v, \"value\");\n\n  const hi = floor(h / 60);\n  const f = h / 60 - hi;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n\n  let rgb1: Channels;\n\n  switch (hi) {\n    case 0:\n      rgb1 = [v, t, p];\n      break;\n    case 1:\n      rgb1 = [q, v, p];\n      break;\n    case 2:\n      rgb1 = [p, v, t];\n      break;\n    case 3:\n      rgb1 = [p, q, v];\n      break;\n    case 4:\n      rgb1 = [t, p, v];\n      break;\n    case 5:\n      rgb1 = [v, p, q];\n      break;\n    default:\n      rgb1 = [0, 0, 0];\n  }\n\n  return rgb1.map((ch) => ch * 255) as Channels;\n}\n","import { Channels } from \"../common\";\nimport { assertHue } from \"../assert\";\n\nconst { cos, sin, PI } = Math;\n\nexport default function ([l, c, h]: Channels): Channels {\n  assertHue(h);\n\n  return [\n    l, // L is still L\n    c * cos((h * PI) / 180), // a\n    c * sin((h * PI) / 180), // b\n  ];\n}\n","import { Channels, clampRgb } from \"../common\";\nimport { assertCIELightness } from \"../assert\";\nimport { ε, κ, white } from \"./consts\";\n\nconst { pow } = Math;\n\nexport default function (lab: Channels): Channels {\n  assertCIELightness(lab[0]);\n\n  return clampRgb(lrgbToRgb(xyz50toLrgb(toXyz50(lab))));\n}\n\nfunction toXyz50([l, a, b]: Channels): Channels {\n  // compute f, starting with the luminance-related term\n  const f1 = (l + 16) / 116;\n  const f0 = a / 500 + f1;\n  const f2 = f1 - b / 200;\n\n  // compute xyz\n  const xyz = [\n    pow(f0, 3) > ε ? pow(f0, 3) : (116 * f0 - 16) / κ,\n    l > κ * ε ? pow((l + 16) / 116, 3) : l / κ,\n    pow(f2, 3) > ε ? pow(f2, 3) : (116 * f2 - 16) / κ,\n  ];\n\n  // Compute XYZ by scaling xyz by reference white\n  return xyz.map((val, i) => val * white[i]) as Channels;\n}\n\nfunction xyz50toLrgb([x, y, z]: Channels): Channels {\n  return [\n    3.1338561 * x + -1.6168667 * y + -0.4906146 * z,\n    -0.9787684 * x + 1.9161415 * y + 0.033454 * z,\n    0.0719453 * x + -0.2289914 * y + 1.4052427 * z,\n  ];\n}\n\nfunction lrgbToRgb(rgb: Channels): Channels {\n  return rgb.map(\n    (val) =>\n      (val > 0.0031308 ? 1.055 * pow(val, 1 / 2.4) - 0.055 : 12.92 * val) * 255\n  ) as Channels;\n}\n","import { Channels } from \"../common\";\nimport { assertHue } from \"../assert\";\nimport lchToLab from \"./to-lab\";\nimport labToRgb from \"../lab/to-rgb\";\n\nexport default function (lch: Channels): Channels {\n  assertHue(lch[2]);\n\n  return labToRgb(lchToLab(lch));\n}\n","import { Channels } from \"../common\";\nimport hslToRgb from \"./to-rgb\";\nimport rgbToLab from \"../rgb/to-lab\";\n\nexport default function (hsl: Channels): Channels {\n  return rgbToLab(hslToRgb(hsl));\n}\n","import { Channels } from \"../common\";\nimport hslToRgb from \"./to-rgb\";\nimport rgbToLch from \"../rgb/to-lch\";\n\nexport default function (hsl: Channels): Channels {\n  return rgbToLch(hslToRgb(hsl));\n}\n","import { Channels } from \"../common\";\nimport { assertHue, assertUnit } from \"../assert\";\nimport { patchHsl } from \"../hsl/patch\";\n\nexport default function ([h, s, v]: Channels): Channels {\n  assertHue(h);\n  assertUnit(s, \"satuation\");\n  assertUnit(v, \"value\");\n\n  let l = (2 - s) * v;\n  let sl = s * v;\n  sl /= l <= 1 ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return patchHsl([h, sl, l]);\n}\n","import { Channels } from \"../common\";\nimport hsvToRgb from \"./to-rgb\";\nimport rgbToLab from \"../rgb/to-lab\";\n\nexport default function (hsv: Channels): Channels {\n  return rgbToLab(hsvToRgb(hsv));\n}\n","import { Channels } from \"../common\";\nimport hsvToRgb from \"./to-rgb\";\nimport rgbToLch from \"../rgb/to-lch\";\n\nexport default function (hsv: Channels): Channels {\n  return rgbToLch(hsvToRgb(hsv));\n}\n","import { Channels } from \"../common\";\nimport labToRgb from \"./to-rgb\";\nimport rgbToHsl from \"../rgb/to-hsl\";\n\nexport default function (lab: Channels): Channels {\n  return rgbToHsl(labToRgb(lab));\n}\n","import { Channels } from \"../common\";\nimport labToRgb from \"./to-rgb\";\nimport rgbToHsv from \"../rgb/to-hsv\";\n\nexport default function (lab: Channels): Channels {\n  return rgbToHsv(labToRgb(lab));\n}\n","import { Channels } from \"../common\";\nimport lchToRgb from \"./to-rgb\";\nimport rgbToHsl from \"../rgb/to-hsl\";\nimport { assertHue } from \"../assert\";\n\nexport default function (lch: Channels): Channels {\n  assertHue(lch[2]);\n\n  return rgbToHsl(lchToRgb(lch));\n}\n","import { Channels } from \"../common\";\nimport lchToRgb from \"./to-rgb\";\nimport rgbToHsv from \"../rgb/to-hsv\";\nimport { assertHue } from \"../assert\";\n\nexport default function (lch: Channels): Channels {\n  assertHue(lch[2]);\n\n  return rgbToHsv(lchToRgb(lch));\n}\n"],"names":["assertRange","val","every","v","RangeError","ε","clampRgb","rgb","map","ch","max","min","Math","clamp","patchHsl","_a","h","s","l","r","g","b","diff","sum","patchHsv","κ","white","pow","cbrt","xyz","toLrgb","toXyz50","f","i","assertHue","assertUnit","channelName","str","length","charAt","toUpperCase","slice","upperFirst","assertCIELightness","atan2","PI","sqrt","a","labToLch","rgbToLab","round","convert","toString","hexRe","t2","t1","hueToRgb","floor","rgb1","hi","p","q","t","cos","sin","c","lab","x","y","z","xyz50toLrgb","f2","f1","f0","lch","labToRgb","lchToLab","hex","test","Error","split","join","num","parseInt","hv","hsl","hslToRgb","rgbToLch","sl","hsv","hsvToRgb","rgbToHsl","rgbToHsv","lchToRgb"],"mappings":"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"}