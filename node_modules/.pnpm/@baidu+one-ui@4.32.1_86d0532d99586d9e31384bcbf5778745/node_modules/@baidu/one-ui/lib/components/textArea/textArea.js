"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

exports.__esModule = true;
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _react = _interopRequireWildcard(require("react"));

var _omit = _interopRequireDefault(require("omit.js"));

var _inputTools = require("../../core/inputTools");

var _commonTools = require("../../core/commonTools");

var _textAreaTools = _interopRequireDefault(require("../../core/textAreaTools"));

var _popover = _interopRequireDefault(require("../popover"));

var _tipsAndErrorTools = require("../../core/tipsAndErrorTools");

var _context = require("../providerConfig/context");

var _config = require("../config");

var _dec, _class, _class2, _temp;

function onNextFrame(cb) {
  if (window.requestAnimationFrame) {
    return window.requestAnimationFrame(cb);
  }

  return window.setTimeout(cb, 1);
}

function clearNextFrameAction(nextFrameId) {
  if (window.cancelAnimationFrame) {
    window.cancelAnimationFrame(nextFrameId);
  } else {
    window.clearTimeout(nextFrameId);
  }
}

var TextArea = (_dec = (0, _context.withConfigConsumer)('textarea'), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_PureComponent) {
  (0, _inheritsLoose2["default"])(TextArea, _PureComponent);

  function TextArea(_props) {
    var _this;

    _this = _PureComponent.call(this, _props) || this;
    _this.___imeStart___ = void 0;
    _this.nextFrameActionId = void 0;
    _this.textAreaRef = void 0;
    _this.counterRef = void 0;

    _this.onInputCompositionStart = function () {
      _this.___imeStart___ = true;
    };

    _this.onInputCompositionEnd = function (e) {
      _this.___imeStart___ = false;

      _this.onChange(e);
    };

    _this.onChange = function (e) {
      _this.resizeTextarea();

      if (_this.___imeStart___) {
        _this.setState({
          inputValue: e.target.value
        });

        return;
      }

      _this.handleError(e, 'onChange', false);
    };

    _this.resizeTextarea = function () {
      var _this$props = _this.props,
          minRows = _this$props.minRows,
          maxRows = _this$props.maxRows;

      _this.setState({
        textareaStyles: (0, _textAreaTools["default"])(_this.textAreaRef, _this.counterRef, false, minRows, maxRows)
      });
    };

    _this.handleError = function (e, funcName, isHandleMin) {
      if (isHandleMin === void 0) {
        isHandleMin = true;
      }

      var props = _this.props;
      var value = e && e.target && e.target.value;
      var errorMessage = (0, _inputTools.handleErrorMessage)((0, _extends2["default"])({}, props, {
        value: value
      }), isHandleMin, true);
      var result = {
        value: value,
        errorMessage: errorMessage,
        event: e,
        target: e && e.target
      };
      var newState = {
        errorMessage: errorMessage
      };

      if (!('value' in _this.props)) {
        // this.setState(result);
        newState.value = value;
        newState.inputValue = value;
      } else {
        newState.inputValue = _this.state.value;
      }

      _this.setState(newState);

      var func = props[funcName];

      if (func) {
        func(result, e);
      }
    };

    _this.blur = function (e) {
      _this.setState({
        hasFocus: false
      });

      _this.handleError(e, 'onBlur', true);
    };

    _this.focus = function (e) {
      _this.setState({
        hasFocus: true
      });

      _this.handleError(e, 'onFocus', true);
    };

    _this.saveTextAreaRef = function (textArea) {
      _this.textAreaRef = textArea;
    };

    _this.saveCounterRef = function (node) {
      _this.counterRef = node;
    };

    var _value = typeof _props.value === 'undefined' ? _props.defaultValue : _props.value;

    _this.state = {
      prevProps: _props,
      hasFocus: false,
      textareaStyles: null,
      value: _value,
      inputValue: _value,
      errorMessage: ''
    };
    return _this;
  }

  var _proto = TextArea.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.resizeTextarea();
    this.setContainerRef();
  };

  _proto.setContainerRef = function setContainerRef() {
    var containerRef = this.props.containerRef;

    if (containerRef) {
      return containerRef(this);
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var value = this.props.value;

    if (value !== prevProps.value) {
      if (this.nextFrameActionId) {
        clearNextFrameAction(this.nextFrameActionId);
      }

      this.nextFrameActionId = onNextFrame(this.resizeTextarea);
    }

    this.setContainerRef();
  };

  TextArea.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    var newState = {
      prevProps: nextProps
    };
    var value = nextProps.value;

    if ('value' in nextProps && value !== (prevState.prevProps || {}).value) {
      newState.value = value;
      newState.inputValue = value;
    }

    return newState;
  };

  _proto.render = function render() {
    var _classnames, _classnames2, _classnames3;

    var props = this.props;
    var propsErrorMessage = props.errorMessage;
    var otherProps = (0, _omit["default"])(props, ['prefixCls', 'maxRows', 'minRows', 'filterArray', 'defaultValue', 'showErrorWithoutErrorMessage', 'showErrorMessage', 'originTextAreaProps', 'containerRef', 'width'].concat(_inputTools.commonRemoveProps, _commonTools.locationRemoveProps));
    var width = props.width,
        prefixCls = props.prefixCls,
        maxLen = props.maxLen,
        className = props.className,
        disabled = props.disabled,
        readOnly = props.readOnly,
        showErrorMessage = props.showErrorMessage,
        showErrorWithoutErrorMessage = props.showErrorWithoutErrorMessage,
        tipText = props.tipText,
        location = props.location,
        tipLocation = props.tipLocation,
        errorLocation = props.errorLocation,
        _props$style = props.style,
        style = _props$style === void 0 ? {} : _props$style,
        size = props.size;
    var _this$state = this.state,
        textareaStyles = _this$state.textareaStyles,
        hasFocus = _this$state.hasFocus,
        value = _this$state.value,
        inputValue = _this$state.inputValue,
        stateErrorMessage = _this$state.errorMessage;
    var errorMessage = propsErrorMessage == null ? stateErrorMessage : propsErrorMessage;
    var defaultProps = (0, _extends2["default"])({
      value: (0, _inputTools.fixControlledValue)(inputValue),
      style: (0, _extends2["default"])({
        width: width
      }, style, textareaStyles),
      className: (0, _commonTools.classnames)(prefixCls, className, _config.COMPONENT_MAIN, (_classnames = {}, _classnames[prefixCls + "-disabled"] = disabled, _classnames[prefixCls + "-readOnly"] = readOnly, _classnames)),
      ref: this.saveTextAreaRef,
      onFocus: this.focus,
      onBlur: this.blur,
      onChange: this.onChange,
      onCompositionStart: this.onInputCompositionStart,
      onCompositionEnd: this.onInputCompositionEnd
    }, props.originTextAreaProps);
    var containerProps = {
      className: (0, _commonTools.classnames)(prefixCls + "-container", (_classnames2 = {}, _classnames2[prefixCls + "-error"] = errorMessage || showErrorWithoutErrorMessage, _classnames2))
    };
    var popParams = (0, _extends2["default"])({}, props, {
      errorMessage: errorMessage
    });
    var wrapperClass = prefixCls + "-wrapper";
    var showSideMessage = showErrorMessage && ((tipText || errorMessage) && location === 'right' || tipText && tipLocation === 'right' || errorMessage && errorLocation === 'right');
    var wrapperProps = {
      className: (0, _commonTools.classnames)(wrapperClass, (_classnames3 = {}, _classnames3[wrapperClass + "-" + size] = size, _classnames3)),
      style: {
        width: !showSideMessage ? style.width || width : undefined
      }
    };
    return /*#__PURE__*/_react["default"].createElement("div", wrapperProps, /*#__PURE__*/_react["default"].createElement("div", containerProps, /*#__PURE__*/_react["default"].createElement(_popover["default"], (0, _tipsAndErrorTools.getPopoverProps)(popParams, {
      hasFocus: hasFocus
    }), /*#__PURE__*/_react["default"].createElement("textarea", (0, _extends2["default"])({}, (0, _extends2["default"])({}, otherProps, defaultProps), {
      "data-type": "textarea"
    }))), maxLen ? /*#__PURE__*/_react["default"].createElement("span", {
      className: prefixCls + "-count-tips",
      ref: this.saveCounterRef
    }, (0, _commonTools.handleCountTips)((0, _commonTools.getRealLength)(props, value), maxLen)) : null), showErrorMessage ? (0, _tipsAndErrorTools.tipsAndErrorRender)(popParams) : null);
  };

  return TextArea;
}(_react.PureComponent), _class2.defaultProps = {
  prefixCls: 'one-textarea',
  width: 300,
  maxRows: 8,
  minRows: 3,
  maxLen: null,
  errorMessage: null,
  location: 'right',
  tipLocation: null,
  errorLocation: null,
  tipText: null,
  onChange: function onChange() {},
  onBlur: function onBlur() {},
  onFocus: function onFocus() {},
  size: 'medium',
  isRequired: false,
  filterArray: [],
  countMode: _commonTools.CHINA_COUNT_MODE,
  getLength: null,
  disabled: false,
  readOnly: false,
  showErrorMessage: true,
  showErrorWithoutErrorMessage: false,
  originTextAreaProps: {}
}, _temp)) || _class);
var _default = TextArea;
exports["default"] = _default;
module.exports = exports.default;