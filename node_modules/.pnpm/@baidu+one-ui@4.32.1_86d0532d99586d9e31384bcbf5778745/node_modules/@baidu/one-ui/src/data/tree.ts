import {last} from "lodash";

type TreeNode = {
    children?: TreeNode[],
    value?: any,
    label?: any,
    title?: any,
    disabled?: boolean,
    selectable?: boolean,
    isLeaf?: boolean,
    loading?: boolean,
    expandType?: 'inline' | 'column' | 'toggle',
    item?: TreeNode,
    [key: string]: any
};

type WalkerContext = {
    deep: number,
    parents: Object[],
    parentResult?: TreeNode | void,
    result?: TreeNode,
    childrenResult?: TreeNode[],
};

type Walker = {
    enter: (item: TreeNode, context: WalkerContext) => any,
    exit?: (item: TreeNode, context: WalkerContext) => void,
    deepKey?: string
};

type SearchConfig = {
    filter?: (query: string, path: any[]) => boolean,
    sort?: (a: any[], b: any[], query: string) => number
}

export function walk(
    items: TreeNode[],
    {enter, exit, deepKey = 'children'}: Walker,
    context: WalkerContext = {deep: 0, parents: []}
) {
    const results = [];
    items.forEach(function (item) {
        const result = enter(item, context);
        const children = item[deepKey];
        let childrenResult = null;
        if (children && children.length) {
            childrenResult = walk(
                children,
                {enter, exit, deepKey},
                {...context, parentResult: result, parents: [...context.parents, result], deep: context.deep + 1}
            );
        }
        if (exit) {
            exit(item, {...context, result, childrenResult});
        }
        results.push(result);
    });
    return results;
}
const ROOT_VALUE = '__ONE_TREE_ROOT_VALUE__';

type FieldNames = {
    children?: string,
    value?: string,
    label?: string,
    title?: string,
    disabled?: string,
    selectable?: string,
    isLeaf?: string,
    loading?: string,
    icon?: string,
    expandType?: string
}

export class Tree {
    constructor(items: TreeNode[] = [], checkedKeys = [], names: FieldNames = {}, leaf?: boolean) {
        const map = {};
        const {
            children: childrenKey = 'children',
            value: valueKey = 'value',
            label: labelKey = 'label',
            title: titleKey = 'title',
            disabled: disabledKey = 'disabled',
            selectable: selectableKey = 'selectable',
            isLeaf: isLeafKey = 'isLeaf',
            loading: loadingKey = 'loading',
            icon: iconKey = 'icon',
            expandType: expandTypeKey = 'expandType'
        } = names;
        const normalizedCheckedKeys = [];
        this.root = {[labelKey]: '全选', [valueKey]: ROOT_VALUE};
        const flatten = [];
        this.tree = walk(
            [{...this.root, [childrenKey]: items}],
            {
                deepKey: childrenKey,
                enter: (item, {parentResult, parents}) => {
                    const key = item[valueKey];
                    const label = item[labelKey];
                    const title = item[titleKey] || (typeof label === 'string' ? label : null);
                    const disabled = (parentResult && parentResult.disabled) || item[disabledKey];
                    const selectable = item[selectableKey];
                    const checked = (parentResult && parentResult.checked) || checkedKeys.includes(key);
                    const isLeaf = item[isLeafKey];
                    const loading = item[loadingKey];
                    const icon = item[iconKey];
                    const expandType = item[expandTypeKey];
                    const children = item[childrenKey];
                    const normalizedItem = {
                        root: key === ROOT_VALUE,
                        key,
                        label,
                        icon,
                        title,
                        item,
                        disabled,
                        selectable,
                        checked,
                        isLeaf,
                        loading,
                        expandType,
                        parent: parentResult,
                        keyPath: null
                    };

                    const keyPath = this.getKeyPath(normalizedItem);
                    normalizedItem.keyPath = keyPath;
                    if (map[key]) { // 允许重复key
                        map[this.keyPathToString(keyPath)] = normalizedItem;
                    }
                    else {
                        map[key] = normalizedItem;
                    }

                    if (leaf && (!children || !children.length)) {
                        flatten.push([...parents.slice(1), normalizedItem]);
                    }
                    else if (!leaf) {
                        flatten.push([...parents.slice(1), normalizedItem]);
                    }

                    return normalizedItem;
                },
                exit(item, {result, childrenResult, parents}) {
                    if (!result.checked && childrenResult) {
                        result.checked = childrenResult.every(c => c.checked);
                        if (!result.checked) {
                            result.indeterminate = childrenResult.some(c => c.checked || c.indeterminate);
                        }
                    }
                    if (result.checked && result.key !== ROOT_VALUE) {
                        normalizedCheckedKeys.push(result.key);
                    }
                    result.children = childrenResult;
                }
            }
        );
        this.map = map;
        this.flatten = flatten;
        this.checkedKeys = this.keepKeysOrder(normalizedCheckedKeys, checkedKeys);
    }

    getKeyPath(option: TreeNode) {
        const keys = [option.key];
        option = option.parent;
        while (option && option.key !== ROOT_VALUE) {
            keys.unshift(option.key);
            option = option.parent;
        }
        return keys;
    }

    map;
    flatten;
    checkedKeys;
    tree;
    root;

    keyPathToString(keyPath) {
        return keyPath && '_ONE_' + keyPath.join('_');
    }

    getNormalizedOption(key, keyPath?) {
        const path = this.keyPathToString(keyPath);
        const option = this.map[key];
        if (option && path && this.map[path]) {
            return this.map[path];
        }
        return option;
    }

    getNormalizedOptionWithParent(key) {
        let option = this.getNormalizedOption(key);
        const path = [];
        while (option && option.key !== ROOT_VALUE) {
            path.unshift(option);
            option = option.parent;
        }
        return path.length ? path : null;
    }

    getKeyWithParent(key, keyPath) {
        let option = this.getNormalizedOption(key, keyPath);
        const path = [];
        while (option && option.key !== ROOT_VALUE) {
            path.unshift(option.key);
            option = option.parent;
        }
        return path.length ? path : null;
    }

    getNormalizedOptions(keys, isPath?) {
        return keys
            .map((key, index) => this.getNormalizedOption(key, isPath ? keys.slice(0, index + 1) : undefined))
            .filter(Boolean);
    }

    getOption(key, keyPath?) {
        const item = this.getNormalizedOption(key, keyPath);
        if (item) {
            return item.item;
        }
    }

    getOptions(keys) {
        return keys.map(key => this.getOption(key)).filter(Boolean);
    }

    getPathOptions(keyPath) {
        return keyPath.map((key, i) => this.getOption(key, keyPath.slice(0, i + 1))).filter(Boolean);
    }

    getOptionWithParent(key, keyPath?) {
        let option = this.getNormalizedOption(key, keyPath);
        const path = [];
        while (option && option.key !== ROOT_VALUE) {
            path.unshift(option.item);
            option = option.parent;
        }
        return path.length ? path : null;
    }

    getOptionsWithParent(keys) {
        return keys.map(key => this.getOptionWithParent(key)).filter(Boolean);
    }

    /**
     * 获取当前key路径中的兄弟节点
     */
    getColumns(key, keyPath, showCheckAll, group) {
        let item = this.getNormalizedOption(key, keyPath) || this.tree[0];
        const columns = [];
        while (item) {
            if (item.children
                && item.children.length
                && item.expandType !== 'inline'
                && item.expandType !== 'toggle'
            ) {
                columns.unshift([...item.children]);
            }
            item = item.parent;
        }
        if (showCheckAll) {
            const root = {...this.tree[0]};
            delete root.children;
            columns[0].unshift(root);
        }
        if (group) {
            columns.splice(1, 1);
        }
        return columns;
    }

    getCheckedKeys() {
        return this.checkedKeys.filter(key => this.getOption(key).selectable !== false);
    }

    /**
     * 搜索
     *
     * @param {string} query
     * @returns
     */
    search(query, config: SearchConfig = {}) {
        const {
            filter,
            sort
        } = config;
        return this.flatten
            .filter(path => {
                if (filter) {
                    return filter(query, path.map(node => node.item));
                }
                if (last<TreeNode>(path).selectable === false) {
                    return false;
                }
                return path.some(option => typeof option.label === 'string' && option.label.includes(query));
            })
            .sort((a, b) => {
                if (sort) {
                    return sort(a.item, b.item, query);
                }
                return a.findIndex(o => typeof o.label === 'string' && o.label.includes(query))
                    - b.findIndex(o => typeof o.label === 'string' && o.label.includes(query));
            });
    }

    toggleChecked(key, checkedKeys?) {
        const item = this.getNormalizedOption(key);
        if (!item) {
            return checkedKeys|| this.getCheckedKeys();
        }

        checkedKeys = checkedKeys || this.checkedKeys;
        const checked = !(item.checked || item.indeterminate);
        // 设置当前节点与子节点的状态
        walk(
            [item],
            {
                enter(item) {
                    if (item.disabled) {
                        return;
                    }
                    item.checked = checked;
                    const key = item.key;
                    if (checked) {
                        if (key !== ROOT_VALUE) {
                            checkedKeys.push(key);
                        }
                    }
                    else {
                        checkedKeys = checkedKeys.filter(k => k !== key);
                    }
                }
            }
        );
        const normalizedCheckedKeys = [];
        walk(
            this.tree,
            {
                enter(item) {
                    if (!item.children || !item.children.length) {
                        item.checked = checkedKeys.includes(item.key);
                        if (item.checked && item.key !== ROOT_VALUE) {
                            normalizedCheckedKeys.push(item.key);
                        }
                    }
                },
                exit(item) {
                    const children = item.children;
                    if (children && children.length) {
                        item.checked = children.every(c => c.checked);
                        item.indeterminate = false;
                        if (!item.checked) {
                            item.indeterminate = children.some(c => c.checked || c.indeterminate);
                        }
                        else if (item.key !== ROOT_VALUE) {
                            normalizedCheckedKeys.push(item.key);
                        }
                    }
                }
            }
        );

        this.checkedKeys = this.keepKeysOrder(normalizedCheckedKeys, checkedKeys);
        return this.getCheckedKeys();
    }

    /**
     * 保持选择顺序
     *
     * @param {Array} keys
     * @param {Array} orderedKeys
     * @returns
     */
    keepKeysOrder(keys, orderedKeys) {
        const resultKeys = orderedKeys.filter(key => keys.includes(key));
        return resultKeys.concat(keys.filter(key => !resultKeys.includes(key)));
    }
}