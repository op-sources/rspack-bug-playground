/**
 * @file 公用工具方法入口
 * @author huangshiming
 * @date 2020-04-29
 */
/**
 * 定义组件的size和prefixCls等全局变量
 * @param {Object} 组件的props
 * @param {Object} 顶层context变量
 * @return {Object} 格式化后的size和prefixCls
 */
export const defaultPrefixCls = 'one';
export const defaultSize = 'medium';
export const locationRemoveProps = [
    'location', 'tipLocation', 'errorLocation', 'tipText'
];

export const formatCommonConfig = (
    props, consumerConfig = {}
) => {
    const {size, prefixCls, suffixCls} = props;
    const consumerSize = consumerConfig.size;
    const consumerPrefixCls = consumerConfig.prefixCls;
    const prefix = consumerPrefixCls || defaultPrefixCls;
    return {
        size: size || consumerSize || defaultSize,
        prefixCls: prefixCls || `${prefix}-${suffixCls}`
    };
};

/**
 * 获取classNams
 * @return {string} classNames集合
 */
export function classnames(...rest) {
    let classes = [];
    for (let i = 0; i < rest.length; i++) {
        const arg = rest[i];
        if (!arg) {
            continue;
        }
        const argType = typeof arg;
        if (argType === 'string' || argType === 'number') {
            classes.push(arg);
        }
        else if (Array.isArray(arg) && arg.length) {
            classes = [...classes, ...arg];
        }
        else if (argType === 'object') {
            Object.keys(arg).forEach(key => {
                if (arg[key]) {
                    classes.push(key);
                }
            });
        }
    }
    return classes.join(' ');
}

export const partial = function (fn, ...partialArgs) {
    let args = partialArgs;
    return function (...fullArguments) {
        let arg = 0;
        for (let i = 0; i < args.length && arg < fullArguments.length; i++) {
            if (args[i] === undefined) {
                args[i] = fullArguments[arg++];
            }
        }

        return fn.apply(null, args);
    };
};

export const handleCountTips = (currentLine, maxLine) => (maxLine != null ? `${currentLine}/${maxLine}` : null);

export const COUNT_MODE = {
    CHINA: 'cn',
    ENGLISH: 'en'
};

export const CHINA_COUNT_MODE = COUNT_MODE.CHINA;
export const ENGLISH_COUNT_MODE = COUNT_MODE.ENGLISH;

const handleFilter = (str = '', arr = []) => {
    arr.forEach(element => {
        if (typeof element === 'string') {
            str = str.replace(new RegExp(element, 'g'), '');
        }
    });
    return str;
};

const toString = Object.prototype.toString;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function getTag(value) {
    if (value == null) {
        return value === undefined ? '[object Undefined]' : '[object Null]';
    }
    return toString.call(value);
}

export const isString = value => {
    const type = typeof value;
    return type === 'string'
        || (type === 'object' && value != null && !Array.isArray(value)
        && getTag(value) === '[object String]');
};

export const isObjectLike = value => {
    return typeof value === 'object' && value !== null;
};

export const isNumber = value => {
    return typeof value === 'number' || (isObjectLike(value) && getTag(value) === '[object Number]');
};

export const getLengthInBytes = (str, needTrim = true, filterArray = [], countMode = CHINA_COUNT_MODE) => {
    if (str == null) {
        return 0;
    }
    if (!isString(str) && !isNumber(str)) {
        throw new Error('传入的数据为非字符串或数字');
    }

    str = String(str);

    if (needTrim) {
        str = `${str}`.trim();
    }

    if (filterArray.length) {
        str = handleFilter(str, filterArray);
    }
    if (countMode === CHINA_COUNT_MODE) {
        return str.replace(/[^\x00-\xff]/g, '**').length;
    }
    return str.length;
};

export const getRealLength = ({getLength, filterArray, countMode}, value) => (
    getLength ? getLength(value) : getLengthInBytes(value, false, filterArray, countMode)
);

export const handleEventParams = (e = {}, that) => {
    const {value, errorMessage} = that.state;
    e.value = value;
    e.errorMessage = errorMessage;
    return e;
};

export function flatFilter(tree, callback) {
    return tree.reduce((acc, node) => {
        if (callback(node)) {
            acc.push(node);
        }
        if (node.children) {
            const children = flatFilter(node.children, callback);
            acc.push(...children);
        }
        return acc;
    }, []);
}

export function createStore(initialState) {
    let state = initialState;
    const listeners = [];
    function setState(partial) {
        state = {
            ...state,
            ...partial
        };
        for (let i = 0; i < listeners.length; i++) {
            listeners[i]();
        }
    }
    function getState() {
        return state;
    }
    function subscribe(listener) {
        listeners.push(listener);
        return function unsubscribe() {
            const index = listeners.indexOf(listener);
            listeners.splice(index, 1);
        };
    }
    return {
        setState,
        getState,
        subscribe
    };
}

export function treeMap(tree, mapper, childrenName = 'children', parentNode) {
    return tree.map((node, index) => {
        const newNode = mapper(node, index, parentNode) || {};
        const children = node[childrenName];
        if (children && children.length > 0) {
            newNode[childrenName] = treeMap(children, mapper, childrenName, newNode);
        }
        return newNode;
    });
}

export function flatArray(data, childrenName = 'children') {
    const result = [];
    const loop = array => {
        array.forEach(item => {
            if (item[childrenName]) {
                const newItem = {...item};
                delete newItem[childrenName];
                result.push(newItem);
                if (item[childrenName].length > 0) {
                    loop(item[childrenName]);
                }
            }
            else {
                result.push(item);
            }
        });
    };
    loop(data);
    return result;
}

export const stopPropagation = e => {
    e.stopPropagation();
    if (e && e.nativeEvent && e.nativeEvent.stopImmediatePropagation) {
        e.nativeEvent.stopImmediatePropagation();
    }
};

export function remove(array, item) {
    const index = array.indexOf(item);
    const front = array.slice(0, index);
    const last = array.slice(index + 1, array.length);
    return front.concat(last);
}

export const getScroll = (target, top) => {
    if (typeof window === 'undefined') {
        return 0;
    }
    const prop = top ? 'pageYOffset' : 'pageXOffset';
    const method = top ? 'scrollTop' : 'scrollLeft';
    const isWindow = target === window;
    let ret = isWindow ? target[prop] : target[method];
    // ie6,7,8 standard mode
    if (isWindow && typeof ret !== 'number') {
        ret = document.documentElement[method];
    }
    return ret;
};

export const intersperseSpace = list => {
    return list.reduce((current, item) => [...current, ' ', item], []).slice(1);
};

/**
 * 判断一个元素是否匹配某个指定的选择器。

 * @param {Element} elem 指定元素
 * @param {string} selector 选择器字符串
 * @return {boolean} 是否匹配
 */
export function matches(elem, selector) {
    const match = (
        elem.matches
        || elem.matchesSelector
        || elem.mozMatchesSelector
        || elem.msMatchesSelector
        || elem.oMatchesSelector
        || elem.webkitMatchesSelector
    );
    return match ? match.call(elem, selector) : false;
}

const FOCUSABLE_SELECTOR = `
a[href],
area[href],
input:not([disabled]),
select:not([disabled]),
textarea:not([disabled]),
button:not([disabled]),
iframe,
[tabindex],
[contentEditable=true]`;

function isPreventFocus(el) {
    return (
        !matches(el, '[tabindex="-1"]')
        && (el.offsetWidth || el.offsetHeight || el.getClientRects().length)
    );
}

// 代码来自veui
export function isFocusable(el) {
    return matches(el, FOCUSABLE_SELECTOR) && isPreventFocus(el);
}

// 浏览器视口的高度
export function getWindowHeight() {
    if (!window) {
        return 0;
    }
    let windowHeight = 0;
    const document = window.document;
    if (document.compatMode === 'CSS1Compat') {
        windowHeight = document.documentElement.clientHeight;
    }
    else {
        windowHeight = document.body.clientHeight;
    }
    return windowHeight;
}

export const windowIsUndefined = !(
    typeof window !== 'undefined'
    && window.document
    && window.document.createElement
);

let PASSIVESUPPORTED = false;
if (!windowIsUndefined) {
    window.addEventListener(
        'test',
        () => { },
        Object.defineProperty({}, 'passive', {
            get: () => {
                PASSIVESUPPORTED = true;
                return null;
            }
        }),
    );
}
export const passiveSupported = PASSIVESUPPORTED;

// copy from veui dom util
export function isInsideTransformedContainer(el) {
    let current = el.parentElement;
    while (current) {
        let styles = window.getComputedStyle(current);
        if (styles.transform !== 'none' || styles.transformStyle !== 'flat') {
            return true;
        }
        current = current.parentElement;
    }
    return false;
}

function getNavigator(key) {
    // 为了支持 ssr，需要判断下有没有 bom
    return typeof navigator === 'undefined' ? undefined : navigator[key];
}

export function isSafari() {
    return /apple/i.test(getNavigator('vendor'));
}
