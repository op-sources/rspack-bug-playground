import React, {cloneElement, isValidElement, PureComponent, ReactNode} from 'react';
import Grid from '../grid';
import {intersperseSpace, classnames} from '../../core/commonTools';
import {FormContext} from './context';
import {FormItemProps} from './interface';

const {
    Row,
    Col
} = Grid;

export const FIELD_META_PROP = 'data-__meta';
export const FIELD_DATA_PROP = 'data-__field';

class FormItem extends PureComponent<FormItemProps> {

    static defaultProps = {
        prefixCls: 'one-form',
        className: '',
        style: {},
        extralPlacemenet: 'left'
    }

    static contextType = FormContext;

    helpShow = false;

    getHelpMessage = () => {
        const help = this.props.help;
        if (help === undefined && this.getOnlyControl()) {
            const errors = this.getField().errors;
            if (errors) {
                return intersperseSpace(
                    errors.map((e, index) => {
                        let node = null;
                        if (isValidElement(e)) {
                            node = e;
                        } else if (isValidElement(e.message)) {
                            node = e.message;
                        }
                        return node ? cloneElement(node, {key: index}) : e.message;
                    })
                );
            }
            return '';
        }
        return help;
    }

    getControls = (children, recursively) => {
        let controls = [];
        const childrenArray = React.Children.toArray(children);
        for (let i = 0; i < childrenArray.length; i++) {
            if (!recursively && controls.length > 0) {
                break;
            }
            const child = childrenArray[i];
            if (!isValidElement(child) || (isValidElement(child) && child.type === FormItem)) {
                continue;
            }
            if (FIELD_META_PROP in child.props) {
                controls.push(child);
            } else if (child.props.children) {
                controls = controls.concat(this.getControls(child.props.children, recursively));
            }
        }
        return controls;
    }

    getOnlyControl = () => {
        const child = this.getControls(this.props.children, false)[0];
        return child !== undefined ? child : null;
    }

    getChildProp = prop => {
        const child = this.getOnlyControl();
        if (isValidElement(child)) {
            return child.props[prop];
        }
        return null;
    }

    getId = (): string => {
        return this.getChildProp('id');
    }

    getMeta = () => {
        return this.getChildProp(FIELD_META_PROP);
    }

    getField = () => {
        return this.getChildProp(FIELD_DATA_PROP);
    }

    renderHelp(): ReactNode {
        const help = this.getHelpMessage();
        if (help) {
            return (
                <div className={`${this.props.prefixCls}-explain`} key="help">
                    {help}
                </div>
            );
        }
        return null;
    }

    renderExtra(): ReactNode {
        const {
            prefixCls,
            extra
        } = this.props;
        return extra ? <div className={`${prefixCls}-extra`}>{extra}</div> : null;
    }

    getValidateStatus() {
        const onlyControl = this.getOnlyControl();
        if (!onlyControl) {
            return '';
        }
        const field = this.getField();
        if (field.validating) {
            return 'validating';
        }
        if (field.errors) {
            return 'error';
        }
        const fieldValue = 'value' in field ? field.value : this.getMeta().initialValue;
        if (fieldValue !== undefined && fieldValue !== null && fieldValue !== '') {
            return 'success';
        }
        return '';
    }

    renderControl() {
        const {
            prefixCls,
            children,
            wrapperCol,
            extralPlacemenet,
            validateStatus: validateStatusProp
        } = this.props;

        const {
            wrapperCol: contextWrapperCol,
            vertical
        } = this.context;

        const mergedWrapperCol = ('wrapperCol' in this.props ? wrapperCol : contextWrapperCol) || {};
        const className = classnames(
            `${prefixCls}-item-control-wrapper`,
            mergedWrapperCol.className,
        );

        const onlyControl = this.getOnlyControl;
        const validateStatus = validateStatusProp === undefined && onlyControl
            ? this.getValidateStatus()
            : validateStatusProp;
        let classes = `${prefixCls}-item-control`;
        if (validateStatus) {
            classes = classnames(`${prefixCls}-item-control`, {
                [`${prefixCls}-has-success`]: validateStatus === 'success',
                [`${prefixCls}-has-warning`]: validateStatus === 'warning',
                [`${prefixCls}-has-error`]: validateStatus === 'error',
                [`${prefixCls}-is-validating`]: validateStatus === 'validating'
            },
            `${prefixCls}-item-explain-${extralPlacemenet}`
            );
        }

        // 其他context不整体往下传
        return (
            <FormContext.Provider value={{vertical}}>
                <Col {...mergedWrapperCol} className={className}>
                    <div className={classes}>
                        <span className={`${prefixCls}-item-children`}>
                            {children}
                        </span>
                        {this.renderHelp()}
                        {this.renderExtra()}
                    </div>
                </Col>
            </FormContext.Provider>
        );
    }

    isRequired = () => {
        const required = this.props.required;
        if (required !== undefined) {
            return required;
        }
        if (this.getOnlyControl()) {
            const meta = this.getMeta() || {};
            const validate = meta.validate || [];
            return validate
                .filter(item => !!item.rules)
                .some(item => {
                    return item.rules.some(rule => rule.required);
                });
        }
        return false;
    }

    renderLabel() {
        const {
            prefixCls,
            label,
            labelCol,
            labelAlign,
            colon,
            id,
            htmlFor
        } = this.props;

        if (!label) {
            return null;
        }

        const {
            vertical,
            labelAlign: contextLabelAlign,
            labelCol: contextLabelCol,
            colon: contextColon
        } = this.context;

        const required = this.isRequired();
        const mergedLabelCol = ('labelCol' in this.props ? labelCol : contextLabelCol) || {};
        const mergedLabelAlign = 'labelAlign' in this.props ? labelAlign : contextLabelAlign;
        const labelClsBasic = `${prefixCls}-item-label`;
        const labelColClassName = classnames(
            labelClsBasic,
            mergedLabelAlign === 'left' && `${labelClsBasic}-left`,
            mergedLabelCol.className,
        );
        let labelChildren = label;
        // Keep label is original where there should have no colon
        const computedColon = colon === true || (contextColon !== false && colon !== false);
        const haveColon = computedColon && !vertical;
        // Remove duplicated user input colon
        if (haveColon && typeof label === 'string' && label.trim() !== '') {
            labelChildren = label.replace(/[：|:]\s*$/, '');
        }
        const labelClassName = classnames({
            [`${prefixCls}-item-required`]: required,
            [`${prefixCls}-item-no-colon`]: !computedColon
        });

        return (
            <Col {...mergedLabelCol} className={labelColClassName}>
                <label
                    htmlFor={htmlFor || id || this.getId()}
                    className={labelClassName}
                    title={typeof label === 'string' ? label : ''}
                >
                    {labelChildren}
                </label>
            </Col>
        );
    }

    render() {
        const {
            prefixCls,
            style,
            className
        } = this.props;
        return (
            <Row
                className={classnames({
                    [`${prefixCls}-item`]: true,
                    [`${prefixCls}-item-with-help`]: this.helpShow,
                    [`${className}`]: !!className
                })}
                style={style}
            >
                {this.renderLabel()}
                {this.renderControl()}
            </Row>
        );
    }
}

export default FormItem;
