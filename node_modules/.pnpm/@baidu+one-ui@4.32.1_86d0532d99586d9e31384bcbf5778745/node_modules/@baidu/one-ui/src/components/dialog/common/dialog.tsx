import React, {Component, CSSProperties} from 'react';
import KeyCode from 'rc-util/lib/KeyCode';
import contains from 'rc-util/lib/Dom/contains';
import {IconTimes} from 'dls-icons-react';
import LazyRenderBox from './lazyRenderBox';
import {classnames} from '../../../core/commonTools';
import Button from '../../button';
import {lockManager} from '../../../util/scrollbar';
import {some, identity} from 'lodash';
import {DialogProps} from '../interface';

let uuid = 0;
let modalMap = {};

export interface InnerDialogProps extends
    Omit<DialogProps,
        'centered'
        | 'className'
        | 'buttonPosition'
        | 'destroyOnClose'
        | 'size'
        | 'fullScreen'
        | 'okOrder'
        | 'cancelOrder'
    > {
        forceRender?: boolean;

        closable?: boolean;

        /**
         * 弹窗关闭触发
         */
        onClose?(e);
    };

export default class Dialog extends Component<InnerDialogProps> {

    static defaultProps = {
        className: '',
        mask: true,
        visible: false,
        keyboard: true,
        closable: true,
        maskClosable: true,
        destroyOnClose: false,
        visibleControlledWhenClose: false,
        maskClassName: ''
    }

    titleId = null;

    wrap = null;

    timeoutId = null;

    dialogMouseDown = null;

    openTime = null;

    lastOutSideFocusNode = null;

    inTransition;
    sentinelStart;

    componentDidMount() {
        const {
            forceRender
        } = this.props;
        this.titleId = `dialogTitle${uuid++}`;
        this.componentDidUpdate({});
        if (forceRender && this.wrap) {
            this.wrap.style.display = 'none';
        }
        this.toggleScrollLock();
    }

    toggleScrollLock(unmount?) {
        const {mask, visible} = this.props;
        if (unmount) {
            delete modalMap[this.titleId];
        }
        else {
            modalMap[this.titleId] = mask && visible && this.wrap.style.display !== 'none';
        }
        if (some(modalMap, identity)) {
            lockManager.lock();
        }
        else {
            lockManager.unlock();
        }
    }

    componentDidUpdate = prevProps => {
        const {
            visible,
            mask
        } = this.props;
        if (visible) {
            if (!prevProps.visible) {
                this.openTime = Date.now();
                this.tryFocus();
            }
        }
        else if (prevProps.visible) {
            this.inTransition = true;
            if (mask && this.lastOutSideFocusNode) {
                try {
                    this.lastOutSideFocusNode.focus();
                }
                catch (e) {
                    this.lastOutSideFocusNode = null;
                }
                this.lastOutSideFocusNode = null;
            }
        }
        this.toggleScrollLock();
    }

    componentWillUnmount() {
        clearTimeout(this.timeoutId);
        this.toggleScrollLock(true);
    }

    tryFocus() {
        if (!contains(this.wrap, document.activeElement)) {
            this.lastOutSideFocusNode = document.activeElement;
            this.sentinelStart.focus();
        }
    }

    onDialogMouseDown = () => {
        this.dialogMouseDown = true;
    }

    onMaskMouseUp = () => {
        if (this.dialogMouseDown) {
            this.timeoutId = setTimeout(() => {
                this.dialogMouseDown = false;
            }, 0);
        }
    }

    onMaskClick = e => {
        if (Date.now() - this.openTime < 300) {
            return;
        }
        if (e.target === e.currentTarget && !this.dialogMouseDown) {
            this.close(e);
        }
    }

    onKeyDown = e => {
        const props = this.props;
        if (props.keyboard && e.keyCode === KeyCode.ESC) {
            e.stopPropagation();
            this.close(e);
        }
    }

    getZIndexStyle = () => {
        const style: CSSProperties = {};
        const props = this.props;
        if (props.zIndex !== undefined) {
            style.zIndex = props.zIndex;
        }
        return style;
    }

    getWrapStyle = (): CSSProperties => {
        return {
            ...this.getZIndexStyle(),
            ...this.props.wrapStyle
        };
    }

    saveRef = name => node => {
        this[name] = node;
    }

    getMaskElement = () => {
        const props = this.props;
        let maskElement = null;
        if (props.mask) {
            maskElement = (
                <LazyRenderBox
                    style={props.maskStyle}
                    key="mask"
                    className={classnames(`${props.prefixCls}-mask`, props.maskClassName)}
                    hiddenClassName={`${props.prefixCls}-mask-hidden`}
                    visible={props.visible}
                    {...props.maskProps}
                />
            );
        }
        return maskElement;
    }

    getDialogElement = () => {
        const {
            closable,
            needCloseIcon,
            prefixCls,
            width,
            height,
            title,
            visible,
            children,
            bodyStyle,
            bodyProps,
            contentClassName
        } = this.props;
        const dest: CSSProperties = {};
        if (width !== undefined) {
            dest.width = width;
        }
        if (height !== undefined) {
            dest.height = height;
        }
        let footer;
        let hasFooter = !!this.props.footer;
        if (Array.isArray(this.props.footer) && !this.props.footer.length) {
            hasFooter = false;
        }
        if (hasFooter) {
            footer = (
                <div className={`${prefixCls}-footer`} ref={this.saveRef('footer')}>
                    {this.props.footer}
                </div>
            );
        }
        let closer;
        if (closable && needCloseIcon) {
            closer = (
                <Button
                    type="text-aux"
                    onClick={this.close}
                    className={`${prefixCls}-close`}
                >
                    <IconTimes />
                </Button>
            );
        }

        let header;
        if (title || closer) {
            header = (
                <div className={`${prefixCls}-header`} ref={this.saveRef('header')}>
                    <div className={`${prefixCls}-title`} id={this.titleId}>
                        {title}
                    </div>
                    {closer}
                </div>
            );
        }

        const style = {
            ...this.props.style,
            ...dest
        };
        const sentinelStyle = {width: 0, height: 0, overflow: 'hidden'};
        const contentClsName = classnames(`${prefixCls}-content`, contentClassName);
        return (
            <LazyRenderBox
                key="dialog-element"
                role="document"
                ref={this.saveRef('dialog')}
                style={style}
                className={prefixCls}
                visible={visible}
                onMouseDown={this.onDialogMouseDown}
            >
                <div tabIndex={0} ref={this.saveRef('sentinelStart')} style={sentinelStyle} aria-hidden="true" />
                <div className={contentClsName}>
                    {header}
                    <div
                        className={`${prefixCls}-body`}
                        style={bodyStyle}
                        ref={this.saveRef('body')}
                        {...bodyProps}
                    >
                        {children}
                    </div>
                    {footer}
                </div>
                <div tabIndex={0} ref={this.saveRef('sentinelEnd')} style={sentinelStyle} aria-hidden="true" />
            </LazyRenderBox>
        );
    }

    close = e => {
        const {onClose, afterClose, visibleControlledWhenClose, mask} = this.props;
        if (onClose) {
            onClose(e);
        }
        if (this.wrap && !visibleControlledWhenClose) {
            this.wrap.style.display = 'none';
            this.toggleScrollLock();
        }
        if (afterClose) {
            setTimeout(() => {
                afterClose();
            }, 300);
        }
    }

    render() {
        const props = this.props;
        const {prefixCls, maskClosable} = props;
        const style = this.getWrapStyle();
        if (props.visible) {
            style.display = 'block';
        }
        else {
            style.display = 'none';
        }
        return (
            <div
                tabIndex={-1}
                onKeyDown={this.onKeyDown}
                className={`${prefixCls}-wrap ${props.wrapClassName || ''}`}
                ref={this.saveRef('wrap')}
                onClick={maskClosable ? this.onMaskClick : null}
                onMouseUp={maskClosable ? this.onMaskMouseUp : null}
                role="dialog"
                aria-labelledby={props.title ? this.titleId : null}
                style={style}
                {...props.wrapProps}
            >
                {this.getMaskElement()}
                {this.getDialogElement()}
            </div>
        );
    }
}
