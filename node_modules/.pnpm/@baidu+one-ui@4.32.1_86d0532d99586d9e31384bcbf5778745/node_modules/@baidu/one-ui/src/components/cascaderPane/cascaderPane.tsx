import React, {PureComponent, isValidElement, cloneElement} from 'react';
import {IconChevronRight} from 'dls-icons-react';
import scrollIntoView from 'dom-scroll-into-view';
import {classnames} from '../../core/commonTools';
import IconLoading from '../loading';
import Menu from './menu';
import SearchMenu from './searchMenu';
import CascaderInput, {CascaderInputProps} from './input';
import {Tree} from '../../data/tree';
import {last, isEqual, cloneDeepWith, omit, isEmpty} from 'lodash';
import {CascaderPaneProps} from './interface';
import shallowEqual from 'shallowequal';
import {CascaderOption} from '../cascader/interface';

interface CascaderPaneState {
    value?: Array<string | number>,
    activeValue?: Array<string | number>,
    query?: string,
    options?: [],
    optionsClone?: [],
    checkedKeys?: Array<string | number>,
    showCheckbox?: boolean,
    firstColumnGroup?: boolean,
    changeOnSelect?: boolean,
    showCheckAll?: boolean,
    tree?: Tree;
    columns?: [][];
    searchOptions?: [];
    loadingMap?: Record<string, boolean>;
}

class CascaderPane extends PureComponent<CascaderPaneProps, CascaderPaneState> {

    static defaultProps = {
        options: [],
        prefixCls: 'one-cascader-pane',
        expandTrigger: 'click',
        onSelect() {},
        visible: true,
        fieldNames: {
            label: 'label',
            value: 'value',
            children: 'children',
            icon: 'icon'
        },
        expandIcon: <IconChevronRight />,
        loadingIcon: <IconLoading size="small" />,
        showCheckbox: false,
        checkboxPrefixCls: 'one-checkbox',
        onCheckboxChange() {},
        showSearch: false,
        paneWidth: 360,
        useDefaultFilter: true,
        onInputChange() {},
        emptyNode: '暂无结果',
        emptyType: 'card',
        onClickSearchItem() {},
        firstColumnGroup: false,
        inputType: 'inline',
        showCheckAll: false,
        size: 'medium'
    }

    constructor(props) {
        super(props);
        const value = props.defaultValue || [];
        this.state = {
            value,
            activeValue: value,
            query: props.defaultSearchValue || '',
            options: [],
            optionsClone: [],
            checkedKeys: props.defaultCheckedKeys || [],
            loadingMap: {}
        };
    }

    static getDerivedStateFromProps(props, state) {
        const newState: CascaderPaneState = {};
        const {
            options,
            checkedKeys,
            showCheckAll,
            firstColumnGroup,
            showCheckbox,
            changeOnSelect,
            fieldNames,
            value,
            searchValue,
            useDefaultFilter,
            searchConfig
        } = props;
        let tree = state.tree;
        let buildTree = false;
        let buildColumns = false;
        let buildQuery = false;
        let activeValue = state.activeValue;
        let query = state.query;

        if (!isEqual(options, state.optionsClone)
            || showCheckbox !== state.showCheckbox
            || changeOnSelect !== state.changeOnSelect) {
            newState.optionsClone = cloneDeepWith(
                options, value => isValidElement(value) ? cloneElement(value) : undefined
            );;
            newState.options = options;
            newState.showCheckbox = showCheckbox;
            newState.changeOnSelect = changeOnSelect;
            buildTree = true;
        }

        if ('checkedKeys' in props
            && (!shallowEqual(checkedKeys, state.checkedKeys)
                || (tree && !shallowEqual(checkedKeys, tree.checkedKeys)))) {
            newState.checkedKeys = checkedKeys;
            buildTree = true;
        }

        if (buildTree) {
            tree = new Tree(
                options,
                checkedKeys || state.checkedKeys,
                fieldNames,
                !showCheckbox && !changeOnSelect
            );
            newState.tree = tree;
        }

        if (firstColumnGroup !== state.firstColumnGroup
            || showCheckbox !== state.showCheckbox
            || showCheckAll !== state.showCheckAll) {
            newState.firstColumnGroup = firstColumnGroup;
            newState.showCheckbox = showCheckbox;
            newState.showCheckAll = showCheckAll;
            buildColumns = true;
        }

        if ('value' in props && !shallowEqual(value || [], state.value)) {
            activeValue = value || [];
            newState.value = activeValue;
            newState.activeValue = activeValue;
            buildColumns = true;
        }

        if (buildTree || buildColumns) {
            newState.columns = tree.getColumns(last(activeValue), activeValue, showCheckAll, firstColumnGroup === true);
        }

        if ('searchValue' in props && searchValue !== state.query) {
            query = searchValue;
            newState.query = searchValue;
            buildQuery = true;
        }

        if (useDefaultFilter && (buildTree || buildColumns || buildQuery)) {
            newState.searchOptions = query ? tree.search(query, searchConfig) : [];
        }

        return newState;
    }

    prefix(name) {
        return `${this.props.prefixCls}-${name}`;
    }

    render() {
        const {
            prefixCls,
            className,
            showSearch,
            showCheckbox,
            size,
            style
        } = this.props;
        const paneClassName = classnames(
            className,
            prefixCls,
            this.prefix(size),
            {
                [this.prefix('show-search')]: showSearch,
                [this.prefix('multiple')]: showCheckbox
            }
        );
        return (
            <div className={paneClassName} style={style}>
                {this.renderSearch()}
                {this.renderMenu()}
            </div>
        );
    }

    renderMenu() {
        const {
            columns,
            activeValue,
            value,
            query,
            searchOptions,
            loadingMap
        } = this.state;
        const {
            prefixCls,
            size,
            expandIcon,
            loadingIcon,
            showCheckbox,
            checkboxPrefixCls,
            cascaderPaneStyle,
            useDefaultFilter,
            showSearch,
            searchConfig = {},
            paneWidth,
            menuWidth,
            expandTrigger,
            emptyNode,
            emptyType,
            CustomItemRender,
            firstColumnGroup,
            renderOption,
            columnHeader,
            columnFooter,
            header,
            footer
        } = this.props;
        if (columns.length === 0 || (query && useDefaultFilter)) {
            return (
                <SearchMenu
                    prefixCls={prefixCls}
                    style={cascaderPaneStyle}
                    size={size}
                    width={searchConfig.matchInputWidth === false ? undefined : paneWidth}
                    options={searchOptions}
                    emptyNode={emptyNode}
                    emptyType={emptyType}
                    onSelect={this.handleOnSelect}
                    onCheck={this.handleOnCheck}
                    showCheckbox={showCheckbox}
                    query={query}
                    renderLabel={searchConfig.render}
                />
            );
        }
        const width = (showSearch && paneWidth) ? paneWidth : null;
        return (
            <Menu
                prefixCls={prefixCls}
                style={cascaderPaneStyle}
                size={size}
                width={width}
                columnWidth={menuWidth}
                columns={columns}
                value={value}
                activeValue={activeValue}
                expandIcon={expandIcon}
                loadingIcon={loadingIcon}
                loadingMap={loadingMap}
                onSelect={this.handleOnSelect}
                onHover={this.handleOnHover}
                onCheck={this.handleOnCheck}
                showCheckbox={showCheckbox}
                checkboxPrefixCls={checkboxPrefixCls}
                expandTrigger={expandTrigger}
                firstColumnGroup={firstColumnGroup}
                CustomItemRender={CustomItemRender}
                columnHeader={columnHeader}
                columnFooter={columnFooter}
                header={header}
                footer={footer}
                forwardRef={this.saveMenuRef}
                renderOption={renderOption}
            />
        );
    }

    menuRef;

    saveMenuRef = ref => {
        this.menuRef = ref;
    };

    componentDidMount() {
        this.scrollActiveItemToView();
    }

    componentDidUpdate(preProps) {
        const {
            visible,
            value,
            options
        } = this.props;
        if (!visible) {
            return;
        }
        if (!preProps.visible
            || (isEmpty(preProps.value) && !isEmpty(value))
            || (isEmpty(preProps.options) && !isEmpty(options))) {
            this.scrollActiveItemToView();
        }
    }

    scrollActiveItemToView() {
        const menu = this.menuRef;
        if (menu) {
            menu.querySelectorAll('.' + this.prefix('menu')).forEach(col => {
                const item = col.querySelector('.' + this.prefix('menu-item-active'));
                if (item) {
                    scrollIntoView(item, col, {
                        onlyScrollIfNeeded: true
                    });
                }
            });
        }
    }

    renderSearch() {
        const {
            paneWidth,
            inputType,
            searchProps,
            showSearch
        } = this.props;

        if (!showSearch) {
            return null;
        }

        const props: CascaderInputProps = {
            width: paneWidth,
            onInputChange: this.onInputChange,
            inputType,
            value: this.state.query
        };
        if (searchProps) {
            props.searchProps = searchProps;
        }
        return <CascaderInput {...props} />;
    }

    onInputChange = e => {
        this.props.onInputChange(e);
        const query = e.value;
        if (!('searchValue' in this.props)) {
            this.setState({
                query
            });
            this.setSearchOptions(query);
        }
    }

    setSearchOptions(query) {
        const {
            useDefaultFilter,
            searchConfig
        } = this.props;
        const searchOptions = typeof searchConfig === 'boolean' ? undefined : searchConfig;
        if (useDefaultFilter) {
            this.setState({
                searchOptions: query ? this.state.tree.search(query, searchOptions) : []
            });
        }
    }

    setColumns(key, keyPath?) {
        const {
            tree
        } = this.state;
        const {
            showCheckAll,
            firstColumnGroup
        } = this.props;

        this.setState({
            columns: tree.getColumns(key, keyPath, showCheckAll, firstColumnGroup === true)
        });
    }

    handleOnHover = (key, keyPath, columnIndex) => {
        const {
            tree
        } = this.state;

        const {
            onHover
        } = this.props;

        const activeValue = tree.getKeyWithParent(key, keyPath);

        this.setState({
            activeValue
        });
        this.setColumns(key, keyPath);

        const option = tree.getNormalizedOption(key, keyPath);
        this.loadData(option, 'children', 'expand');

        onHover && onHover(tree.getOption(key, keyPath), columnIndex, activeValue);
    }

    loadData(option: CascaderOption, trigger, scope) {
        const {
            isLeaf,
            key,
            children
        } = option;
        const {
            loadData
        } = this.props;
        const {
            loadingMap,
            tree
        } = this.state;
        if (loadData && isLeaf === false && !children) {
            if (loadingMap[key]) {
                return;
            }
            const promise = loadData({
                parent: option.item,
                value: tree.getKeyPath(option),
                trigger,
                scope
            });
            if (promise && promise.finally) {
                loadingMap[key] = true;
                this.setState({
                    loadingMap: {
                        ...loadingMap,
                        [key]: true
                    }
                });
                promise.finally(() => {
                    this.setState({
                        loadingMap: omit(this.state.loadingMap, [key])
                    });
                });
            }
        }
    }

    handleOnSelect = (key, keyPath, columnIndex?) => {
        const {
            tree,
            query
        } = this.state;

        const {
            onSelect,
            onClickSearchItem,
            showCheckbox
        } = this.props;

        const value = tree.getKeyWithParent(key, keyPath) || [];
        this.setState({
            activeValue: value
        });

        const option = tree.getNormalizedOption(key, keyPath);
        const isInline = option.expandType === 'inline' || option.expandType === 'toggle';
        if (!isInline) {
            this.setColumns(key, keyPath);
        }

        this.loadData(option, 'children', 'expand');

        if (option.disabled || isInline) {
            return;
        }

        if (!('searchValue' in this.props) && query && !showCheckbox) {
            this.setState({
                query: '',
                searchOptions: []
            });
        }

        if (!('value' in this.props)) {
            this.setState({
                value
            });
        }

        onSelect && onSelect(tree.getOption(key, keyPath), columnIndex, value);
        if (query && onClickSearchItem) {
            onClickSearchItem(tree.getOptionWithParent(key, keyPath));
        }
    }

    handleOnCheck = key => {
        const {
            tree,
            query
        } = this.state;
        const {
            onCheckboxChange
        } = this.props;
        const checkedKeys = tree.toggleChecked(key);
        if (!('checkedKeys' in this.props)) {
            this.setState({
                checkedKeys
            });
            this.setColumns(key);
            this.setSearchOptions(query);
        }

        const option = tree.getNormalizedOption(key);
        this.loadData(option, 'descendants', 'check');

        onCheckboxChange && onCheckboxChange(checkedKeys);
    }
}

export default CascaderPane;
