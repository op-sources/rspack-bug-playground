import React, {Component} from 'react';
import {onMouseDown} from '../../../core/dragTools';
import {classnames, isFocusable} from '../../../core/commonTools';
import shallowEqual from 'shallowequal';
import {isEqual} from 'lodash';
import {InnerTableColumnProps} from './interface';

interface HeaderCellProps {
    prefixCls?: string,
    className?: string,
    render?(column: InnerTableColumnProps),
    column?: InnerTableColumnProps,
    index?: number,
    left?: number,
    onMoving?(e: {key: string, width: number}),
    width?: number,
    onDragEnd?(),
    onDragStart?(),
    maxWidth?,
    minWidth?,
    onHeaderCellMouseEnter?(e: {key: string}),
    onHeaderCellMouseLeave?(e: {key: string}),
    dynamicWidth?
}

class HeaderCell extends Component<HeaderCellProps> {

    static defaultProps = {
        column: {}
    }

    shouldComponentUpdate(nextProps) {
        return !shallowEqual(nextProps, this.props, (a, b, key) => {
            if (key === 'column') {
                return isEqual(a, b);
            }
        });
    }

    positionObj;
    dragging;
    cellRef;
    customProps;

    onDropped = () => {
        this.positionObj = {
            position: {},
            cellWidth: this.cellRef.offsetWidth
        };
        setTimeout(() => {
            this.dragging = false;
        }, 0);
        this.props.onDragEnd();
    };

    onDragged = props => {
        this.positionObj = {
            position: props.position,
            cellWidth: this.cellRef.offsetWidth
        };
        this.dragging = true;
        this.props.onDragStart();
    };

    onMoving = props => {
        const {maxWidth, minWidth} = this.props;
        const mPos = props.position;
        const x = mPos.x;
        const {position, cellWidth} = this.positionObj;
        const initialX = position.x;
        let newWidth;
        if (x > initialX) {
            newWidth = cellWidth + (x - initialX);
        }
        else if (x <= initialX) {
            newWidth = cellWidth - (initialX - x);
        }
        if (maxWidth && newWidth > maxWidth) {
            return;
        }
        else if (minWidth && newWidth < minWidth) {
            return;
        }
        this.props.onMoving({
            key: this.getKey(),
            width: newWidth
        });
    };

    onMouseEnter = () => {
        if (typeof this.props.onHeaderCellMouseEnter === 'function') {
            this.props.onHeaderCellMouseEnter({
                key: this.getKey()
            });
        }
    }

    onMouseLeave = () => {
        if (typeof this.props.onHeaderCellMouseLeave === 'function') {
            this.props.onHeaderCellMouseLeave({
                key: this.getKey()
            });
        }
    }

    getCellRef = ref => {
        this.cellRef = ref;
    }

    onClick = e => {
        const {column, prefixCls} = this.props;
        if (!this.dragging
            && e.target.className !== `${prefixCls}-cell-drag-cursor`
            && insideUnfocusable(e.target, this.cellRef)
            && column.toggleSortOrder
        ) {
            column.toggleSortOrder(column);
        }
        if (this.customProps.onClick) {
            this.customProps.onClick(e);
        }
    }

    getKey() {
        const {dataIndex, key} = this.props.column;
        return key || dataIndex;
    }

    render() {
        const {
            className,
            render,
            prefixCls,
            column,
            index,
            left,
            width,
            dynamicWidth
        } = this.props;
        const customProps = column.onHeaderCell ? column.onHeaderCell(column) : {};
        this.customProps = customProps;
        const cellStyle = customProps.style || {};
        if (left != null
            && column.fixed === 'left'
        ) {
            cellStyle.left = left - width;
        }
        else if (column.fixed === 'right'
            && left != null
            && dynamicWidth
        ) {
            cellStyle.right = dynamicWidth - left < 0 ? 0 : dynamicWidth - left;
        }
        if (column.align) {
            cellStyle.textAlign = column.align;
        }
        const title = render ? render(column) : customProps.children;
        const Cell = (
            <th
                {...customProps}
                className={
                    classnames(className, customProps.className)
                }
                key={column.key || column.dataIndex || index}
                ref={this.getCellRef}
                style={cellStyle}
                onClick={this.onClick}
                rowSpan={column.rowSpan}
                colSpan={column.colSpan}
            >
                {title}
                {
                    (!column.colSpan && column.draggable) ? (
                        <span
                            className={`${prefixCls}-cell-drag-cursor`}
                            onMouseEnter={this.onMouseEnter}
                            onMouseLeave={this.onMouseLeave}
                            onMouseDown={
                                event => onMouseDown({
                                    event,
                                    onDropped: this.onDropped,
                                    onDragged: this.onDragged,
                                    onMoving: this.onMoving
                                })
                            }
                        />
                    ) : null
                }
            </th>
        );
        return Cell;
    }
}

function insideUnfocusable(el, context) {
    while (el) {
        if (isFocusable(el)) {
            return false;
        }
        if (el === context) {
            return true;
        }

        el = el.parentNode;
    }

    return false;
}

export default HeaderCell;