import React, {cloneElement, PureComponent} from 'react';
import {classnames} from '../../../core/commonTools';
import {
    isTreeNode,
    getDataAndAria,
    mapChildren,
    warnOnlyTreeNode
} from '../../../core/treeTools';
import Checkbox from '../../checkbox';
import SearchText from '../../select/searchText';
import toArray from '../../../core/childrenTools';
import {TreeNodeProps} from '../interface';
import Context from './context';

const ICON_OPEN = 'open';
const ICON_CLOSE = 'close';

const defaultTitle = '---';

class TreeNode extends PureComponent<TreeNodeProps> {

    static contextType = Context;

    static defaultProps = {
        title: defaultTitle,
        size: 'medium',
        isFileNode: false,
        disabledAllWhenNodeDisabled: false
    };

    selectHandle;

    componentDidMount() {
        this.syncLoadData(this.props);
    }

    componentDidUpdate() {
        this.syncLoadData(this.props);
    }

    onSelectorClick = e => {
        if (this.isDisabled() && this.props.disabledAllWhenNodeDisabled) {
            return;
        }
        const {rcTree: {onNodeClick}} = this.context;
        onNodeClick(e, this);

        if (this.isSelectable()) {
            this.onSelect(e);
        }
        else {
            this.onCheck(e);
        }
    };

    onSelectorDoubleClick = e => {
        if (this.isDisabled() && this.props.disabledAllWhenNodeDisabled) {
            return;
        }
        const {rcTree: {onNodeDoubleClick}} = this.context;
        onNodeDoubleClick(e, this);
    };

    onSelect = e => {
        if (this.isDisabled()) {
            return;
        }
        const {rcTree: {onNodeSelect}} = this.context;
        // e.preventDefault();
        onNodeSelect(e, this);
    };

    onCheck = e => {
        if (this.isDisabled()) {
            return;
        }

        const {disableCheckbox, checked} = this.props;
        const {
            rcTree: {checkable, onNodeCheck}
        } = this.context;

        if (!checkable || disableCheckbox) {
            return;
        }

        e.preventDefault();
        const targetChecked = !checked;
        onNodeCheck(e, this, targetChecked);
    };

    onMouseEnter = e => {
        const {rcTree: {onNodeMouseEnter}} = this.context;
        onNodeMouseEnter(e, this);
    };

    onMouseLeave = e => {
        const {rcTree: {onNodeMouseLeave}} = this.context;
        onNodeMouseLeave(e, this);
    };

    onContextMenu = e => {
        const {rcTree: {onNodeContextMenu}} = this.context;
        onNodeContextMenu(e, this);
    };

    // Disabled item still can be switch
    onExpand = e => {
        if (this.isDisabled() && this.props.disabledAllWhenNodeDisabled) {
            return;
        }
        const {rcTree: {onNodeExpand}} = this.context;
        onNodeExpand(e, this);
    };

    // Drag usage
    setSelectHandle = node => {
        this.selectHandle = node;
    };

    getNodeChildren = () => {
        const {children, disableCheckbox, disabled} = this.props;
        const originList = toArray(children)
            .map(child => {
                // 父存在disabled的话，所有的子都是disabled checkbox
                const props = {...child.props};
                if (disableCheckbox) {
                    props.disableCheckbox = disableCheckbox;
                }
                if (disabled) {
                    props.disabled = disabled;
                }
                return cloneElement(child, props);
            })
            .filter(node => node);
        const targetList = originList.filter(isTreeNode);

        if (originList.length !== targetList.length) {
            warnOnlyTreeNode();
        }

        return targetList;
    };

    getNodeState = isLeaf => {
        const {expanded} = this.props;

        if (isLeaf) {
            return null;
        }

        return expanded ? ICON_OPEN : ICON_CLOSE;
    };

    isLeaf = hasChildren => {
        const {isLeaf, loaded} = this.props;
        const {rcTree: {loadData}} = this.context;

        if (isLeaf === false) {
            return false;
        }

        return (
            isLeaf || (!loadData && !hasChildren) || (loadData && loaded && !hasChildren)
        );
    };

    isDisabled = () => {
        const {disabled} = this.props;
        const {rcTree: {disabled: treeDisabled}} = this.context;

        // Follow the logic of Selectable
        if (disabled === false) {
            return false;
        }

        return !!(treeDisabled || disabled);
    };

    isSelectable() {
        const {selectable} = this.props;
        const {rcTree: {selectable: treeSelectable}} = this.context;

        // Ignore when selectable is undefined or null
        if (typeof selectable === 'boolean') {
            return selectable;
        }

        return treeSelectable;
    }

    // Load data to avoid default expanded tree without data
    syncLoadData = props => {
        const {expanded, loading, loaded} = props;
        const {rcTree: {loadData, onNodeLoad}} = this.context;

        if (!loadData || !expanded || loaded || loading) {
            return;
        }

        const hasChildren = this.getNodeChildren().length > 0;
        // read from state to avoid loadData at same time
        if (!hasChildren && !this.isLeaf(hasChildren)) {
            // We needn't reload data when has children in sync logic
            // It's only needed in node expanded
            onNodeLoad(this);
        }
    };

    // Switcher
    renderSwitcher = isLeaf => {
        const {
            switcherIcon: switcherIconFromProps,
            expanded
        } = this.props;
        const {
            rcTree: {
                prefixCls,
                switcherIcon: switcherIconFromCtx
            }
        } = this.context;

        const switcherIcon = switcherIconFromProps || switcherIconFromCtx;

        if (isLeaf) {
            return (
                <span className={classnames(`${prefixCls}-switcher`, `${prefixCls}-switcher-noop`)}>
                    {typeof switcherIcon === 'function'
                        ? React.createElement(switcherIcon, {...this.props, isLeaf: true}) : switcherIcon}
                </span>
            );
        }
        const switcherCls = classnames(
            `${prefixCls}-switcher`,
            `${prefixCls}-switcher_${expanded ? ICON_OPEN : ICON_CLOSE}`
        );
        return (
            <span onClick={this.onExpand} className={switcherCls}>
                {typeof switcherIcon === 'function'
                    ? React.createElement(switcherIcon, {...this.props, isLeaf: false}) : switcherIcon}
            </span>
        );
    };

    // Checkbox
    renderCheckbox = () => {
        const {checked, halfChecked, disableCheckbox, size} = this.props;
        const {rcTree: {prefixCls, checkable}} = this.context;
        const disabled = this.isDisabled();
        let currentCheckable = checkable;
        if ('checkable' in this.props) {
            currentCheckable = this.props.checkable;
        }
        if (!currentCheckable) {
            return null;
        }

        // [Legacy] Custom element should be separate with `checkable` in future
        let $custom = typeof currentCheckable !== 'boolean' ? currentCheckable : null;
        if (typeof currentCheckable === 'boolean' && currentCheckable === true) {
            $custom = (
                <Checkbox
                    checked={checked}
                    indeterminate={!checked && halfChecked}
                    disabled={disabled || disableCheckbox}
                    size={size}
                />
            );
        }

        return (
            <span
                className={classnames(
                    `${prefixCls}-checkbox`,
                    checked && `${prefixCls}-checkbox-checked`,
                    !checked && halfChecked && `${prefixCls}-checkbox-indeterminate`,
                    (disabled || disableCheckbox) && `${prefixCls}-checkbox-disabled`,
                )}
                onClick={this.onCheck}
            >
                {$custom}
            </span>
        );
    };

    // Icon + Title
    renderSelector = (filterTitle, isLeafNode) => {
        const {title, selected, icon} = this.props;
        const {rcTree: {prefixCls, showIcon, icon: treeIcon}} = this.context;
        const disabled = this.isDisabled();

        const wrapClass = `${prefixCls}-node-content-wrapper`;

        // Icon - Still show loading icon when loading without showIcon
        let $icon;

        if (showIcon) {
            const currentIcon = icon || treeIcon;

            $icon = currentIcon ? (
                <span
                    className={classnames(
                        `${prefixCls}-iconEle`,
                        `${prefixCls}-icon__customize`,
                    )}
                >
                    {typeof currentIcon === 'function' ? React.createElement(currentIcon, {
                        ...this.props
                    }) : currentIcon}
                </span>
            ) : null;
        }

        let currentTitle = title;
        if (typeof title === 'string' && typeof filterTitle === 'string' && !!filterTitle) {
            currentTitle = (
                <SearchText
                    prefixCls={prefixCls}
                    text={title}
                    searchValue={filterTitle}
                    showSearch
                />
            );
        }
        // Title
        const $title = <span className={`${prefixCls}-title`}>{currentTitle}</span>;

        return (
            <span
                ref={this.setSelectHandle}
                title={typeof title === 'string' ? title : ''}
                className={classnames(
                    `${wrapClass}`,
                    `${wrapClass}-${this.getNodeState(isLeafNode) || 'normal'}`,
                    (!disabled && selected) && `${prefixCls}-node-selected`,
                )}

                onMouseEnter={this.onMouseEnter}
                onMouseLeave={this.onMouseLeave}
                onContextMenu={this.onContextMenu}
                onClick={this.onSelectorClick}
                onDoubleClick={this.onSelectorDoubleClick}
            >
                {$icon}
                {$title}
            </span>
        );
    };

    // Children list wrapped with `Animation`
    renderChildren = nodeList => {
        const {expanded, pos} = this.props;
        const {rcTree: {
            prefixCls,
            renderTreeNode
        }} = this.context;

        let $children;
        if (expanded) {
            $children = (
                <ul
                    className={classnames(
                        `${prefixCls}-child-tree`,
                        expanded && `${prefixCls}-child-tree-open`,
                    )}
                    data-expanded={expanded}
                    role="group"
                >
                    {mapChildren(nodeList, (node, index) => (
                        renderTreeNode(node, index, pos)
                    ))}
                </ul>
            );
        }
        return $children;
    };

    render() {
        const {
            loading,
            className,
            style,
            isLeaf,
            expanded,
            selected,
            checked,
            halfChecked,
            ...otherProps
        } = this.props;
        const {rcTree: {
            prefixCls,
            filterTreeNode
        }} = this.context;
        const disabled = this.isDisabled();
        const dataOrAriaAttributeProps = getDataAndAria(otherProps);
        const filterTitle = (filterTreeNode && filterTreeNode(this)) || false;
        const nodeList = this.getNodeChildren();
        const hasChildren = nodeList.length > 0;
        const isLeafNode = this.isLeaf(hasChildren);

        return (
            <li
                className={classnames(className, {
                    [`${prefixCls}-treenode-disabled`]: disabled,
                    [`${prefixCls}-treenode-switcher-${expanded ? 'open' : 'close'}`]: !isLeaf,
                    [`${prefixCls}-treenode-checkbox-checked`]: checked,
                    [`${prefixCls}-treenode-checkbox-indeterminate`]: halfChecked,
                    [`${prefixCls}-treenode-selected`]: selected,
                    [`${prefixCls}-treenode-loading`]: loading,
                    'current-filter-node': filterTitle
                })}

                style={style}

                role="treeitem"
                {...dataOrAriaAttributeProps}
            >
                <div className={`${prefixCls}-treenode-container`}>
                    {this.renderSwitcher(isLeafNode)}
                    <span className={`${prefixCls}-treenode-container-title`}>
                        {this.renderCheckbox()}
                        {this.renderSelector(filterTitle, isLeafNode)}
                    </span>
                </div>
                {hasChildren && this.renderChildren(nodeList)}
            </li>
        );
    }
}

// @ts-ignore
TreeNode.isTreeNode = 1;

export default TreeNode;
