/**
 * @file 可拖拽排序组件
 * @author tangjinhua
 * @date 2021/06/30
 */

import React, {PureComponent} from 'react';
import {
    classnames,
    isSafari as checkIsSafari,
    isInsideTransformedContainer
} from '../../core/commonTools';
import {noop} from 'lodash';
import {ReactSortable} from 'react-sortablejs';
import cloneElement from 'clone-element';
import {SortableProps} from './interface';
import {withConfigConsumer} from '../providerConfig/context';
import Handle from './handle';

const isSafari = checkIsSafari();

@withConfigConsumer('sortable')
class Sortable extends PureComponent<SortableProps> {

    static defaultProps = {
        prefixCls: 'one-sortable',
        options: [],
        renderOption(option) {},
        useHandle: false,
        // 未放开属性
        animation: 200,
        easing: 'cubic-bezier(.25, .1, .25, 1)'
    };

    static Handle: typeof Handle;

    static getDerivedStateFromProps(props) {
        const list = props.options.map(option => ({option}));
        // 数据适配`before`与`after`节点
        list.unshift({filtered: true});
        list.push({filtered: true});

        return {
            list
        };
    }

    state = {
        list: []
    };

    offsetX = 0;
    offsetY = 0;

    handleOnChange = event => {
        const {onChange, before} = this.props;
        if (!onChange) {
            return;
        }
        let {
            oldIndex,
            newIndex
        } = event;
        const headOffset = before ? 0 : 1;
        if (!before) {
            oldIndex += headOffset;
            newIndex += headOffset;
        }
        const list = this.state.list.slice();
        if (oldIndex === newIndex
            || newIndex === list.length - 1 // tail
        ) {
            return;
        }
        const oldOption = list[oldIndex];
        list.splice(oldIndex, 1);
        list.splice(newIndex, 0, oldOption);
        onChange(list.map(item => item.option).slice(1, -1), oldIndex - headOffset, newIndex - headOffset);
    };

    setDragImage = (dataTransfer, ele) => {
        if (isSafari && isInsideTransformedContainer(ele)) {
            const eleImage = cloneElement(ele) as HTMLElement;
            eleImage.style.position = 'fixed';
            eleImage.style.left = '0px';
            eleImage.style.top = '0px';
            document.body.append(eleImage);
            requestAnimationFrame(() => document.body.removeChild(eleImage));
            if (dataTransfer && dataTransfer.setDragImage) {
                dataTransfer.setDragImage(eleImage, this.offsetX, this.offsetY);
            }
        }
    };

    setOffset = ({originalEvent: {offsetX, offsetY}}: any) => {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
    };

    handleOnStart = () => {
        this.toggleDraggingClassName(true);
        const {onStart} = this.props;
        if (onStart) {
            onStart();
        }
    };

    handleOnEnd = event => {
        this.toggleDraggingClassName(false);
        this.handleOnChange(event);
        const {onEnd} = this.props;
        if (onEnd) {
            onEnd();
        }
    };

    componentWillUnmount() {
        // 拖拽过程中组件可能卸载，补充移除样式
        this.toggleDraggingClassName(false);
    }

    toggleDraggingClassName(add) {
        const classList = document.documentElement.classList;
        const className = `${this.props.prefixCls}-dragging`;
        if (add) {
            classList.add(className);
        }
        else {
            classList.remove(className);
        }
    }

    render() {
        const {
            prefixCls,
            className,
            options,
            renderOption,
            useHandle,
            onChange,
            before,
            after,
            ...restProps
        } = this.props;

        return (
            <ReactSortable
                {...restProps}
                className={classnames(prefixCls, className, {
                    [`${prefixCls}-use-handle`]: useHandle
                })}
                handle={useHandle ? `.${prefixCls}-handle` : null}
                list={this.state.list}
                setData={this.setDragImage}
                onChoose={this.setOffset}
                onStart={this.handleOnStart}
                onEnd={this.handleOnEnd}
                ghostClass={classnames(`${prefixCls}-ghost`)}
                dragClass={classnames(`${prefixCls}-drag`)}
                chosenClass={classnames(`${prefixCls}-chosen`)}
                draggable={`.${prefixCls}-draggable`}
                setList={noop}
            >
                <>{before}</>
                {options.map((option, index) => {
                    const optionElement = renderOption(option, index);
                    return React.cloneElement(optionElement, {
                        className: classnames(`${prefixCls}-draggable`, optionElement.props.className)
                    });
                })}
                <>{after}</>
            </ReactSortable>
        );
    }
}

export default Sortable;