import React, {PureComponent, ReactNode, TdHTMLAttributes} from 'react';
import {classnames} from '../../../core/commonTools';
import {get} from 'lodash';

function isInvalidRenderCellText(text) {
    return (
        text
            && !React.isValidElement(text)
            && Object.prototype.toString.call(text) === '[object Object]'
    );
}

interface TableCellProps {
    record: object,
    prefixCls: string,
    className: string,
    index: number,
    indent: number,
    indentSize: number,
    expandIcon: ReactNode,
    left: number | string,
    right: number | string,
    onCellClick,
    cellIndex,
    dataIndex,
    render,
    onCell,
    align
}

export default class TableCell extends PureComponent<TableCellProps> {

    handleClick = e => {
        const {
            record,
            onCellClick
        } = this.props;
        if (onCellClick) {
            onCellClick(record, e);
        }
    };

    cellRef;

    getRef = ref => {
        this.cellRef = ref;
    }

    render() {
        const {
            record,
            indentSize,
            prefixCls,
            indent,
            index,
            cellIndex,
            expandIcon,
            className,
            left,
            right,
            dataIndex,
            render,
            onCell,
            align
        } = this.props;

        // We should return undefined if no dataIndex is specified, but in order to
        // be compatible with object-path's behavior, we return the record object instead.
        let text;
        if (typeof dataIndex === 'number') {
            text = get(record, dataIndex);
        }
        else if (!dataIndex || dataIndex.length === 0) {
            text = record;
        }
        else {
            text = get(record, dataIndex);
        }
        let tdProps: TdHTMLAttributes<HTMLTableCellElement> = {};
        let colSpan;
        let rowSpan;

        if (render) {
            text = render(text, record, index);
            if (isInvalidRenderCellText(text)) {
                tdProps = text.props || tdProps;
                colSpan = tdProps.colSpan;
                rowSpan = tdProps.rowSpan;
                text = text.children;
            }
        }

        if (onCell) {
            tdProps = {...tdProps, ...onCell(record)};
        }

        if (isInvalidRenderCellText(text)) {
            text = null;
        }

        const indentText = expandIcon ? (
            <span
                // @ts-ignore
                style={{'--one-table-cell-indent-level': indent}}
                className={`${prefixCls}-indent indent-level-${indent}`}
            />
        ) : null;

        if (rowSpan === 0 || colSpan === 0) {
            return null;
        }

        if (align) {
            tdProps.style = {...tdProps.style, textAlign: align};
        }

        if (left != null) {
            tdProps.style = {...tdProps.style, left};
        }
        else if (right != null) {
            tdProps.style = {...tdProps.style, right};
        }

        const bodyCellClassName = classnames(
            `${prefixCls}-body-cell`,
            className,
            {
                [`${prefixCls}-first-cell`]: cellIndex === 0
            }
        );
        let content = <div className={`${prefixCls}-cell-content`}>{text}</div>;
        if (indentText) {
            content = (
                <div className={`${prefixCls}-cell-content-wrapper`}>
                    <div className={`${prefixCls}-cell-content-expand`}>
                        {indentText}
                        {expandIcon}
                    </div>
                    {content}
                </div>
            );
        }
        return (
            <td
                className={bodyCellClassName}
                onClick={this.handleClick}
                {...tdProps}
                ref={this.getRef}
            >
                {content}
            </td>
        );
    }
}
