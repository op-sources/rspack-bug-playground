import React, {CSSProperties} from 'react';
import {IconChevronDown, IconChevronRight} from 'dls-icons-react';
import Trigger from 'rc-trigger';
import KeyCode from 'rc-util/lib/KeyCode';
import CSSMotion from 'rc-animate/lib/CSSMotion';
import {classnames} from '../../../core/commonTools';
import {connect} from 'mini-store';
import SubPopupMenu, {SubPopupMenuProps} from './subPopupMenu';
import placements from './placements';
import {
    loopMenuItemRecursively,
    getMenuIdFromSubMenuEventKey
} from './util';
import Context from '../context';
import omit from 'omit.js';
import {MenuStore} from './menu';
import ReactDOM from 'react-dom';

let guid = 0;

const popupPlacementMap = {
    horizontal: 'bottomLeft',
    vertical: 'rightTop',
    'vertical-left': 'rightTop',
    'vertical-right': 'leftTop'
};

const updateDefaultActiveFirst = (
    store,
    eventKey,
    defaultActiveFirst,
) => {
    const menuId = getMenuIdFromSubMenuEventKey(eventKey);
    const state = store.getState();
    store.setState({
        defaultActiveFirst: {
            ...state.defaultActiveFirst,
            [menuId]: defaultActiveFirst
        }
    });
};

interface InnerSubMenu extends Omit<SubPopupMenuProps, 'mode'> {
    mode?: 'horizontal' | 'vertical' | 'inline',
    onDestroy?(key: string);
    manualRef?,
    isOpen?: boolean,
    active?: boolean,
    selectedKeys?: string[],
    openKeys?: string[],
    onMouseEnter?(e): void;
    onMouseLeave?;
    onTitleMouseEnter?;
    onTitleMouseLeave?;
    onTitleClick?;
    builtinPlacements?;
    prefixCls?;
    inlineIndent?;
    renderMenuItem?;
    onItemHover?;
    onOpenChange?;
    subMenuKey?;
}

export class SubMenu extends React.Component<InnerSubMenu> {

    static defaultProps: InnerSubMenu = {
        onMouseEnter: () => {},
        onMouseLeave: () => {},
        onTitleMouseEnter: () => {},
        onTitleMouseLeave: () => {},
        onTitleClick: () => {},
        manualRef: () => {},
        mode: 'vertical',
        title: '',
        prefixCls: 'one-menu'
    };

    static contextType = Context;

    constructor(props) {
        super(props);
        const {store, eventKey} = props;
        const {defaultActiveFirst} = store.getState();

        this.isRootMenu = false;

        let value = false;

        if (defaultActiveFirst) {
            value = defaultActiveFirst[eventKey];
        }

        updateDefaultActiveFirst(store, eventKey, value);
    }

    isRootMenu;
    mouseenterTimeout;
    minWidthTimeout;
    subMenuTitle;
    menuInstance;
    haveRendered;
    haveOpened;

    componentDidMount() {
        this.componentDidUpdate();
    }

    componentDidUpdate() {
        const {mode, parentMenu, manualRef, isOpen} = this.props;

        // invoke customized ref to expose component to mixin
        if (manualRef) {
            manualRef(this);
        }

        // @ts-ignore 暂时保留horizontal逻辑
        if (mode !== 'horizontal' || !parentMenu.isRootMenu || !isOpen) {
            return;
        }

        this.minWidthTimeout = setTimeout(() => this.adjustWidth(), 0);
    }

    componentWillUnmount() {
        const {onDestroy, eventKey} = this.props;
        if (onDestroy) {
            onDestroy(eventKey);
        }

        clearTimeout(this.minWidthTimeout);
        clearTimeout(this.mouseenterTimeout);
    }

    onDestroy = key => {
        this.props.onDestroy(key);
    };

    /**
     * note:
     *  This legacy code that `onKeyDown` is called by parent instead of dom self.
     *  which need return code to check if this event is handled
     */
    onKeyDown = e => {
        const {keyCode} = e;
        const menu = this.menuInstance;
        const {isOpen, store} = this.props;

        if (keyCode === KeyCode.ENTER) {
            this.onTitleClick(e);
            updateDefaultActiveFirst(store, this.props.eventKey, true);
            return true;
        }

        if (keyCode === KeyCode.RIGHT) {
            if (isOpen) {
                menu.onKeyDown(e);
            }
            else {
                this.triggerOpenChange(true);
                // need to update current menu's defaultActiveFirst value
                updateDefaultActiveFirst(store, this.props.eventKey, true);
            }
            return true;
        }
        if (keyCode === KeyCode.LEFT) {
            let handled;
            if (isOpen) {
                handled = menu.onKeyDown(e);
            }
            else {
                return undefined;
            }
            if (!handled) {
                this.triggerOpenChange(false);
                handled = true;
            }
            return handled;
        }

        if (isOpen && (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN)) {
            return menu.onKeyDown(e);
        }

        return undefined;
    };

    onOpenChange = e => {
        this.props.onOpenChange(e);
    };

    onPopupVisibleChange = visible => {
        this.triggerOpenChange(visible, visible ? 'mouseenter' : 'mouseleave');
    };

    onMouseEnter = e => {
        const {eventKey: key, onMouseEnter, store} = this.props;
        updateDefaultActiveFirst(store, this.props.eventKey, false);
        onMouseEnter({
            key,
            domEvent: e
        });
    };

    onMouseLeave = e => {
        const {parentMenu, eventKey, onMouseLeave} = this.props;
        parentMenu.subMenuInstance = this;
        onMouseLeave({
            key: eventKey,
            domEvent: e
        });
    };

    onTitleMouseEnter = domEvent => {
        const {eventKey: key, onItemHover, onTitleMouseEnter} = this.props;
        onItemHover({
            key,
            hover: true
        });
        onTitleMouseEnter({
            key,
            domEvent
        });
    };

    onTitleMouseLeave = e => {
        const {parentMenu, eventKey, onItemHover, onTitleMouseLeave} = this.props;
        parentMenu.subMenuInstance = this;
        onItemHover({
            key: eventKey,
            hover: false
        });
        onTitleMouseLeave({
            key: eventKey,
            domEvent: e
        });
    };

    onTitleClick = e => {
        const {
            onTitleClick,
            eventKey,
            mode,
            isOpen,
            store
        } = this.props;

        onTitleClick({
            key: eventKey,
            domEvent: e
        });
        if (mode !== 'inline') {
            return;
        }
        this.triggerOpenChange(!isOpen, 'click');
        updateDefaultActiveFirst(store, eventKey, false);
    };

    onSubMenuClick = info => {
        // in the case of overflowed submenu
        // onClick is not copied over
        if (typeof this.props.onClick === 'function') {
            this.props.onClick(this.addKeyPath(info));
        }
    };

    onSelect = info => {
        this.props.onSelect(info);
    };

    onDeselect = info => {
        this.props.onDeselect(info);
    };

    getPrefixCls = () => `${this.props.prefixCls}-submenu`;

    getActiveClassName = () => `${this.getPrefixCls()}-active`;

    getDisabledClassName = () => `${this.getPrefixCls()}-disabled`;

    getSelectedClassName = () => `${this.getPrefixCls()}-selected`;

    getOpenClassName = () => `${this.props.prefixCls}-submenu-open`;

    saveMenuInstance = c => {
        // children menu instance
        this.menuInstance = c;
    };

    addKeyPath = info => ({
        ...info,
        keyPath: (info.keyPath || []).concat(this.props.eventKey)
    });

    triggerOpenChange = (open, type?) => {
        const key = this.props.eventKey;
        const openChange = () => {
            this.onOpenChange({
                key,
                item: this,
                trigger: type,
                open
            });
        };
        if (type === 'mouseenter') {
            // make sure mouseenter happen after other menu item's mouseleave
            this.mouseenterTimeout = setTimeout(() => {
                openChange();
            }, 0);
        }
        else {
            openChange();
        }
    };

    isChildrenSelected = () => {
        const ret = {find: false};
        loopMenuItemRecursively(this.props.children, this.props.selectedKeys, ret);
        return ret.find;
    };

    adjustWidth = () => {
        if (!this.subMenuTitle || !this.menuInstance) {
            return;
        }
        const popupMenu = ReactDOM.findDOMNode(this.menuInstance) as HTMLElement;
        if (popupMenu.offsetWidth >= this.subMenuTitle.offsetWidth) {
            return;
        }

        popupMenu.style.minWidth = `${this.subMenuTitle.offsetWidth}px`;
    };

    saveSubMenuTitle = subMenuTitle => {
        this.subMenuTitle = subMenuTitle;
    };

    renderChildren(children) {
        const {
            mode,
            isOpen,
            level,
            inlineIndent,
            selectedKeys,
            eventKey,
            openKeys,
            motion,
            subMenuOpenDelay,
            subMenuCloseDelay,
            forceSubMenuRender,
            triggerSubMenuAction,
            builtinPlacements,
            multiple,
            prefixCls,
            store
        } = this.props;
        const baseProps = {
            mode: mode === 'horizontal' ? 'vertical' : mode,
            visible: isOpen,
            level: level + 1,
            inlineIndent,
            focusable: false,
            onClick: this.onSubMenuClick,
            onSelect: this.onSelect,
            onDeselect: this.onDeselect,
            onDestroy: this.onDestroy,
            selectedKeys,
            eventKey: `${eventKey}-menu-`,
            openKeys,
            motion,
            onOpenChange: this.onOpenChange,
            subMenuOpenDelay,
            parentMenu: this,
            subMenuCloseDelay,
            forceSubMenuRender,
            triggerSubMenuAction,
            builtinPlacements,
            defaultActiveFirst: store.getState().defaultActiveFirst[
                getMenuIdFromSubMenuEventKey(eventKey)
            ],
            multiple,
            prefixCls,
            id: this.internalMenuId,
            manualRef: this.saveMenuInstance
        };

        const {haveRendered} = this;
        this.haveRendered = true;

        this.haveOpened = this.haveOpened || baseProps.visible || baseProps.forceSubMenuRender;
        // never rendered not planning to, don't render
        if (!this.haveOpened) {
            return <div />;
        }

        // ================== Motion ==================
        // don't show transition on first rendering (no animation for opened menu)
        // show appear transition if it's not visible (not sure why)
        // show appear transition if it's not inline mode
        const mergedMotion = {
            ...motion,
            leavedClassName: `${prefixCls}-hidden`,
            removeOnLeave: false,
            motionAppear:
                haveRendered || !baseProps.visible || baseProps.mode !== 'inline'
        };

        return (
            <CSSMotion visible={baseProps.visible} {...mergedMotion}>
                {({className, style}) => {
                    const mergedClassName = classnames(
                        `${baseProps.prefixCls}-sub`,
                        className,
                    );

                    return (
                        <SubPopupMenu
                            {...baseProps}
                            id={this.internalMenuId}
                            className={mergedClassName}
                            style={style}
                        >
                            {children}
                        </SubPopupMenu>
                    );
                }}
            </CSSMotion>
        );
    }

    internalMenuId;

    render() {
        const {
            isOpen,
            className,
            active,
            disabled,
            mode,
            eventKey,
            level,
            title,
            parentMenu,
            children,
            popupOffset,
            popupClassName,
            triggerSubMenuAction,
            subMenuOpenDelay,
            forceSubMenuRender,
            subMenuCloseDelay,
            builtinPlacements,
            onClick,
            ...restProps
        } = this.props;
        const prefixCls = this.getPrefixCls();
        const isInlineMode = mode === 'inline';

        if (!this.internalMenuId) {
            if (eventKey) {
                this.internalMenuId = `${eventKey}$Menu`;
            }
            else {
                guid += 1;
                this.internalMenuId = `$__$${guid}$Menu`;
            }
        }

        let mouseEvents = {};
        let titleClickEvents = {};
        let titleMouseEvents = {};
        if (!disabled) {
            mouseEvents = {
                onMouseLeave: this.onMouseLeave,
                onMouseEnter: this.onMouseEnter
            };

            // only works in title, not outer li
            titleClickEvents = {
                onClick: this.onTitleClick
            };
            titleMouseEvents = {
                onMouseEnter: this.onTitleMouseEnter,
                onMouseLeave: this.onTitleMouseLeave
            };
        }

        const style: CSSProperties = {};
        if (isInlineMode) {
            style.paddingLeft = this.context.inlineIndent * (level - 1) + this.context.inlinePaddingLeft;
        }

        let ariaOwns = {};
        // only set aria-owns when menu is open
        // otherwise it would be an invalid aria-owns value
        // since corresponding node cannot be found
        if (isOpen) {
            ariaOwns = {
                'aria-owns': this.internalMenuId
            };
        }

        // expand custom icon should NOT be displayed in menu with horizontal mode.
        let icon = null;
        if (mode !== 'horizontal') {
            icon = mode !== 'vertical'
                ? <IconChevronDown className={`${prefixCls}-down-icon`} />
                : <IconChevronRight className={`${prefixCls}-right-icon`} />
        }

        const titleNode = (
            <div
                ref={this.saveSubMenuTitle}
                style={style}
                className={classnames(`${prefixCls}-title`, {
                    [`${prefixCls}-title-disabled`]: disabled
                })}
                {...titleMouseEvents}
                {...titleClickEvents}
                aria-expanded={isOpen}
                {...ariaOwns}
                aria-haspopup="true"
                title={typeof title === 'string' ? title : undefined}
            >
                {title}
                {icon || <i className={`${prefixCls}-arrow`} />}
            </div>
        );
        const childrenNode = this.renderChildren(children);

        const getPopupContainer = parentMenu.isRootMenu
            ? parentMenu.props.getPopupContainer
            : triggerNode => triggerNode.parentNode;
        const popupPlacement = popupPlacementMap[mode];
        const popupAlign = Object.assign({ignoreShake: true}, popupOffset ? {offset: popupOffset} : {});
        const popupCls = mode === 'inline' ? '' : popupClassName;

        const cls = classnames(prefixCls, className, `${prefixCls}-${mode}`, {
            [this.getOpenClassName()]: isOpen,
            [this.getActiveClassName()]: active || (isOpen && !isInlineMode),
            [this.getDisabledClassName()]: disabled,
            [this.getSelectedClassName()]: this.isChildrenSelected()
        });

        return (
            <li
                {...omit(restProps, [
                    'renderMenuItem',
                    'onDestroy',
                    'manualRef',
                    'selectedKeys',
                    'openKeys',
                    'onMouseEnter',
                    'onMouseLeave',
                    'onTitleMouseEnter',
                    'prefixCls',
                    'inlineIndent',
                    'onItemHover',
                    'onOpenChange',
                    'onDeselect',
                    'onTitleMouseLeave',
                    'onTitleClick',
                    'subMenuKey'
                ])}
                {...mouseEvents}
                className={cls}
                role="menuitem"
            >
                {isInlineMode && titleNode}
                {isInlineMode && childrenNode}
                {!isInlineMode && (
                    <Trigger
                        prefixCls={prefixCls}
                        popupClassName={`${prefixCls}-popup ${popupCls}`}
                        getPopupContainer={getPopupContainer}
                        builtinPlacements={Object.assign({}, placements, builtinPlacements)}
                        popupPlacement={popupPlacement}
                        popupVisible={isOpen}
                        popupAlign={popupAlign}
                        popup={childrenNode}
                        action={disabled ? [] : [triggerSubMenuAction]}
                        mouseEnterDelay={subMenuOpenDelay}
                        mouseLeaveDelay={subMenuCloseDelay}
                        onPopupVisibleChange={this.onPopupVisibleChange}
                        forceRender={forceSubMenuRender}
                    >
                        {titleNode}
                    </Trigger>
                )}
            </li>
        );
    }
}

const connected = connect(
    ({openKeys, activeKey, selectedKeys}: MenuStore, {eventKey, subMenuKey}: InnerSubMenu) => ({
        isOpen: openKeys.indexOf(eventKey) > -1,
        active: activeKey[subMenuKey] === eventKey,
        selectedKeys
    }),
)(SubMenu);

connected.isSubMenu = true;

export default connected;
