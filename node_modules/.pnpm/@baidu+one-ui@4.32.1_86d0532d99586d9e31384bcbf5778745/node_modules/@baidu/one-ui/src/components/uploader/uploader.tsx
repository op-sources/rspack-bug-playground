import React, {PureComponent, ChangeEvent} from 'react';
import {map, findIndex, noop, identity} from 'lodash';
import UploaderAnchor from './common/uploaderAnchor';
import UploaderList from './common/uploaderList';
import Message from '../toast';
import {
    checkFileRules,
    originStatus,
    fileUploader,
    getUid,
    UPLOAD_STATUS_MAP,
    getAccept
} from '../../core/uploaderTools';
import {classnames} from '../../core/commonTools';
import {UploaderProps, UploadFile, UploaderProgressEvent} from './interface';
import {withConfigConsumer} from '../providerConfig/context';
import omit from 'omit.js';
import {propChangeWarning} from '../../util/warning';

const defaultUploader = options => {
    const file = options.file?.originFile;
    if (file) {
        options.file = file;
    }
    return fileUploader(options);
};

interface UploaderState {
    fileList: UploadFile[];
    insertImage: boolean;
    insetIndex: number;
}

@withConfigConsumer('uploader')
class Uploader extends PureComponent<UploaderProps, UploaderState> {
    static defaultProps: UploaderProps = {
        disabled: false,
        sortable: false,
        listType: 'file',
        timeout: 3000,
        multiple: false,
        className: '',
        prefixCls: 'one-uploader',
        inputControlName: 'file',
        loading: false,
        helperTextPosition: 'right',
        onRemove: noop,
        onChange: noop,
        transformFile: identity,
        uploader: defaultUploader,
        maxFileLengthErrorMessage: '已超出文件最大上传个数，请删除后重新上传',
        useInForm: false,
        size: 'medium',
        errorDisplay: 'popup'
    }

    uploaderXhrMap: {[key: string]: {abort(): void}} = {};
    _fileList: UploadFile[];
    uploaderAnchorRef: UploaderAnchor;

    constructor(props: UploaderProps) {
        super(props);
        propChangeWarning(
            'Uploader',
            props,
            {
                'helperTextPostion': 'helperTextPosition',
                'showUploadListIcon': 'controls',
                'customUploadListIcon': 'controls',
                'CustomUploadAnchor': 'CustomUploadPicker',
                'order': 'pickerPosition',
                'hideAnchor': 'hidePicker',
                'formatUploadAnchor': 'picker'
            }
        );
        const _fileList = props.fileList || props.defaultFileList || [];
        this.state = {
            fileList: _fileList,
            insertImage: false,
            insetIndex: 0
        };
        this._fileList = _fileList;
    }

    state: UploaderState;

    static getDerivedStateFromProps = (nextProps: UploaderProps, prevState: UploaderState) => {
        if ('fileList' in nextProps && nextProps.fileList !== prevState.fileList) {
            return {
                fileList: nextProps.fileList
            };
        }
        return null;
    }

    componentDidUpdate(prevProps: UploaderProps) {
        if (this.props.fileList && this.props.fileList !== prevProps.fileList) {
            this._fileList = [...this.props.fileList];
        }
    }

    componentWillUnmount() {
        this.uploaderXhrMap = {};
    }

    onInputChange = (e: ChangeEvent<HTMLInputElement>) => {
        const files = e.target.files;
        const postFiles: File[] = Array.prototype.slice.call(files);
        const tempFiles: UploadFile[] = [];
        const {maxParallelFileNumber, maxFileLength, maxFileLengthErrorMessage} = this.props;
        const {insertImage, insetIndex} = this.state;
        if (maxParallelFileNumber && postFiles.length > maxParallelFileNumber) {
            Message.error({
                content: '超过最大可并行上传个数， 请重新选择...'
            });
            return;
        }
        const currentFileCount = !insertImage
            ? this.state.fileList.length + postFiles.length
            : this.state.fileList.length + postFiles.length - 1;
        if (maxFileLength && maxFileLength < currentFileCount) {
            // 存在限制文件上传的个数，并且不是图片重新上传的情况下，进行报错return
            Message.error({
                content: `${maxFileLengthErrorMessage}`
            });
            return;
        }
        postFiles.forEach((file, index) => {
            tempFiles.push({
                status: originStatus.WAITING,
                name: file.name,
                isNewUpload: true,
                originFile: file,
                uid: getUid(index),
                type: file.type
            });
        });
        let newFileList = this._fileList.concat(tempFiles);
        if (insertImage) {
            // 从中间插入
            newFileList = [...this._fileList];
            newFileList.splice(insetIndex, 1, ...tempFiles);
        }
        const {_fileList, allFailures} = this.onValidatorFiles(newFileList);
        this._fileList = _fileList;
        if (allFailures) {
            return;
        }
        const newUploadingFiles = _fileList.filter(file => file.status === originStatus.WAITING && file.isNewUpload);
        newUploadingFiles.forEach(file => {
            this.upload(file, newUploadingFiles);
        });
    }

    upload = (file: UploadFile, fileList: UploadFile[]) => {
        if (!this.props.beforeUpload) {
            return setTimeout(() => this.post(file), 0);
        }
        const before = this.props.beforeUpload(file, fileList);
        if (typeof before !== 'boolean' && before && before.then) {
            before.then(processedFile => {
                const processedFileType = Object.prototype.toString.call(processedFile);
                if (processedFileType === '[object File]' || processedFileType === '[object Blob]') {
                    return this.post(processedFile);
                }
                return this.post(file);
            }).catch(e => {});
        }
        else if (before !== false) {
            setTimeout(() => this.post(file), 0);
        }
    }

    post = (file: UploadFile) => {
        return new Promise(() => {
            const {
                uploadResquestUrl, transformFile, uploader,
                headers, withCredentials = false, method = 'post', reqData
            } = this.props;
            const transform = Promise.resolve(transformFile(file));
            transform.then(transformedFile => {
                const requestOption = {
                    action: uploadResquestUrl,
                    filename: file.name,
                    reqData,
                    file: transformedFile,
                    headers,
                    withCredentials,
                    method: method || 'post',
                    onProgress: (e: UploaderProgressEvent) => {
                        this.onProgress(e, file);
                    },
                    onSuccess: (ret: any) => {
                        this.onSuccess(ret, file);
                    },
                    onError: (err: Error | ProgressEvent, ret?: any) => {
                        this.onError(err, ret, file);
                    }
                };
                this.uploaderXhrMap[(file && file.uid)] = uploader(requestOption);
                this.onStart(file);
            });
        });
    }

    getFileIndex = (file: UploadFile) => {
        const uid = file.uid;
        const fileList = [...this.state.fileList];
        const currentFileIndex = findIndex(fileList, file => file.uid === uid);
        return currentFileIndex;
    }

    onProgress = (e: UploaderProgressEvent, file: UploadFile) => {
        const percent = e.percent;
        const fileList = [...this.state.fileList];
        const currentFileIndex = this.getFileIndex(file);
        if (fileList[currentFileIndex]) {
            fileList[currentFileIndex].progressStep = percent - 1;
        }
        this.props.onChange({
            index: currentFileIndex,
            file,
            fileList
        });
        if (!('fileList' in this.props)) {
            this.setState({
                fileList
            });
        }
    }

    onSuccess = (ret: any, file: UploadFile) => {
        const fileList = [...this.state.fileList];
        const currentFileIndex = this.getFileIndex(file);
        if (fileList[currentFileIndex]) {
            fileList[currentFileIndex].status = originStatus.SUCCESS;
        }

        const {
            afterUpload,
            onChange
        } = this.props;

        if (afterUpload) {
            Object.assign(file, afterUpload(ret, file, fileList));
        }

        onChange({
            index: currentFileIndex,
            file,
            fileList,
            response: ret
        });
        if (!('fileList' in this.props)) {
            this.setState({
                fileList
            });
        }
    }

    onError = (err: Error | ProgressEvent<EventTarget>, ret: any, file: UploadFile) => {
        const fileList = [...this.state.fileList];
        const currentFileIndex = this.getFileIndex(file);
        if (fileList[currentFileIndex]) {
            fileList[currentFileIndex].status = originStatus.ERROR;
            fileList[currentFileIndex].errorMessage = [UPLOAD_STATUS_MAP.UPLOAD_ERROR.error.msg];
        }
        this.props.onChange({
            index: currentFileIndex,
            file,
            fileList,
            err,
            response: ret
        });
        if (!('fileList' in this.props)) {
            this.setState({
                fileList
            });
        }
    }

    onStart = (file: UploadFile) => {
        const fileList = [...this.state.fileList];
        const currentFileIndex = this.getFileIndex(file);
        if (fileList[currentFileIndex]) {
            fileList[currentFileIndex].status = originStatus.UPLOADING;
            fileList[currentFileIndex].progressStep = 0;
        }
        this.props.onChange({
            index: currentFileIndex,
            file,
            fileList
        });
        if (!('fileList' in this.props)) {
            this.setState({
                fileList
            });
        }
    }

    onValidatorFiles = (files: UploadFile[]) => {
        const _fileList = [...files];
        let allFailures = true;
        _fileList.forEach((file, index) => {
            if (file.status === originStatus.WAITING && file.isNewUpload) {
                const errors = this.onValidatorSingleFile(file.originFile);
                const hasError = errors.length;
                _fileList[index] = {
                    ..._fileList[index],
                    status: hasError ? originStatus.ERROR : originStatus.WAITING
                };
                if (hasError) {
                    _fileList[index].errorMessage = errors;
                }
                else {
                    _fileList[index].progressStep = 0;
                }
                this.props.onChange({
                    index,
                    fileList: _fileList,
                    file: _fileList[index].originFile
                });
                if (!hasError) {
                    allFailures = false;
                }
            }
        });
        if (!('fileList' in this.props)) {
            this.setState({
                fileList: _fileList
            });
        }
        return {
            allFailures,
            _fileList
        };
    }

    onValidatorSingleFile = (file: File) => {
        const errorMessages: string[] = [];
        const {accept, maxSize, validator, listType} = this.props;
        map(checkFileRules, checkFileRule => {
            if (checkFileRule.match({
                file,
                options: {
                    accept: getAccept(accept, listType),
                    maxSize
                }
            })) {
                errorMessages.push(checkFileRule.error.error.msg);
            }
        });
        if (validator) {
            const msg = validator(file);
            if (msg) {
                errorMessages.push(msg);
            }
        }
        return errorMessages;
    };

    onRemove = ({
        fileList,
        index,
        originFileList = []
    }: {fileList: UploadFile[], index: number, originFileList: UploadFile[]}) => {
        const curFile = originFileList[index];
        if (curFile
            && curFile.status === originStatus.UPLOADING
            && this.uploaderXhrMap[curFile.uid]
            && typeof this.uploaderXhrMap[curFile.uid].abort === 'function'
        ) {
            // 对于删除正在上传的组件，应该直接abort
            this.uploaderXhrMap[curFile.uid].abort();
        }
        if (!('fileList' in this.props)) {
            this.setState({
                fileList
            });
        }
        this._fileList = [...fileList];
        if (this.props.useInForm) {
            this.props.onChange({
                fileList,
                index
            });
        }
        this.props.onRemove({
            fileList,
            index
        });
    }

    onSort = (fileList: UploadFile[]) => {
        this.props.onChange({
            fileList
        });
        if (!('fileList' in this.props)) {
            this.setState({
                fileList
            });
        }
    }

    onInsertImage = (insertImage: boolean, index: number) => {
        this.setState({
            insertImage,
            insetIndex: index
        });
        this.uploaderAnchorRef.uploadInputRef.value = '';
        this.uploaderAnchorRef.uploadInputRef.click();
    };

    onPickerClick = () => {
        this.setState({
            insertImage: false
        });
        const onPickerClick = this.props.onPickerClick;
        if (onPickerClick) {
            return onPickerClick();
        }
    }

    uploadAnchorRef = (ref: UploaderAnchor) => {
        this.uploaderAnchorRef = ref;
    }

    normalizePickerPosition() {
        const {
            hideAnchor,
            hidePicker,
            order,
            pickerPosition,
            listType
        } = this.props;
        if (hideAnchor === true || hidePicker === true) {
            return 'none';
        }
        if (listType === 'image' && order === 'reverse') {
            return 'before';
        }
        if (listType === 'file' && order === 'reverse') {
            return 'after';
        }
        if (!pickerPosition) {
            if (listType === 'file') {
                return 'before';
            }
            return 'after';
        }
        return pickerPosition;
    }

    render() {
        const {
            prefixCls,
            className,
            listType,
            onPreview,
            onReUpload,
            size,
            formatUploadAnchor,
            picker,
            sortable,
            helperTextPosition,
            helperTextPostion
        } = this.props;
        const fileList = this.state.fileList;

        const pickerPosition = this.normalizePickerPosition();

        const showType = listType === 'file' ? 'file' : 'image';
        const uploadClassNames = classnames(prefixCls, className, `${prefixCls}-picker-position-${pickerPosition}`, {
            [`${prefixCls}-${size}`]: listType !== 'file',
            [`${prefixCls}-image`]: showType === 'image'
        });

        let uploadPicker = (<UploaderAnchor
            key='uploader-anchor'
            {...this.props}
            pickerPosition={pickerPosition}
            helperTextPosition={helperTextPostion || helperTextPosition}
            ref={this.uploadAnchorRef}
            onChange={this.onInputChange}
            onPickerClick={this.onPickerClick}
            listType={showType}
            realType={listType}
            fileList={fileList}
        />);
        if (formatUploadAnchor && typeof formatUploadAnchor === 'function') {
            uploadPicker = formatUploadAnchor(uploadPicker);
        }
        if (picker && typeof picker === 'function') {
            uploadPicker = picker(uploadPicker);
        }
        if (showType === 'image') {
            return (
                <div className={uploadClassNames}>
                    <UploaderList
                        key='uploader-list'
                        {...this.props}
                        fileList={fileList}
                        onRemove={this.onRemove}
                        onPreview={onPreview}
                        onReUpload={onReUpload}
                        onSort={this.onSort}
                        sortable={sortable}
                        onInsertImage={this.onInsertImage}
                        listType={showType}
                        realType={listType}
                        picker={uploadPicker}
                        pickerPosition={pickerPosition}
                    />
                </div>
            );
        }
        const renders = [
            uploadPicker,
            <UploaderList
                key="upload-list"
                {...omit(this.props, ['picker'])}
                fileList={fileList}
                onSort={this.onSort}
                onRemove={this.onRemove}
                listType={showType}
                realType={listType}
                pickerPosition={pickerPosition}
            />
        ];
        return (
            <div className={uploadClassNames}>
                {pickerPosition === 'after' ? renders.reverse() : renders}
            </div>
        );
    }

}

export default Uploader;
