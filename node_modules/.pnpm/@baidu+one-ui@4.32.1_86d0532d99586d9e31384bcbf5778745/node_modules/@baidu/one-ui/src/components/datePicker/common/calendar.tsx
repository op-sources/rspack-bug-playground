import React, {PureComponent} from 'react';
import {partial} from 'lodash';
import dayjs from 'dayjs';
import {
    formatPerMonthInDay,
    getTimeTramp,
    formatWeek
} from '../../../core/datePickerTools';
import {classnames} from '../../../core/commonTools';

interface RangeDayItemRenderProps {
    prefixCls: string,
    showYear: number,
    showMonth: number,
    onChange(value: string, readOnly: boolean): void,
    dateFormat: string,
    validateMinDate: string,
    validateMaxDate: string,
    endDate: string,
    beginDate: string,
    onMouseEnter(value: string): void,
    onMouseLeave(value: string): void,
    hoverDate: string,
    validateDisabled(value: {
        selectedValue: string[],
        dayItem: string,
        timeStamp: number,
        getTimeStamp(value: string): number
    }): boolean,
    mode: 'week' | 'date',
    multiple?: boolean
}

const betweenTime = (startTime, endTime, time) => startTime && endTime && time >= startTime && time <= endTime;
const normalizeWeekDays = (day, {minTime, maxTime, validator}, selectedValue) => {
    const dayTime = getTimeTramp(day.value);
    let disabled = false;
    if (dayTime > maxTime || dayTime < minTime) {
        disabled = true;
    }
    else if (validator && typeof validator === 'function') {
        disabled = validator({
            selectedValue,
            dayItem: day.value,
            timeStamp: dayTime,
            getTimeStamp: getTimeTramp
        });
    }
    day.disabled = disabled;
    return day;
};

export default class RangeDayItemRender extends PureComponent<RangeDayItemRenderProps> {

    static defaultProps = {
        onChange() {},
        onMouseEnter() {},
        onMouseLeave() {}
    }

    cache = {};

    memoize = function (param: string) {
        if (!this.cache[param]) {
            const date = param.split('/');
            const result = formatPerMonthInDay({
                year: date[0],
                month: date[1]
            });
            this.cache[param] = result;
        }
        return this.cache[param];
    };

    onClickDay = (value: string, disabled: boolean, readOnly: boolean) => {
        if (disabled) {
            return;
        }
        const {
            onChange,
            dateFormat,
            multiple
        } = this.props;
        onChange(dayjs(value).format(dateFormat), multiple && readOnly);
    }

    onMouseEnter = (value: string, disabled: boolean) => {
        if (disabled) {
            return;
        }
        this.props.onMouseEnter(value);
    }

    onMouseLeave = (value: string, disabled: boolean) => {
        if (disabled) {
            return;
        }
        this.props.onMouseLeave(value);
    }

    renderMonthItem = () => {
        const {
            showYear,
            showMonth,
            prefixCls,
            beginDate,
            validateMinDate,
            validateMaxDate,
            endDate,
            hoverDate,
            mode,
            multiple,
            validateDisabled
        } = this.props;

        const perMonthInDay = this.memoize(`${showYear}/${showMonth}`);
        const selectedValue = [beginDate, endDate].filter(Boolean);
        const minTime = getTimeTramp(validateMinDate);
        const maxTime = getTimeTramp(validateMaxDate);
        const validation = {
            minTime,
            maxTime,
            validator: validateDisabled
        };
        const weeks = formatWeek(perMonthInDay)
            .map(days => days.map(day => normalizeWeekDays(day, validation, selectedValue)));
        const itemDaysClx = `${prefixCls}-body-month`;
        const todayTime = getTimeTramp(dayjs().startOf('day'));
        let startTime = beginDate ? getTimeTramp(beginDate) : null;
        let endTime = endDate ? getTimeTramp(endDate) : startTime;
        const singleSelected = multiple && beginDate && !endDate;
        const hoverTime = hoverDate ? getTimeTramp(hoverDate) : null;
        if (singleSelected && hoverTime && hoverTime < startTime && mode === 'week') {
            startTime = Math.min(maxTime, getTimeTramp(dayjs(endTime).endOf('week').startOf('day')));
            endTime = startTime;
        }
        let hoverStartTime = hoverTime;
        let hoverEndTime = hoverTime;
        if (mode === 'week' && hoverTime) {
            hoverStartTime = Math.max(minTime, getTimeTramp(dayjs(hoverTime).startOf('week')));
            hoverEndTime = Math.min(maxTime, getTimeTramp(dayjs(hoverTime).endOf('week').startOf('day')));
        }
        const rangeStartTime = singleSelected && hoverStartTime ? Math.min(startTime, hoverStartTime) : startTime;
        const rangeEndTime = singleSelected && hoverEndTime ? Math.max(endTime, hoverEndTime) : endTime;

        return (
            <div className={itemDaysClx}>
                {
                    weeks.map((days, index) => {
                        return (
                            <div
                                key={`week-${index}`}
                                className={`${itemDaysClx}-week`}
                            >
                                {
                                    days.map(({value, label, disabled, isCurrentMonth}) => {
                                        const dayTime = getTimeTramp(value);
                                        const readOnly = !isCurrentMonth;
                                        const range = betweenTime(rangeStartTime, rangeEndTime, dayTime) && !readOnly && !disabled;
                                        const startSelected = (dayTime === startTime) && !readOnly;
                                        const endSelected = (dayTime === endTime) && !readOnly;
                                        const selected = startSelected || endSelected;

                                        const className = classnames(
                                            `${itemDaysClx}-item`,
                                            {
                                                [`${itemDaysClx}-item-read-only`]: readOnly,
                                                [`${itemDaysClx}-item-today`]: dayTime === todayTime && !readOnly,
                                                [`${itemDaysClx}-item-disabled`]: disabled,
                                                [`${itemDaysClx}-item-selected`]: selected,
                                                [`${itemDaysClx}-item-selected-start`]: startSelected,
                                                [`${itemDaysClx}-item-selected-end`]: endSelected,
                                                [`${itemDaysClx}-item-range`]: range,
                                                [`${itemDaysClx}-item-range-start`]: rangeStartTime === dayTime && !readOnly && !disabled,
                                                [`${itemDaysClx}-item-range-end`]: rangeEndTime === dayTime && !readOnly && !disabled,
                                                [`${itemDaysClx}-item-hover`]: !singleSelected && !readOnly && betweenTime(hoverStartTime, hoverEndTime, dayTime),
                                                [`${itemDaysClx}-item-hover-end`]: !singleSelected && !readOnly && hoverEndTime === dayTime
                                            }
                                        );
                                        return (
                                            <span
                                                key={value}
                                                className={className}
                                                onClick={partial(this.onClickDay, value, disabled, readOnly)}
                                                onMouseEnter={partial(this.onMouseEnter, value, disabled)}
                                                onMouseLeave={partial(this.onMouseLeave, value, disabled)}
                                            >
                                                <span>
                                                    {label}
                                                </span>
                                            </span>
                                        );
                                    })
                                }
                            </div>
                        );
                    })
                }
            </div>
        );
    }

    render() {
        return this.renderMonthItem();
    }
}
