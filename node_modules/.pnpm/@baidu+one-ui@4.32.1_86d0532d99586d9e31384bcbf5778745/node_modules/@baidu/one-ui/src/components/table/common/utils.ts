/**
 * @file 表格内部工具方法
 * @author huangshiming
 * @date 2020-05-15
 */
export const expandIconWidth = 38;

export const formatCellWidth = (width, totalWidth) => {
    if (typeof width === 'string') {
        if (width.indexOf('%') > -1) {
            return Math.floor((+(width.split('%')[0]) / 100) * totalWidth);
        }
        else if (width.indexOf('px') > -1) {
            return +(width.split('px')[0]);
        }
        return +width;
    }
    return width;
};

export const formatNormalWidth = (tableWidth, leftColumns = []) => {
    const noWidthColumns = leftColumns.filter(col => !col.width) || [];
    const hasWidthColumns = leftColumns.filter(col => col.width) || [];
    let spitWidth = 0;
    hasWidthColumns.forEach(col => {
        spitWidth += formatCellWidth(col.width, tableWidth);
    });
    const remainWidth = tableWidth - spitWidth;
    return remainWidth / ((noWidthColumns || []).length);
};

export const formatCellLeft = (width, prevWidth, totalWidth?) => {
    if (!width) {
        return prevWidth;
    }
    if (typeof width === 'string') {
        if (width.indexOf('%') > -1 && totalWidth) {
            const calWidth =  Math.floor(((+(width.split('%')[0])) / 100) * totalWidth);
            return calWidth + prevWidth;
        }
        else if (width.indexOf('px') > -1) {
            return +width.split('px')[0] + prevWidth;
        }
    }
    return width + prevWidth;
};

export const formatTableWidthWithAllColumnsWidth = allColumnsWidth => {
    if (!(allColumnsWidth && allColumnsWidth.length)) {
        return null;
    }
    let tableWidth = 0;
    allColumnsWidth.forEach(col => {
        tableWidth += col.width;
    });
    return tableWidth;
};

export const formatTableWidth = (bodyTable, scroll, expandedRowRender) => {
    let bodyWidth;
    const width = bodyTable.getBoundingClientRect().width;
    if (typeof scroll.x === 'number') {
        bodyWidth = scroll.x;
    }
    else if (typeof scroll.x === 'string') {
        if (scroll.x.indexOf('px') > -1) {
            bodyWidth = +scroll.x.split('px')[0];
        }
        else if (scroll.x.indexOf('%') > -1) {
            bodyWidth = Math.floor(width * (+scroll.x.split('%')[0] / 100));
        }
    }
    else {
        bodyWidth = width;
    }
    return bodyWidth;
};

export const isColumnWidthChange = (
    originColumns = [], newColumns = []
) => {
    if (originColumns.length !== newColumns.length) {
        return true;
    }
    return newColumns.some(({width, fixed, maxWidth, minWidth, children}, index) => {
        const col = originColumns[index];
        if (!col
            || (width !== col.width)
            || (fixed !== col.fixed)
            || (maxWidth !== col.maxWidth)
            || (minWidth !== col.minWidth)
        ) {
            return true;
        }
        if ((col.children || children)
            && isColumnWidthChange(col.children, children)) {
            return true;
        }
    });
};

export const leafColumns = columns => {
    const leafColumn = [];
    columns.forEach(column => {
        if (!column.children) {
            leafColumn.push(column);
        }
        else {
            leafColumn.push(...leafColumns(column.children));
        }
    });
    return leafColumn;
};

export const recalcWidthWhenColumnsChange = (
    allColumnsWidth = [],
    newColumns = [],
    oldColumns = [],
    tableWidth
) => {
    const columsMap = {};
    const oldColumnsMap = {};
    allColumnsWidth.forEach(col => {
        columsMap[col.key || col.dataIndex] = col;
    });

    leafColumns(oldColumns).forEach(col => {
        oldColumnsMap[col.key || col.dataIndex] = col;
    });
    let curWidth = 0;
    const leftColumns = leafColumns(newColumns);;
    const fixedWidth = leftColumns.filter(col => col.fixedWidth).reduce((width, col) => col.width + width, 0);
    const tableCalcWidth = tableWidth - fixedWidth;
    const normalWidth = formatNormalWidth(tableWidth, leftColumns);
    let prevCol;
    return leftColumns.map(
        (column, index) => {
            const key = column.key || column.dataIndex;
            const oldCol = oldColumnsMap[key];
            const col = columsMap[key];
            const keepLastWidth = leftColumns.length - 1 === index && prevCol && prevCol.dragged;

            const width = column.fixedWidth
                ? column.width
                : formatCellWidth(
                    (
                        (column.draggable && oldCol && oldCol.width === column.width)
                            ? ((col && (col.dragged || keepLastWidth) && col.width) || column.width || normalWidth)
                            : column.width || normalWidth
                    ),
                    tableCalcWidth
                );
            const minWidth = column.fixedWidth
                ? width
                : formatCellWidth((column.minWidth || column.width || normalWidth), tableCalcWidth);
            const maxWidth = column.fixedWidth
                ? width
                : formatCellWidth(column.maxWidth, tableCalcWidth) || null;
            curWidth = formatCellLeft(width, curWidth, tableCalcWidth);
            prevCol = col;
            return {
                ...col,
                key,
                width,
                minWidth,
                maxWidth,
                left: curWidth,
                fixed: column.fixed
            };
        }
    );
};

export const resetWidthByColumnsWidth = (
    newColumns = [],
    tableWidth
) => {
    const leftColumns = leafColumns(newColumns);
    const fixedWidth = leftColumns.filter(col => col.fixedWidth).reduce((width, col) => col.width + width, 0);
    const tableCalcWidth = tableWidth - fixedWidth;
    const normalWidth = formatNormalWidth(tableWidth, leftColumns);
    let curWidth = 0;
    return leftColumns.map(
        column => {
            const key = column.key || column.dataIndex;
            const width = column.fixedWidth
                ? column.width
                : formatCellWidth((column.width || normalWidth), tableCalcWidth);
            const minWidth = column.fixedWidth
                ? column.width
                : formatCellWidth((column.minWidth || column.width || normalWidth), tableCalcWidth);
            const maxWidth = column.fixedWidth
                ? column.width
                : formatCellWidth(column.maxWidth, tableCalcWidth) || null;
            curWidth = formatCellLeft(width, curWidth, tableCalcWidth);
            return {
                key,
                width,
                minWidth,
                maxWidth,
                left: curWidth,
                fixed: column.fixed,
                fixedWidth: column.fixedWidth
            };
        }
    );
};

export const uniformCalcWidth = (columns, tableWidth) => {
    if (!columns || !columns.length) {
        return columns;
    }
    let newColumnsWidth = 0;
    columns.forEach(col => {
        newColumnsWidth += col.width;
    });
    if (newColumnsWidth >= tableWidth) {
        return columns;
    }

    let gapWidth = tableWidth - newColumnsWidth;
    const fixedWidthColumns = columns.filter(col => col.fixedWidth);
    let everyColAddWidth = 0;
    if (columns.length > fixedWidthColumns.length) {
        everyColAddWidth = gapWidth / (columns.length - fixedWidthColumns.length);
    }
    let curWidth = 0;
    const newColumns = columns.map(
        column => {
            const key = column.key || column.dataIndex;
            const width = column.fixedWidth
                ? column.width
                : formatCellWidth((column.width + everyColAddWidth), tableWidth);
            const minWidth = column.fixedWidth
                ? column.width
                : formatCellWidth(column.minWidth, tableWidth);
            const maxWidth = column.fixedWidth
                ? column.width
                : formatCellWidth(column.maxWidth, tableWidth) || null;
            curWidth = formatCellLeft(width, curWidth, tableWidth);
            return {
                ...column,
                key,
                width,
                minWidth,
                maxWidth,
                left: curWidth
            };
        }
    );
    let columnsWidth = 0;
    newColumns.forEach(col => {
        columnsWidth += col.width;
    });
    if (columnsWidth < tableWidth) {
        newColumns[newColumns.length - 1].width += tableWidth - columnsWidth;
    }
    return newColumns;
};
