import React, {isValidElement, PureComponent, ReactElement, ReactNode} from 'react';
import {classnames} from '../../core/commonTools';
import Message from '../message';
import {IconQuestionCircle} from 'dls-icons-react';
import {FormContext, FormContextProps, FormFieldContext} from './context';
import {FormFieldOption, FormFieldProps} from './interface';
import {flattenDeep, pickBy, isEmpty} from 'lodash';
import Loading from '../loading';
import {COMPONENT_INVALID} from '../config';

interface FormFieldState {
    abstractFields: string[]
}

class FormField extends PureComponent<FormFieldProps, FormFieldState> {

    static defaultProps = {
        prefixCls: 'one-form',
        helpPosition: 'bottom',
        messageDisplay: 'simple',
        validateFirst: true
    }

    static contextType = FormFieldContext;

    formContext: FormContextProps;
    fieldNode: ReactNode;

    state = {
        abstractFields: []
    };

    componentDidMount() {
        const {
            name,
            abstract
        } = this.props;
        if (this.context && abstract && name) {
            this.context.register(name);
        }
    }

    componentWillUnmount() {
        const {
            name,
            abstract
        } = this.props;
        if (this.context && abstract && name) {
            this.context.unregister(name);
        }
    }

    className(name?: string) {
        const fieldName = `${this.props.prefixCls}-field`;
        if (name) {
            return fieldName + '-' + name;
        }
        return fieldName;
    }

    renderFieldNode() {
        const {
            name,
            rules,
            children,
            initialValue,
            trigger,
            validateTrigger,
            valuePropName,
            validate,
            normalize,
            getValueFromEvent,
            validateFirst,
            validateStatus,
            hidden,
            preserve
        } = this.props;
        const form = this.formContext.form;
        let fieldNode = children;
        if (name && form && React.isValidElement<Element>(children)) {
            fieldNode = React.cloneElement(children, {
                className: classnames(children.props.className, {
                    [COMPONENT_INVALID]: validateStatus === 'error' || !isEmpty(form.getFieldError(name))
                })
            });
            const options: FormFieldOption = {
                rules,
                initialValue,
                trigger,
                validateTrigger,
                valuePropName,
                validate,
                normalize,
                getValueFromEvent,
                validateFirst,
                hidden,
                preserve
            };
            fieldNode = form.getFieldDecorator(
                name, pickBy(options, val => val !== undefined))(fieldNode as ReactElement);
        }
        return fieldNode;
    }

    required() {
        const {
            required,
            rules
        } = this.props;

        return required == null ? (rules && rules.some(o => o.required)) : required;
    }

    renderTip() {
        const {
            tip
        } = this.props;
        if (tip) {
            if (typeof tip === 'object' && !isValidElement(tip)) {
                // message属性自定义
                return (
                    <Message
                        className={this.className('tip')}
                        icon={<IconQuestionCircle />}
                        type="aux"
                        size="small"
                        display="popup"
                        {...tip}
                    />
                );
            }
            return (
                <Message
                    className={this.className('tip')}
                    icon={<IconQuestionCircle />}
                    type="aux"
                    size="small"
                    display="popup"
                >
                    {tip}
                </Message>
            );
        }
        return null;
    }

    renderMain() {
        const {
            help,
            helpPosition
        } = this.props;
        const labelPosition = this.formContext.labelPosition;
        const children = this.renderFieldNode();
        const childrenNode =
            helpNode => <div key="Content" className={this.className('content')}>{children}{helpNode}</div>;
        if (!help) {
            return [childrenNode(null), this.renderMessages()];
        }
        const helpNode = this.renderHelp();
        if (helpPosition === 'top') {
            return [
                labelPosition !== 'top' ? helpNode : null,
                childrenNode(null),
                this.renderMessages()
            ];
        }
        else if (helpPosition === 'side') {
            return [
                childrenNode(helpNode),
                this.renderMessages()
            ];
        }
        return [
            childrenNode(null),
            this.renderMessages(helpNode)
        ];
    }

    private renderHelp() {
        const {
            help,
            helpPosition,
            messageDisplay
        } = this.props;

        if (!help) {
            return null;
        }

        return (
            <Message
                type="aux"
                size="small"
                display={messageDisplay}
                key="Help"
                className={classnames(
                    this.className('help'),
                    this.className(`help-position-${helpPosition}`)
                )}
            >
                {help}
            </Message>
        );
    }

    getMessage(fn, name, type) {
        return (fn(name) || []).map(content => ({
            type,
            content
        }));
    }

    renderMessages(helpNode = null) {
        const {
            messageDisplay,
            abstract,
            name,
            validateStatus,
            validateMessage
        } = this.props;

        if (!helpNode && abstract) {
            return null;
        }

        const form = this.formContext.form;

        let messages = [];
        if (!abstract && form) {
            if (validateMessage && validateStatus) {
                messages.push({type: validateStatus, content: validateMessage});
            }
            else {
                const fields = this.state.abstractFields.concat(name ? name : []);
                messages = fields.map(name => {
                    const items = [];
                    const validating = form.isFieldValidating(name);
                    if (validating && !form.isFormValidating()) {
                        items.push({type: 'validating', content: '校验中...'});
                    }
                    items.push(...this.getMessage(form.getFieldError, name, 'error'));
                    items.push(...this.getMessage(form.getFieldWarning, name, 'warning'));
                    items.push(...this.getMessage(form.getFieldSuccess, name, 'success'));
                    return items;
                });
            }
        }
        const flattenMessages = flattenDeep(messages);
        return flattenMessages.length
                ? (
                    <div key="Messages" className={this.className('messages')}>
                        {flattenMessages.map(
                            (message, index) => {
                                if (message.type === 'validating') {
                                    return <Loading key={index} size="small" tip="校验中..." />;
                                }
                                return (
                                    <Message
                                        size="small"
                                        type={message.type}
                                        key={index}
                                        display={messageDisplay}
                                    >
                                        {message.content}
                                    </Message>
                                );
                            }
                        )}
                        {helpNode}
                    </div>
                )
                : (helpNode ? <div key="Messages" className={this.className('message')}>{helpNode}</div> : null);
    }

    registerAbstractField = (name) => {
        this.setState(state => {
            const fields = state.abstractFields.slice();
            fields.push(name);
            return {
                abstractFields: fields
            };
        });
    }

    unregisterAbstractField = (name) => {
        this.setState(state => {
            const fields = state.abstractFields.filter(o => o !== name);
            return {
                abstractFields: fields
            };
        });
    }

    renderField(formContext = {}) {
        const {
            style,
            className,
            abstract,
            actions,
            display
        } = this.props;

        this.formContext = formContext;

        return (
            <div
                className={
                    classnames(className, this.className(), {
                        [this.className('abstract')]: abstract,
                        [this.className('actions')]: actions,
                        [this.className('standalone')]: display === 'standalone'
                    })
                }
                style={style}
            >
                {this.renderLabel()}
                <div className={this.className('main')}>
                    {abstract
                        ? this.renderMain()
                        : (
                            <FormFieldContext.Provider
                                value={{
                                    register: this.registerAbstractField,
                                    unregister: this.unregisterAbstractField
                                }}
                            >
                                {this.renderMain()}
                            </FormFieldContext.Provider>
                        )
                    }
                </div>
            </div>
        );
    }

    private renderLabel(helpNode?: ReactNode): ReactNode {
        const {
            label,
            abstract,
            htmlFor,
            helpPosition,
            help
        } = this.props;
        const {
            labelPosition,
            labelAlign
        } = this.formContext;

        if (label != null && !abstract) {
            return (
                <div
                    className={classnames(this.className('label'), {
                        [this.className('label-left')]: labelAlign === 'left',
                        [this.className('label-required')]: this.required(),
                        [this.className('label-align-help')]: help && labelPosition === 'side' && helpPosition === 'top'
                    })}
                >
                    <label
                        title={typeof label === 'string' ? label : ''}
                        htmlFor={htmlFor}
                    >
                        {label}
                    </label>
                    {this.renderTip()}
                    {labelPosition === 'top' && helpPosition === 'top'
                        ? this.renderHelp()
                        : helpNode
                    }
                </div>
            );
        }
        return labelPosition === 'top' && helpPosition === 'top' ? this.renderHelp() : null;
    }

    render() {
        return (
            <FormContext.Consumer>
                {context => this.renderField(context)}
            </FormContext.Consumer>
        );
    }
}

export default FormField;
