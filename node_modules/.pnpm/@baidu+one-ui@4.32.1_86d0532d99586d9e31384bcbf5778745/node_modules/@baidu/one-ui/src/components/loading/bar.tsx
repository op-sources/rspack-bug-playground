import React, {PureComponent} from 'react';
import {LoadingBarProps} from './interface';
import {withConfigConsumer} from '../providerConfig/context';
import Progress from '../progress';
import classnames from 'classnames';

const INTERVAL_RANGE = [200, 500];
const ROUND_STOPS = [0.4, 0.7, 0.8];
const ROUND_DELTA_RANGE = [-0.05, 0.1];
const STEP_VALUE = 0.05;
const MIN_STEP_VALUE = 0.005;

@withConfigConsumer('loading-bar')
class LoadingBar extends PureComponent<LoadingBarProps> {

    static defaultProps = {
        loading: true,
        prefixCls: 'one-loading-bar',
        size: 'medium'
    };

    state = {
        value: 0
    };

    static getDerivedStateFromProps(props) {
        if ('value' in props) {
            return {
                value: props.value
            };
        }
        return null;
    }

    render() {
        const {
            prefixCls,
            loading,
            className,
            ...restProps
        } = this.props;
        const value = this.state.value;

        return (
            <Progress
                className={
                    classnames(prefixCls, className, {
                        [`${prefixCls}-done`]: !loading
                    })
                }
                {...restProps}
                showInfo={false}
                width="100%"
                status="normal"
                percent={value * 100}
            />
        );
    }

    valueControlled() {
        return 'value' in this.props;
    }

    componentDidMount() {
        if (!this.valueControlled() && this.props.loading) {
            this.start();
        }
    }

    componentDidUpdate(prevProps) {
        const loading = this.props.loading;
        const preLoading = prevProps.loading;
        const stop = preLoading === true && loading === false;
        const start = preLoading === false && loading === true;
        const valueControlled = this.valueControlled();
        if (!valueControlled && stop) {
            this.stop(true);
        }
        else if (!valueControlled && start) {
            this.start();
        }
    }

    componentWillUnmount(): void {
        if (!this.valueControlled()) {
            this.stop(true);
        }
        if (this.startHandle) {
            cancelAnimationFrame(this.startHandle);
            this.startHandle = null;
        }
    }

    stepTimer;
    durationTimer;
    round = 0;
    stepValue = STEP_VALUE;
    startHandle;

    start() {
        this.stop();
        this.startHandle = requestAnimationFrame(() => {
            this.startHandle = null;
            this.step();
            const duration = this.props.duration;
            if (duration) {
                this.durationTimer = setTimeout(() => {
                    this.stop(true);
                }, duration);
            }
        });
    }

    step() {
        const {round, stepValue} = this;
        const {value} = this.state;

        let newValue;
        if (round < ROUND_STOPS.length) {
            const [minDelta, maxDelta] = ROUND_DELTA_RANGE;
            const delta = minDelta + Math.random() * (maxDelta - minDelta);
            newValue = Math.max(ROUND_STOPS[round] + delta, value);
        }
        else {
            newValue = Math.min(
                value + Math.max(MIN_STEP_VALUE, stepValue),
                1 - MIN_STEP_VALUE
            );
            this.stepValue /= 2;
        }

        this.setState({
            value: newValue
        });

        this.onChange(newValue);

        if (newValue < 1) {
            const [minInterval, maxInterval] = INTERVAL_RANGE;
            const interval = minInterval + Math.random() * (maxInterval - minInterval);
            this.stepTimer = setTimeout(() => {
                this.round++;
                this.step();
            }, interval);
        }
        else {
            this.stop(true);
        }
    }

    stop(done?: boolean) {
        clearTimeout(this.stepTimer);
        clearTimeout(this.durationTimer);
        this.stepTimer = null;
        this.durationTimer = null;
        this.round = 0;
        this.stepValue = STEP_VALUE;
        const value = done ? 1 : 0;
        this.setState({
            value
        });

        this.onChange(value);
    }

    onChange(value: number) {
        const onChange = this.props.onChange;
        if (onChange) {
            onChange(value);
        }
    }
}

export default LoadingBar;
