import React, {PureComponent, ReactNode} from 'react';
import {classnames} from '../../core/commonTools';
import Checkbox from './checkbox';
import Button from './button';
import {getRealValue} from '../../core/radioAndCheckboxTools';
import Context from './context';
import {CheckboxGroupProps, CheckboxProps} from './interface';
import {withConfigConsumer} from '../providerConfig/context';

interface CheckboxGroupState {
    value: (number | string)[]
};

type Option = {label: ReactNode, value: string | number, disabled?: boolean, exclusive?: boolean};

@withConfigConsumer('checkbox-group')
class CheckboxGroup extends PureComponent<CheckboxGroupProps, CheckboxGroupState> {
    static defaultProps: CheckboxGroupProps = {
        options: [],
        prefixCls: 'one-checkbox-group',
        size: 'medium',
        direction: 'row'
    };

    constructor(props: CheckboxGroupProps) {
        super(props);
        this.state = {
            value: getRealValue(props)
        };
    }

    getContext() {
        const {
            disabled,
            size,
            type
        } = this.props;
        return {
            toggleOption: this.toggleOption,
            register: this.register,
            unregister: this.unregister,
            value: this.state.value,
            disabled,
            size,
            type
        };
    }

    static getDerivedStateFromProps(nextProps: CheckboxGroupProps) {
        if (nextProps.value != null) {
            return {value: nextProps.value};
        }
        return null;
    }

    options = [];

    getOptions(): Option[] {
        return this.props.options.map(option => {
            if (typeof option === 'string' || typeof option === 'number') {
                return {
                    label: option,
                    value: option
                };
            }
            return option;
        });
    }

    register = (option) => {
        this.options.push(option);
    }

    unregister = (option) => {
        const index = this.options.findIndex(o => o === option);
        if (index > -1) {
            this.options.splice(index, 1);
        }
    }

    exclusive(val) {
        return this.options.some(({value, exclusive}) => val === value && exclusive);
    }

    toggleOption = (option: Option) => {
        const stateValue = this.state.value || [];
        const {
            value: optionValue,
            exclusive
        } = option;
        const {
            value: propsValue,
            onChange,
            emptyValue
        } = this.props;
        let value;
        if (exclusive) {
            value = [optionValue];
        }
        else {
            value = stateValue.filter(value => !this.exclusive(value));
            const optionIndex = stateValue.indexOf(optionValue);
            if (optionIndex === -1) {
                value.push(optionValue);
            }
            else {
                value.splice(optionIndex, 1);
            }
            if (value.length === 0 && emptyValue != null) {
                value = [emptyValue];
            }
        }
        if (propsValue == null) {
            this.setState({value});
        }
        if (onChange) {
            onChange(value);
        }
    };

    render() {
        const {
            prefixCls,
            className,
            options,
            disabled,
            direction,
            size,
            name,
            type,
            style
        } = this.props;
        let children = this.props.children;

        if (options && options.length > 0) {
            children = this.getOptions().map(option => {
                const {value, label, disabled: optionDisable, exclusive} = option;
                const stateValue = this.state.value || [];
                const props = {
                    name,
                    disabled: optionDisable != null ? optionDisable : disabled,
                    value,
                    exclusive,
                    checked: stateValue.indexOf(value) !== -1,
                    onChange: () => this.toggleOption(option)
                };
                if (type === 'strong' || type === 'simple') {
                    return (<Button key={value} {...props} type={type}>{label}</Button>);
                }
                return (
                    <Checkbox key={value} {...props}>{label}</Checkbox>
                );
            });
        }
        const classString = classnames(
            prefixCls,
            className,
            {
                [`${prefixCls}-${size}`]: size,
                [`${prefixCls}-${direction}`]: direction,
                [`${prefixCls}-${type}`]: type
            }
        );
        return (
            <Context.Provider value={this.getContext()}>
                <div className={classString} style={style}>
                    <div className={`${prefixCls}-items`}>
                        {children}
                    </div>
                </div>
            </Context.Provider>
        );
    }
}

export default CheckboxGroup;
