import React, {PureComponent, cloneElement} from 'react';
import {classnames} from '../../core/commonTools';
import CommonTooltip from './common/tooltip';
import getPlacements from './placements';
import {TooltipProps} from './interface';
import {withConfigConsumer} from '../providerConfig/context';

const splitObject = (obj, keys) => {
    const picked = {};
    const omited = {...obj};
    keys.forEach(key => {
        if (obj && key in obj) {
            picked[key] = obj[key];
            delete omited[key];
        }
    });
    return {picked, omited};
};

type TooltipState = {
    visible: boolean;
};

@withConfigConsumer('tooltip')
class Tooltip extends PureComponent<TooltipProps, TooltipState> {

    static defaultProps = {
        prefixCls: 'one-tooltip',
        placement: 'top',
        transitionName: 'zoom-big-fast',
        mouseEnterDelay: 0.1,
        mouseLeaveDelay: 0.1,
        arrowPointAtCenter: false,
        autoAdjustOverflow: true,
        type: 'light'
    };

    constructor(props) {
        super(props);

        this.state = {
            visible: !!props.visible || !!props.defaultVisible
        };
    }

    static getDerivedStateFromProps = (nextProps, prevState) => {
        if ('visible' in nextProps) {
            return {
                visible: nextProps.visible
            };
        }
        return null;
    }

    onVisibleChange = visible => {
        const {onVisibleChange} = this.props;
        if (!('visible' in this.props)) {
            this.setState({visible});
        }
        if (onVisibleChange) {
            onVisibleChange(visible);
        }
    };

    tooltipRef;

    getTooltipRef = ref => {
        this.tooltipRef = ref;
    }

    // 动态设置动画点
    onPopupAlign = (domNode, align) => {
        const placements = this.getPlacements();
        // 当前返回的位置
        const placement = Object.keys(placements).filter(
            key => (
                placements[key].points[0] === align.points[0]
                && placements[key].points[1] === align.points[1]
            ),
        )[0];
        if (!placement) {
            return;
        }
        // 根据当前坐标设置动画点
        const rect = domNode.getBoundingClientRect();
        const transformOrigin = {
            top: '50%',
            left: '50%'
        };
        if (placement.indexOf('top') >= 0 || placement.indexOf('Bottom') >= 0) {
            transformOrigin.top = `${rect.height - align.offset[1]}px`;
        }
        else if (placement.indexOf('Top') >= 0 || placement.indexOf('bottom') >= 0) {
            transformOrigin.top = `${-align.offset[1]}px`;
        }
        if (placement.indexOf('left') >= 0 || placement.indexOf('Right') >= 0) {
            transformOrigin.left = `${rect.width - align.offset[0]}px`;
        }
        else if (placement.indexOf('right') >= 0 || placement.indexOf('Left') >= 0) {
            transformOrigin.left = `${-align.offset[0]}px`;
        }
        if (placement.indexOf('top') >= 0) {
            domNode.style.top = (domNode.style.top.split('px') && `${+domNode.style.top.split('px')[0] + 4}px`)
                || domNode.style.top;
        }
        else if (placement.indexOf('bottom') >= 0) {
            domNode.style.top = (domNode.style.top.split('px') && `${+domNode.style.top.split('px')[0] - 4}px`)
                || domNode.style.top;
        }
        else if (placement.indexOf('right') >= 0) {
            domNode.style.left = (domNode.style.left.split('px') && `${+domNode.style.left.split('px')[0] - 4}px`)
                || domNode.style.left;
        }
        else if (placement.indexOf('left') >= 0) {
            domNode.style.left = (domNode.style.left.split('px') && `${+domNode.style.left.split('px')[0] + 4}px`)
                || domNode.style.left;
        }
        domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
    };

    getPlacements() {
        const {arrowPointAtCenter, autoAdjustOverflow} = this.props;
        return getPlacements({
            arrowPointAtCenter,
            verticalArrowShift: 8,
            autoAdjustOverflow
        });
    }

    // Fix Tooltip won't hide at disabled button
    getDisabledCompatibleChildren(element) {
        if (
            (element.type === 'button' || element.type.displayName === 'Button' || element.type.displayName === 'Switch')
                && element.props.disabled
                && this.isHoverTrigger()
        ) {
            // Pick some layout related style properties up to span
            const {picked, omited} = splitObject(
                element.props.style,
                ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex'],
            );
            const spanStyle = {
                display: 'inline-block', // default inline-block is important
                ...picked,
                cursor: 'not-allowed'
            };
            const buttonStyle = {
                ...omited,
                pointerEvents: 'none'
            };
            const child = cloneElement(element, {
                style: buttonStyle,
                className: null
            });
            return (
                <span style={spanStyle} className={element.props.className}>
                    {child}
                </span>
            );
        }
        return element;
    }

    isHoverTrigger() {
        const {trigger} = this.props;
        if (!trigger || trigger === 'hover') {
            return true;
        }
        if (Array.isArray(trigger)) {
            return trigger.indexOf('hover') >= 0;
        }
        return false;
    }

    isNoTitle() {
        const {title, overlay} = this.props;
        return !title && !overlay; // overlay for old version compatibility
    }

    render() {
        const {props, state} = this;
        const {
            prefixCls, title, overlay,
            openClassName, getPopupContainer,
            getTooltipContainer, overlayClassName, type
        } = props;
        const children = props.children;

        const visible = this.isNoTitle() ? false : state.visible;

        const child = this.getDisabledCompatibleChildren(
            React.isValidElement(children) ? children : <span>{children}</span>,
        );
        const childProps = child.props;
        const childCls = classnames(childProps.className, {
            [openClassName || `${prefixCls}-open`]: true
        });

        const tooltipOverlayClass = classnames(overlayClassName, `${prefixCls}-${type}`);

        return (
            <CommonTooltip
                {...this.props}
                ref={this.props.toolTipRef || this.getTooltipRef}
                getTooltipContainer={getPopupContainer || getTooltipContainer}
                builtinPlacements={this.getPlacements()}
                overlay={overlay || title || ''}
                visible={visible}
                onVisibleChange={this.onVisibleChange}
                // onPopupAlign={this.onPopupAlign}
                overlayClassName={tooltipOverlayClass}
            >
                {visible ? cloneElement(child, {className: childCls}) : child}
            </CommonTooltip>
        );
    }
}

export default Tooltip;
