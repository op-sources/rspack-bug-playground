import React, {PureComponent, cloneElement} from 'react';
import {IconTimesCircle} from 'dls-icons-react';
import omit from 'omit.js';
import Popover from '../popover';
import InputGroup from './group';

import {
    classnames,
    handleCountTips,
    CHINA_COUNT_MODE,
    getRealLength,
    handleEventParams
} from '../../core/commonTools';
import {
    handleErrorMessage,
    isMaxLenError,
    isMinLenError,
    fixControlledValue,
    commonRemoveProps,
    defaultInputWidth
} from '../../core/inputTools';
import {withConfigConsumer} from '../providerConfig/context';
import {InputProps} from './interface';
import {COMPONENT_FOCUS, COMPONENT_MAIN} from '../config';


interface InputState {
    value?: string;
    prevValue?: string;
    cacheValue?: string;
    hasFocus?: boolean;
    errorMessage?: string;
    countLabelWidth?: number;
};

@withConfigConsumer('input')
class Input extends PureComponent<InputProps, InputState> {
    static defaultProps = {
        prefixCls: 'one-input',
        disabled: false,
        readOnly: false,
        maxLen: null,
        minLen: null,
        errorMessage: null,
        showErrorMessage: true,
        errorLocation: 'right',
        isRequired: false,
        requiredErrorMessage: '',
        maxLenErrorMessage: '',
        minLenErrorMessage: '',
        width: null,
        style: {},
        filterArray: [],
        isErrorHTML: false,
        className: '',
        countMode: CHINA_COUNT_MODE,
        getLength: null,
        size: 'medium',
        originInputProps: {},
        type: 'normal',
        showClear: false,
        onClear() {}
    };

    constructor(props) {
        super(props);
        // const {value, errorMessage} = args;
        const value = typeof props.value === 'undefined' ? props.defaultValue : props.value;

        this.state = {
            hasFocus: false,
            countLabelWidth: 0,
            value,
            errorMessage: '', // errorMessage || ''
            prevValue: value,
            cacheValue: value
        };
    }

    static Group: typeof InputGroup;

    inputContainerRef;
    inputDetailRef;
    addonBeforeRef;
    addonAfterRef;
    inputCountAnchor;
    ___countLabelTimer___;
    ___imeStart___;

    componentDidMount() {
        this.setLabelWidth();
        const {width, style = {}} = this.props;
        const inputDetailRef = this.inputDetailRef;
        if (this.isAddonInput()) {
            // 组合的话要宽度要重新计算
            const inputWidth = width || style.width || defaultInputWidth;
            const addonBeforeRefWidth = (this.addonBeforeRef && this.addonBeforeRef.offsetWidth) || 0;
            const addonAfterRefWidth = (this.addonAfterRef && this.addonAfterRef.offsetWidth) || 0;
            inputDetailRef.style.width = `${inputWidth + addonBeforeRefWidth + addonAfterRefWidth}px`;
        }
        else if (style.width === '100%' || width === '100%') {
            // 父级别input也应该100%来自定义
            inputDetailRef.style.width = '100%';
            this.inputContainerRef.style.width = '100%';
        }
    }

    static getDerivedStateFromProps(nextProps, prevState) {
        const newState: InputState = {
            prevValue: nextProps.value
        };
        // state变化的时候不触发，只有props变化的时候触发，处理中文输入的时候onChange不触发时候改变了state的问题
        if ('value' in nextProps && nextProps.value !== prevState.prevValue) {
            newState.value = nextProps.value;
            newState.cacheValue = nextProps.value;
            const errorMessage = handleErrorMessage({
                ...nextProps,
                value: nextProps.value
            }, true, true);
            newState.errorMessage = errorMessage;
        }
        return newState;
    }

    componentWillUnmount() {
        clearTimeout(this.___countLabelTimer___);
    }

    onInputCompositionStart = () => {
        this.___imeStart___ = true;
    }

    onInputCompositionEnd = e => {
        this.___imeStart___ = false;
        this.onChange(e);
    }

    onChange = e => {
        const value = e.target.value;
        const props = this.props;
        if (this.___imeStart___) {
            this.setState({
                // value,
                cacheValue: value
            });
            return;
        }
        const errorMessage = handleErrorMessage({
            ...props,
            value
        }, true, true);
        const result = {
            value,
            errorMessage,
            event: e,
            target: e.target
        };
        const newState: InputState = {
            errorMessage
        };
        if (!('value' in this.props)) {
            newState.value = value;
            newState.cacheValue = value;
        }
        else {
            newState.cacheValue = this.state.value;
        }
        this.setState(newState);
        this.setLabelWidth();
        const onChange = props.onChange;
        if (onChange) {
            onChange(result);
        }
    }

    onClear = () => {
        const newState: InputState = {
            errorMessage: '',
            cacheValue: ''
        };
        if (!('value' in this.props)) {
            newState.value = '';
        }
        this.setState(newState);
        this.props.onClear();
    }
    onKeyDown = e => {
        const {
            onKeyDown,
            onPressEnter
        } = this.props;
        if (e.keyCode === 13 && onPressEnter) {
            onPressEnter({
                value: e.target.value,
                errorMessage: this.state.value
            });
        }
        if (onKeyDown) {
            onKeyDown(e);
        }
    }

    setLabelWidth = (showLabel = true) => {
        const me = this;
        const inputCountAnchor = me.inputCountAnchor;
        if (!inputCountAnchor) {
            me.setState({countLabelWidth: 0});
            return;
        }
        const countLabelWidth = showLabel ? inputCountAnchor.offsetWidth : 0;
        if (countLabelWidth === me.state.countLabelWidth) {
            return;
        }
        me.setState({countLabelWidth});
    }

    getInputClassName() {
        const {prefixCls, disabled, readOnly, size, prefix, suffix} = this.props;
        return classnames(prefixCls, {
            [COMPONENT_MAIN]: !(prefix || suffix),
            [`${prefixCls}-focus`]: !(prefix || suffix) && this.state.hasFocus,
            [`${prefixCls}-${size}`]: size,
            [`${prefixCls}-disabled`]: disabled,
            [`${prefixCls}-readOnly`]: readOnly
        });
    }

    focus = e => {
        this.___countLabelTimer___ = setTimeout(this.setLabelWidth, 0); // display为none时无法获取宽度
        this.setState({hasFocus: true});
        const onFocus = this.props.onFocus;
        if (onFocus) {
            onFocus(handleEventParams(e, this));
        }
    }

    blur = e => {
        this.setState({hasFocus: false});
        const onBlur = this.props.onBlur;
        if (onBlur) {
            onBlur(handleEventParams(e, this));
        }
    }

    renderInnerSuffix() {
        const {
            prefixCls,
            maxLen,
            errorMessage: propsErrorMessage,
            showClear
        } = this.props;
        const {value} = this.state;
        const operationClassName = classnames(
            `${prefixCls}-operation`,
            {
                [`${prefixCls}-operation-error`]: this.validateLength()
            });
        return (showClear && value && value.length) || maxLen != null
                ? (
                    <span
                        className={operationClassName}
                        ref={this.saveRef('inputCountAnchor')}
                    >
                        {this.renderClearIcon()}
                        {
                            maxLen != null
                                ? (
                                    <span className={`${prefixCls}-count`}>
                                        {handleCountTips(getRealLength(this.props, value), maxLen)}
                                    </span>
                                ) : null
                        }
                    </span>
                ) : null;
    }

    renderLabeledIcon(children) {
        const {
            prefix,
            suffix,
            prefixCls,
            className,
            style,
            disabled
        } = this.props;
        const inputContent = (
            <div className={`${prefixCls}-content`}>
                {
                    cloneElement(children, {style: {
                        paddingRight: this.state.countLabelWidth || null
                    }, className: this.getInputClassName()})
                }
                {this.renderInnerSuffix()}
            </div>
        );
        if (!prefix && !suffix) {
            return inputContent;
        }
        // 以下暂时未用到
        const prefixItem = prefix
            ? (
                <span className={`${prefixCls}-prefix`}>
                    {prefix}
                </span>
            )
            : null;
        const suffixItem = suffix
            ? (
                <span className={`${prefixCls}-suffix`}>
                    {suffix}
                </span>
            )
            : null;
        const wrapperClassName = classnames(
            className,
            COMPONENT_MAIN,
            `${prefixCls}-affix-wrapper`,
            {
                [`${prefixCls}-affix-wrapper-has-prefix`]: !!prefix,
                [`${prefixCls}-affix-wrapper-has-suffix`]: !!suffix,
                [`${prefixCls}-affix-wrapper-disabled`]: disabled,
                'one-input-focus': this.state.hasFocus
            }
        );
        return (
            <span className={wrapperClassName} style={style}>
                {prefixItem}
                {inputContent}
                {suffixItem}
            </span>
        );
    }

    renderInput() {
        const stateValue = this.state.value;
        const cacheValue = this.state.cacheValue;
        const props = this.props;
        const otherProps: JSX.IntrinsicElements['input'] = omit(props, [
            'prefixCls',
            'onPressEnter',
            'addonBefore',
            'addonAfter',
            'prefix',
            'suffix',
            'defaultValue',
            'originInputProps',
            'showClear',
            'onClear',
            ...commonRemoveProps,
            'filterArray',
            'isErrorHTML',
            'showErrorMessage',
            'inputRef'
        ]);
        otherProps.value = this.___imeStart___
            ? fixControlledValue(cacheValue)
            : fixControlledValue(stateValue);
        otherProps.style = {
            paddingRight: this.state.countLabelWidth || null
        };
        otherProps.onFocus = this.focus;
        otherProps.onBlur = this.blur;
        otherProps.onCompositionStart = this.onInputCompositionStart;
        otherProps.onCompositionEnd = this.onInputCompositionEnd;
        otherProps.onChange = this.onChange;
        otherProps.onKeyDown = this.onKeyDown;
        otherProps.ref = props.inputRef || this.saveRef('inputRef');

        return this.renderLabeledIcon(<input
            {...otherProps}
            {...props.originInputProps}
            data-type="input"
            className={classnames(this.getInputClassName())}
        />);
    }

    saveRef = name => node => {
        this[name] = node;
    };

    renderLabeledInput(children) {
        const {addonBefore, addonAfter, prefixCls, style} = this.props;
        if ((!addonBefore && !addonAfter)) {
            return children;
        }

        const wrapperClassName = `${prefixCls}-group`;
        const addonClassName = `${wrapperClassName}-addon`;
        const addonBeforeItem = addonBefore
            ? (
                <span
                    className={classnames(addonClassName, `${addonClassName}-before`)}
                    ref={this.saveRef('addonBeforeRef')}
                >
                    {addonBefore}
                </span>
            )
            : null;
        const addonAfterItem = addonAfter
            ? (
                <span
                    className={classnames(addonClassName, `${addonClassName}-after`)}
                    ref={this.saveRef('addonAfterRef')}
                >
                    {addonAfter}
                </span>
            )
            : null;
        const className = classnames(`${prefixCls}-wrapper`, {
            [wrapperClassName]: (addonBeforeItem || addonAfterItem)
        });
        if (addonBeforeItem || addonAfterItem) {
            return (
                <span className={`${prefixCls}-group-wrapper`} style={style}>
                    <span className={className}>
                        {addonBeforeItem}
                        {cloneElement(children, {style: null})}
                        {addonAfterItem}
                    </span>
                </span>
            );
        }
        return (
            <span className={className}>
                {addonBeforeItem}
                {children}
                {addonAfterItem}
            </span>
        );
    }

    renderClearIcon() {
        const {value} = this.state;
        const {prefixCls, showClear, maxLen, disabled, readOnly} = this.props;

        if (
            showClear
            && value
            && value.length
            && !disabled
            && !readOnly
        ) {
            const className = classnames(
                `${prefixCls}-clear-icon`,
                {
                    [`${prefixCls}-clear-icon-has-count`]: maxLen !== null
                }
            );

            return (<IconTimesCircle
                className={className}
                onClick={this.onClear}
            />);
        }

        return null;

    }

    isAddonInput = () => {
        const {addonBefore, addonAfter} = this.props;
        return addonBefore || addonAfter;
    }

    validateLength = () => {
        const value = this.state.value;
        const props = this.props;
        return ((value && value.length)
            && ((isMaxLenError({...props, value})
            || isMinLenError({...props, value})))) || '';
    }

    render() {
        const props = this.props;
        const {
            prefixCls,
            errorLocation,
            style = {},
            isErrorHTML,
            className,
            showErrorMessage: showError,
            errorMessage: propsErrorMessage,
            width,
            size,
            type,
            suffix,
            prefix
        } = props;
        const {hasFocus, errorMessage: stateErrorMessage} = this.state;
        const errorMessage = propsErrorMessage == null
            ? (stateErrorMessage || this.validateLength())
            : propsErrorMessage;
        const containerClass = `${prefixCls}-all-container`;
        const containerProps = {
            className: classnames(
                className,
                containerClass,
                `${containerClass}-${size}`,
                `${containerClass}-${type}`,
                {
                    [`${containerClass}-error`]: errorMessage,
                    [`${containerClass}-has-focused`]: hasFocus,
                    [COMPONENT_FOCUS]: hasFocus,
                    [`${containerClass}-has-suffix`]: !!suffix,
                    [`${containerClass}-has-prefix`]: !!prefix,
                    [`${containerClass}-error-bottom`]: errorLocation === 'bottom'
                }
            ),
            ref: this.saveRef('inputContainerRef')
        };
        const detailProps = {
            className: `${prefixCls}-detail`,
            style: {
                ...style
            },
            ref: this.saveRef('inputDetailRef')
        };
        if (!this.isAddonInput() && (width || style.width)) {
            detailProps.style.width = width || style.width;
        }
        const errorClass = `${prefixCls}-error`;
        const errorProps = {
            className: classnames(
                errorClass,
                `${errorClass}-${errorLocation}`
            )
        };
        const showErrorMessage = showError && (errorLocation === 'layer' ? hasFocus && errorMessage : errorMessage);
        const errorRender = isErrorHTML ? (
            <div
                {...errorProps}
                /* eslint-disable react/no-danger */
                dangerouslySetInnerHTML={{__html: errorMessage}}
            />
        ) : <div {...errorProps}>{errorMessage}</div>;

        let input = (
            <div {...detailProps}>
                {this.renderLabeledInput(this.renderInput())}
            </div>
        );

        if (errorLocation === 'layer') {
            input = (
                <Popover
                    visible={showErrorMessage}
                    content={errorRender}
                    placement="bottomLeft"
                >
                    {input}
                </Popover>
            )
        }

        return (
            <div {...containerProps}>
                {input}
                {errorLocation !== 'layer' && showErrorMessage ? errorRender : null}
            </div>
        );
    }
}

export default Input;
