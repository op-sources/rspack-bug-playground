import React, {createRef, PureComponent} from 'react';
import {
    IconSortAsc,
    IconSortDesc
} from 'dls-icons-react';
import Loading from '../loading';
import TableComponent from './common/table';
import {
    stopPropagation, flatArray, treeMap,
    flatFilter, createStore, classnames
} from '../../core/commonTools';
import Pagination, {PaginationProps} from '../pagination';
import FilterDropdown from './common/filterDropdown';
import SelectionBox from './common/selectionBox';
import SelectionCheckboxAll from './common/selectionCheckboxAll';
import Button from '../button';
import ColumnTitle from './columnTitle';
import {pick, isNumber} from 'lodash';
import {TableColumnProps, TableProps} from './interface';
import {withConfigConsumer} from '../providerConfig/context';
import shallowEqual from 'shallowequal';
import {expandIconWidth} from './common/utils';

const defaultPageSize = 20;

const selectionColumnWidth = 56;
const selectionColumnWidthwithoutDropdown = 48;

const defaultLocale = {
    filterTitle: '筛选',
    filterConfirm: '应用',
    filterClear: '清空',
    emptyText: '暂无数据',
    selectAll: '全选当页',
    selectInvert: '反选当页',
    loadingText: '加载中...'
};
const defaultPagination = {
    onPageSizeChange: () => {},
    onPageNoChange: () => {}
};

function getColumnKey(column, index?) {
    return column.key || column.dataIndex || index;
}

function getFilteredValueColumns(columns, useDefault = false) {
    const filteredValue = flatFilter(
        columns || [], column => typeof column.filteredValue !== 'undefined'
    );
    if (useDefault) {
        return (
            flatFilter(
                columns || [], column => typeof column.defaultFilteredValue !== 'undefined'
            ).concat(filteredValue));
    }
    return filteredValue;
}

function getFiltersFromColumns(columns, useDefault = false) {
    const filters = {};
    getFilteredValueColumns(columns, useDefault).forEach(col => {
        let filteredValue = [];
        if (useDefault) {
            filteredValue = col.filteredValue || col.defaultFilteredValue || [];
        }
        else {
            filteredValue = col.filteredValue;
        }
        filters[getColumnKey(col)] = filteredValue;
    });
    return filters;
}

function getSortOrderColumns(columns) {
    return flatFilter(columns || [], column => 'sortOrder' in column);
}

function getSortStateFromColumns(columns) {
    // return first column which sortOrder is not falsy
    const sortedColumn = getSortOrderColumns(columns).filter(col => col.sortOrder)[0];
    if (sortedColumn) {
        return {
            sortColumn: sortedColumn,
            sortOrder: sortedColumn.sortOrder
        };
    }
    return {
        sortColumn: null,
        sortOrder: null
    };
}

const emptyObject = {};

interface TableState {
    filters?: {
        [key: string]: []
    },
    pagination?: PaginationProps,
    columns?: TableProps['columns'],
    dataSource?: TableProps['dataSource']
    sortColumn?: TableColumnProps,
    sortOrder?: '' | 'descend' | 'ascend',
    store?
};

@withConfigConsumer('table')
class Table extends PureComponent<TableProps, TableState> {

    static defaultProps = {
        dataSource: [],
        prefixCls: 'one-table',
        rowSelection: null,
        className: '',
        loading: false,
        bordered: false,
        locale: {},
        rowKey: 'key',
        showHeader: true,
        expandIconClassName: '',
        onClickExpandIcon() {},
        size: 'medium',
        type: 'normal',
        onDragStart() {},
        onDraging() {},
        onDragEnd() {},
        headBordered: false,
        updateWidthChange: true,
        variant: 'normal'
    };

    constructor(props) {
        super(props);
        const columns = props.columns;
        this.store = createStore({
            selectedRowKeys: (props.rowSelection || {}).selectedRowKeys || [],
            selectionDirty: false
        });
        this.state = {
            columns,
            ...getSortStateFromColumns(columns),
            // 减少状态
            filters: getFiltersFromColumns(columns, true),
            pagination: this.getDefaultPagination(props),
            store: this.store
        };
        this.root = createRef();
    }

    columns;
    store;
    root;

    static getDerivedStateFromProps(props: TableProps, state: TableState) {
        const {
            columns,
            pagination,
            rowSelection,
            dataSource,
        } = props;
        const newState: TableState = {
            columns
        };
        if ('pagination' in props && pagination !== state.pagination) {
            if (pagination === false) {
                newState.pagination = emptyObject;
            }
            else {
                const newPagination = {
                    ...defaultPagination,
                    ...state.pagination
                };
                if (typeof pagination !== 'boolean') {
                    Object.assign(newPagination, pagination);
                }
                newPagination.pageNo = newPagination.pageNo || 1;
                newPagination.pageSize = newPagination.pageSize || defaultPageSize;
                newState.pagination = newPagination;
            }
        }
        if (rowSelection
            && 'selectedRowKeys' in rowSelection) {
            state.store.setState({
                selectedRowKeys: rowSelection.selectedRowKeys || []
            });
        }
        if ('dataSource' in props
            && dataSource !== state.dataSource) {
            state.store.setState({
                selectionDirty: false
            });
        }
        if (getSortOrderColumns(columns).length > 0) {
            const {sortColumn, sortOrder} = getSortStateFromColumns(columns);
            if (sortColumn !== state.sortColumn
                || sortOrder !== state.sortOrder) {
                newState.sortColumn = sortColumn;
                newState.sortOrder = sortOrder;
            }
        }
        const filteredValueColumns = getFilteredValueColumns(columns);
        if (filteredValueColumns.length > 0) {
            const filtersFromColumns = getFiltersFromColumns(columns);
            const newFilters = {...state.filters};
            Object.keys(filtersFromColumns).forEach(key => {
                newFilters[key] = filtersFromColumns[key];
            });
            if (!shallowEqual(newFilters, state.filters)) {
                newState.filters = newFilters;
            }
        }
        return newState;
    }

    getLocale() {
        return {
            ...defaultLocale,
            ...this.props.locale
        };
    }

    getCheckboxPropsByItem = (item, index): {
        visible?: boolean, disabled?: boolean, indeterminate?: boolean, defaultChecked?: boolean
    } => {
        const {rowSelection} = this.props;
        if (!rowSelection.getCheckboxProps) {
            return {};
        }
        const props = rowSelection.getCheckboxProps(item);
        if (props.visible === false) {
            props.disabled = true;
        }
        return props;
    }

    getDefaultPagination(props) {
        const pagination = props.pagination || {};
        return this.hasPagination(props)
            ? {
                ...defaultPagination,
                ...pagination,
                pageNo: pagination.pageNo || 1,
                pageSize: pagination.pageSize || defaultPageSize
            } : {};
    }

    getDefaultSelection() {
        const {rowSelection} = this.props;
        if (!rowSelection.getCheckboxProps) {
            return [];
        }
        return this.getFlatData()
            .filter((item, rowIndex) => this.getCheckboxPropsByItem(item, rowIndex).defaultChecked)
            .map((record, rowIndex) => this.getRecordKey(record, rowIndex));
    }

    setSelectedRowKeys(selectedRowKeys, {selectWay, record, checked, changeRowKeys}: {selectWay, record?, checked, changeRowKeys?}) {
        const {rowSelection} = this.props;
        if (rowSelection && !('selectedRowKeys' in rowSelection)) {
            this.store.setState({selectedRowKeys});
        }
        const data = this.getFlatData();
        if (!rowSelection.onChange && !rowSelection[selectWay]) {
            return;
        }
        const selectedRows = data.filter(
            (row, i) => selectedRowKeys.indexOf(this.getRecordKey(row, i)) >= 0,
        );
        if (rowSelection.onChange) {
            rowSelection.onChange(selectedRowKeys, selectedRows);
        }
        if (selectWay === 'onSelect' && rowSelection.onSelect) {
            rowSelection.onSelect(record, checked, selectedRows);
        }
        else if (selectWay === 'onSelectAll' && rowSelection.onSelectAll) {
            const changeRows = data.filter(
                (row, i) => changeRowKeys.indexOf(this.getRecordKey(row, i)) >= 0,
            );
            rowSelection.onSelectAll(checked, selectedRows, changeRows);
        }
        else if (selectWay === 'onSelectInvert' && rowSelection.onSelectInvert) {
            rowSelection.onSelectInvert(selectedRowKeys);
        }
    }

    getLocalData() {
        const state = this.state;
        const {dataSource} = this.props;
        let data = dataSource || [];
        // 优化本地排序
        data = data.slice(0);
        const sorterFn = this.getSorterFn();
        if (sorterFn) {
            data = this.recursiveSort(data, sorterFn);
        }
        // 筛选
        if (state.filters) {
            Object.keys(state.filters).forEach(columnKey => {
                const col = this.findColumn(columnKey);
                if (!col) {
                    return;
                }
                const values = state.filters[columnKey] || [];
                if (values.length === 0) {
                    return;
                }
                const onFilter = col.onFilter;
                data = onFilter ? data.filter(record => {
                    return values.some(v => onFilter(v, record));
                }) : data;
            });
        }
        return data;
    }

    getSorterFn() {
        const {sortOrder, sortColumn} = this.state;
        const sorter = sortColumn?.sorter;
        if (!sortOrder || !sortColumn
            || typeof sorter !== 'function') {
            return;
        }
        return (a, b) => {
            const result = sorter(a, b);
            if (result !== 0) {
                return (sortOrder === 'descend') ? -result : result;
            }
            return 0;
        };
    }

    getRecordKey = (record, index) => {
        const rowKey = this.props.rowKey;
        const recordKey = (typeof rowKey === 'function')
            ? rowKey(record, index) : record[rowKey];
        return recordKey === undefined ? index : recordKey;
    }

    getPopupContainer = () => {
        return this.root.current;
    }

    getScrollContainer = () => {
        return this.refNodes.bodyTable;
    }

    getCurrentPageData() {
        let data = this.getLocalData();
        let pageNo;
        let pageSize;
        const state = this.state;
        // 如果没有分页的话，默认全部展示
        if (!this.hasPagination()) {
            pageSize = Number.MAX_VALUE;
            pageNo = 1;
        }
        else {
            pageSize = state.pagination.pageSize;
            pageNo = this.getMaxCurrent(state.pagination.total || data.length);
        }
        // 分页
        // ---
        // 当数据量少于等于每页数量时，直接设置数据
        // 否则进行读取分页数据
        if (data.length > pageSize || pageSize === Number.MAX_VALUE) {
            data = data.filter((_, i) => {
                return i >= (pageNo - 1) * pageSize && i < pageNo * pageSize;
            });
        }
        return data;
    }

    getFlatCurrentPageData() {
        return flatArray(this.getCurrentPageData());
    }

    getMaxCurrent(total) {
        const {pageNo, pageSize} = this.state.pagination;
        if ((pageNo - 1) * pageSize >= total) {
            return Math.floor((total - 1) / pageSize) + 1;
        }
        return pageNo;
    }

    getFlatData() {
        return flatArray(this.getLocalData());
    }

    isFiltersChanged(filters) {
        let filtersChanged = false;
        if (Object.keys(filters).length !== Object.keys(this.state.filters).length) {
            filtersChanged = true;
        }
        else {
            Object.keys(filters).forEach(columnKey => {
                if (filters[columnKey] !== this.state.filters[columnKey]) {
                    filtersChanged = true;
                }
            });
        }
        return filtersChanged;
    }

    hasPagination(props?) {
        return (props || this.props).pagination !== false;
    }

    toggleSortOrder = column => {
        const isSortColumn = this.isSortColumn(column);
        let {sortColumn, sortOrder} = this.state;
        const isAscend = isSortColumn && sortOrder === 'ascend';
        const isDescend = isSortColumn && sortOrder === 'descend';
        const initialSortType = column.initialSortType || 'descend';
        let order = initialSortType;
        if (isAscend) {
            order = 'descend';
        }
        else if (isDescend) {
            order = 'ascend';
        }
        // 只同时允许一列进行排序，否则会导致排序顺序的逻辑问题
        if (!isSortColumn) { // 当前列未排序
            sortOrder = order;
            sortColumn = column;
        }
        else if ((isAscend || isDescend) && order === initialSortType) { // 当前列已排序
            // 切换为未排序状态
            sortOrder = '';
            sortColumn = null;
        }
        else { // 切换为排序状态
            sortOrder = order;
        }
        const newState = {
            sortOrder,
            sortColumn
        };
        // Controlled
        if (getSortOrderColumns(this.state.columns).length === 0) {
            this.setState(newState);
        }
        const onSortClick = this.props.onSortClick;
        if (onSortClick) {
            onSortClick(newState);
        }
    }

    handleFilter = (columnKey, nextFilters) => {
        const filters = {
            ...this.state.filters,
            [columnKey]: nextFilters
        };
        // Remove filters not in current columns
        const currentColumnKeys = [];
        treeMap(this.state.columns, c => {
            if (!c.children) {
                currentColumnKeys.push(getColumnKey(c));
            }
        });
        Object.keys(filters).forEach(columnKey => {
            if (currentColumnKeys.indexOf(columnKey) < 0) {
                delete filters[columnKey];
            }
        });
        const newState = {
            // pagination,
            filters: {}
        };
        const filtersToSetState = {...filters};
        // Remove filters which is controlled
        getFilteredValueColumns(this.state.columns).forEach(col => {
            const columnKey = getColumnKey(col);
            if (columnKey) {
                delete filtersToSetState[columnKey];
            }
        });
        if (Object.keys(filtersToSetState).length > 0) {
            newState.filters = filtersToSetState;
        }
        this.setState(newState, () => {
            this.store.setState({
                selectionDirty: false
            });
            const onFilterChange = this.props.onFilterChange;
            if (onFilterChange) {
                onFilterChange(filters);
            }
        });
    }

    handleSelect = (record, rowIndex, e) => {
        const checked = e.target.checked;
        const defaultSelection = this.store.getState().selectionDirty ? [] : this.getDefaultSelection();
        let selectedRowKeys = this.store.getState().selectedRowKeys.concat(defaultSelection);
        const key = this.getRecordKey(record, rowIndex);
        if (checked) {
            selectedRowKeys.push(this.getRecordKey(record, rowIndex));
        }
        else {
            selectedRowKeys = selectedRowKeys.filter(i => key !== i);
        }
        this.store.setState({
            selectionDirty: true
        });
        this.setSelectedRowKeys(selectedRowKeys, {
            selectWay: 'onSelect',
            record,
            checked
        });
    }

    handleRadioSelect = (record, rowIndex, e) => {
        const checked = e.target.checked;
        const defaultSelection = this.store.getState().selectionDirty ? [] : this.getDefaultSelection();
        let selectedRowKeys = this.store.getState().selectedRowKeys.concat(defaultSelection);
        const key = this.getRecordKey(record, rowIndex);
        selectedRowKeys = [key];
        this.store.setState({
            selectionDirty: true
        });
        this.setSelectedRowKeys(selectedRowKeys, {
            selectWay: 'onSelect',
            record,
            checked
        });
    }

    handleSelectRow = (selectionKey, index, onSelectFunc) => {
        const data = this.getFlatCurrentPageData();
        const defaultSelection = this.store.getState().selectionDirty ? [] : this.getDefaultSelection();
        const selectedRowKeys = this.store.getState().selectedRowKeys.concat(defaultSelection);
        const changeableRowKeys = data
            .filter((item, i) => !this.getCheckboxPropsByItem(item, i).disabled)
            .map((item, i) => this.getRecordKey(item, i));
        const changeRowKeys = [];
        let selectWay = '';
        let checked;
        // handle default selection
        switch (selectionKey) {
            case 'all':
                changeableRowKeys.forEach(key => {
                    if (selectedRowKeys.indexOf(key) < 0) {
                        selectedRowKeys.push(key);
                        changeRowKeys.push(key);
                    }
                });
                selectWay = 'onSelectAll';
                checked = true;
                break;
            case 'removeAll':
                changeableRowKeys.forEach(key => {
                    if (selectedRowKeys.indexOf(key) >= 0) {
                        selectedRowKeys.splice(selectedRowKeys.indexOf(key), 1);
                        changeRowKeys.push(key);
                    }
                });
                selectWay = 'onSelectAll';
                checked = false;
                break;
            case 'invert':
                changeableRowKeys.forEach(key => {
                    if (selectedRowKeys.indexOf(key) < 0) {
                        selectedRowKeys.push(key);
                    }
                    else {
                        selectedRowKeys.splice(selectedRowKeys.indexOf(key), 1);
                    }
                    changeRowKeys.push(key);
                    selectWay = 'onSelectInvert';
                });
                break;
            default:
                break;
        }
        this.store.setState({
            selectionDirty: true
        });
        // when select custom selection, callback selections[n].onSelect
        const {rowSelection} = this.props;
        let customSelectionStartIndex = 2;
        if (rowSelection && rowSelection.hideDefaultSelections) {
            customSelectionStartIndex = 0;
        }
        if (index >= customSelectionStartIndex && typeof onSelectFunc === 'function') {
            return onSelectFunc(changeableRowKeys);
        }
        this.setSelectedRowKeys(selectedRowKeys, {
            selectWay,
            checked,
            changeRowKeys
        });
    }

    handlePageChange = e => {
        const props = this.props;
        const pageNo = +e.target.value;
        const pagination = {...this.state.pagination};
        if (pageNo) {
            pagination.pageNo = pageNo;
        }
        else {
            pagination.pageNo = pagination.pageNo || 1;
        }
        const newPageNo = pagination.pageNo;
        pagination.onPageNoChange({
            // @ts-ignore
            pageNo: newPageNo,
            pageSize: pagination.pageSize,
            target: {
                value: newPageNo
            }
        });
        const newState = {
            pagination
        };
        // Controlled current prop will not respond user interaction
        if (props.pagination
            && typeof props.pagination === 'object'
            && 'pageNo' in (props.pagination)) {
            newState.pagination = {
                ...pagination,
                pageNo: this.state.pagination.pageNo
            };
        }
        this.setState(newState);
        this.store.setState({
            selectionDirty: false
        });
    }

    isSortColumn(column) {
        const {sortColumn} = this.state;
        if (!column || !sortColumn) {
            return false;
        }
        return getColumnKey(sortColumn) === getColumnKey(column);
    }

    handleShowSizeChange = e => {
        const pagination = this.state.pagination;
        const pageSize = +e.target.value;
        const total = pagination.total || this.getLocalData().length;
        const pageNo = this.getMaxCurrent(total);
        pagination.onPageSizeChange({
            // @ts-ignore
            pageNo,
            pageSize,
            // 应该暴露的e.target.value, 但是因为之前已经这样暴露了，所以封装了一下
            target: {
                value: pageSize
            }
        });
        const nextPagination = {
            ...pagination,
            pageSize,
            pageNo
        };
        this.setState({pagination: nextPagination});
    }

    findColumn(myKey) {
        let column;
        treeMap(this.state.columns, c => {
            if (getColumnKey(c) === myKey) {
                column = c;
            }
        });
        return column;
    }

    recursiveSort(data, sorterFn) {
        // const {childrenColumnName = 'children'} = this.props;
        const childrenColumnName = 'children';
        return data.sort(sorterFn).map(item => (item[childrenColumnName] ? {
            ...item,
            [childrenColumnName]: this.recursiveSort(item[childrenColumnName], sorterFn)
        } : item));
    }

    renderPagination() {
        // 强制不需要分页
        if (!this.hasPagination()) {
            return null;
        }
        let size: PaginationProps['size'] = 'medium';
        const pagination = this.state.pagination;
        if (pagination.size) {
            size = pagination.size;
        }
        const total = pagination.total || this.getLocalData().length;
        return (total > 0) ? (
            <Pagination
                key="pagination"
                {...pagination}
                className={classnames(pagination.className, `${this.props.prefixCls}-pagination`)}
                onPageNoChange={this.handlePageChange}
                total={total}
                size={size}
                pageNo={this.getMaxCurrent(total)}
                onPageSizeChange={this.handleShowSizeChange}
            />
        ) : null;
    }

    normalizeColumns(columns) {
        return treeMap(columns, (originColumn, i, parent) => {
            const column = {
                ...originColumn,
                renderTitle: this.renderColumnTitle
            };
            if (isNumber(column.minWidth) && isNumber(column.width) && column.minWidth > column.width) {
                column.minWidth = column.width;
            }
            if (column.children && column.children.length === 0) {
                column.children = undefined;
            }
            column.key = getColumnKey(column, i);
            const isSortColumn = this.isSortColumn(column);
            if (isSortColumn) {
                column.sortOrderFlag = this.state.sortOrder;
            }
            if (column.sorter || column.customSortNode) {
                column.toggleSortOrder = this.toggleSortOrder;
            }
            column.filtersFlag = this.state.filters[column.key];
            if (parent) {
                column.fixed =  parent.fixed;
            }
            return column;
        });
    }

    renderColumnTitle = column => {
        const {prefixCls, dropdownPrefixCls, autoHideOperation, size} = this.props;
        const {sortOrder, filters} = this.state;
        const locale = this.getLocale();
        const key = getColumnKey(column);
        let filterDropdown;
        let sortButton;
        let filtered = false;
        if (((column.filters && column.filters.length > 0) || column.filterDropdown)
            && column.filterIconVisible !== false) {
            const colFilters = this.state.filters[key] || [];
            filtered = colFilters.length > 0;
            filterDropdown = (
                <FilterDropdown
                    filterTitleText={locale.filterTitle}
                    filterConfirmText={locale.filterConfirm}
                    filterClearText={locale.filterClear}
                    size={size}
                    selectedKeys={colFilters}
                    confirmFilter={this.handleFilter}
                    prefixCls={`${prefixCls}-filter`}
                    dropdownPrefixCls={dropdownPrefixCls || 'one-dropdown'}
                    getPopupContainer={this.getPopupContainer}
                    getScrollContainer={this.getScrollContainer}
                    columnKey={key}
                    {...pick(column, [
                        'filterMultiple',
                        'filterProps',
                        'filterDropdown',
                        'filters',
                        'filterDropdownVisible',
                        'onFilterDropdownVisibleChange',
                        'filterIcon',
                        'filterWithoutConfirm',
                        'filteredValue',
                        'defaultFilteredValue',
                        'onFilter',
                        'filterDropdownTitle',
                        'filterDropdownProps'
                    ])}
                />
            );
        }
        const customSortNode = column.customSortNode;
        let sorted = false;
        if (column.sorter || customSortNode) {
            const isSortColumn = this.isSortColumn(column);
            sorted = isSortColumn && !!sortOrder;
            const isAscend = isSortColumn && sortOrder === 'ascend';
            const isDescend = isSortColumn && sortOrder === 'descend';
            const clickSorter = () => this.toggleSortOrder(column);
            // 支持自定义排序节点， 如果没传入就用默认的
            sortButton = customSortNode || (
                <Button size={size} type="text" onClick={clickSorter} className={`${prefixCls}-sort-icon-set`}>
                    <IconSortAsc
                        className={classnames(`${prefixCls}-sorted-up-icon`, {
                            [`${prefixCls}-sorted-up-icon-active`]: isAscend
                        })}
                    />
                    <IconSortDesc className={classnames(
                        `${prefixCls}-sorted-down-icon`,
                        {
                            [`${prefixCls}-sorted-up-icon-active`]: isDescend
                        }
                    )}
                    />
                </Button>
            );
        }
        const title = typeof column.title === 'function' ? column.title({sortOrder, filters}) : column.title;
        const autohide = autoHideOperation === 'all';
        const autohideFilter = (autohide || autoHideOperation === 'filter') && !filtered;
        const autohideSort = (autohide || autoHideOperation === 'sort') && !sorted;
        return (
            <div className={`${prefixCls}-column-head`}>
                <div className={`${prefixCls}-column-title`}>
                    <ColumnTitle title={title} desc={column.desc} />
                </div>
                {
                    sortButton || filterDropdown || (column.customOperate && column.customOperate.length) ? (
                        <div className={`${prefixCls}-column-operate`}>
                            {
                                sortButton ? (
                                    <span className={
                                        classnames(
                                            `${prefixCls}-column-operate-item`,
                                            `${prefixCls}-column-operate-sort-item`,
                                            {
                                                [`${prefixCls}-column-operate-item-autohide`]: autohideSort
                                            }
                                        )}
                                    >
                                        {sortButton}
                                    </span>
                                ) : null
                            }
                            {
                                filterDropdown ? (
                                    <span className={
                                        classnames(
                                            `${prefixCls}-column-operate-item`,
                                            `${prefixCls}-column-operate-filter-item`,
                                            {
                                                [`${prefixCls}-column-operate-item-autohide`]: autohideFilter
                                            }
                                        )}
                                    >
                                        {filterDropdown}
                                    </span>
                                ) : null
                            }
                            {
                                column.customOperate && column.customOperate.map((itemNode, key) => {
                                    return itemNode ? (
                                        <span
                                            className={`${prefixCls}-column-operate-item`}
                                            key={key}
                                        >
                                            {itemNode}
                                        </span>
                                    ) : null;
                                })
                            }
                        </div>
                    ) : null
                }
            </div>
        );
    }

    renderRowSelection() {
        const {prefixCls, rowSelection, expandIconAsCell} = this.props;
        const columns = this.state.columns.concat();
        if (rowSelection) {
            const data = this.getFlatCurrentPageData().filter((item, index) => {
                if (rowSelection.getCheckboxProps) {
                    return !this.getCheckboxPropsByItem(item, index).disabled;
                }
                return true;
            });
            const selectionColumnClass = classnames(`${prefixCls}-selection-column`, {
                [`${prefixCls}-selection-column-custom`]: rowSelection.selections
            });
            const selectionColumn: TableColumnProps = {
                key: 'selection-column',
                fixedWidth: true,
                // type变化更新
                dataIndex: `__ONE__${rowSelection.type}`,
                // 当有getCheckboxProps时(无法感知变化)，强制render
                render: rowSelection.getCheckboxProps
                    ? (value, record, index) => this.renderSelectionBox(value, record, index)
                    : this.renderSelectionBox,
                className: selectionColumnClass
            };
            const locale = this.getLocale();
            if (rowSelection.type !== 'radio') {
                const checkboxAllDisabled = data.every(
                    (item, index) => this.getCheckboxPropsByItem(item, index)
                        .disabled);
                selectionColumn.title = (
                    <SelectionCheckboxAll
                        store={this.store}
                        selectAllText={locale.selectAll}
                        selectInvertText={locale.selectInvert}
                        data={data}
                        getCheckboxPropsByItem={this.getCheckboxPropsByItem}
                        getRecordKey={this.getRecordKey}
                        disabled={checkboxAllDisabled}
                        prefixCls={prefixCls}
                        onSelect={this.handleSelectRow}
                        selections={rowSelection.selections}
                        hideDefaultSelections={rowSelection.hideDefaultSelections}
                        getPopupContainer={this.getPopupContainer}
                    />
                );
            }
            if (rowSelection.renderCheckbox) {
                selectionColumn.title = rowSelection.renderCheckbox(null, selectionColumn.title);
            }
            if (rowSelection.fixed || columns.some(column => column.fixed === 'left' || column.fixed === true)) {
                selectionColumn.fixed = 'left';
            }
            let hasSelections = false;
            const selections = rowSelection.selections;
            if (selections) {
                if (!rowSelection.hideDefaultSelections || (
                    Array.isArray(rowSelection.selections)
                    && rowSelection.selections.length
                )) {
                    hasSelections = true;
                }
            }
            selectionColumn.width = hasSelections ? selectionColumnWidth : selectionColumnWidthwithoutDropdown;
            if (columns[0] && columns[0].key === 'selection-column') {
                columns[0] = selectionColumn;
            }
            else {
                columns.unshift(selectionColumn);
            }
        }
        return columns;
    }

    renderSelectionBox = (_, record, index) => {
        const {rowSelection = {}} = this.props;
        const rowIndex = this.getRecordKey(record, index); // 从 1 开始
        const props = this.getCheckboxPropsByItem(record, index);
        if (props.visible === false) {
            return null;
        }
        const type = rowSelection.type;
        const handleChange = e => {
            if (type === 'radio') {
                this.handleRadioSelect(record, index, e);
            }
            else {
                this.handleSelect(record, index, e);
            }
        };
        const checkboxNode = (
            <span onClick={stopPropagation}>
                <SelectionBox
                    type={type}
                    store={this.store}
                    rowIndex={rowIndex}
                    disabled={props.disabled}
                    indeterminate={props.indeterminate}
                    onChange={handleChange}
                    defaultSelection={this.getDefaultSelection()}
                />
            </span>
        );

        if (rowSelection.renderCheckbox) {
            return rowSelection.renderCheckbox(record, checkboxNode);
        }

        return checkboxNode;
    };

    tableRef = ref => {
        this.tableContainerRef = ref;
    }

    refNodes: any = {};
    tableContainerRef;

    saveRef = (name, node) => {
        this.refNodes[name] = node;
    }

    updateColumnWidths = columns => {
        if (this.tableContainerRef
            && typeof this.tableContainerRef.updateColumnWidths === 'function') {
            this.tableContainerRef.updateColumnWidths(columns);
        }
    }

    render() {
        const {
            style,
            className,
            prefixCls,
            showHeader,
            loading,
            size,
            type,
            onDragStart,
            onDraging,
            onDragEnd,
            useStickyFixTop,
            pagination,
            cellLines,
            headCellLines,
            loadingOption,
            bordered,
            headBordered,
            variant,
            ...restProps
        } = this.props;
        const data = this.getCurrentPageData();
        let columns = this.renderRowSelection();
        const expandIconAsCell = this.props.expandedRowRender && this.props.expandIconAsCell !== false;
        if (expandIconAsCell) {
            const fixedLeft = columns.some(column => column.fixed === 'left' || column.fixed === true);
            columns.unshift({
                key: 'one-table-expand-icon-cell',
                width: expandIconWidth,
                fixedWidth: true,
                fixed: fixedLeft ? 'left' : null
            });
        }
        const locale = this.getLocale();
        const classString = classnames(`${prefixCls}-${size}`, {
            [`${prefixCls}-bordered`]: bordered,
            [`${prefixCls}-head-bordered`]: headBordered,
            [`${prefixCls}-empty`]: !data.length,
            [`${prefixCls}-without-column-header`]: !showHeader,
            [`${prefixCls}-with-line-clamp`]: cellLines,
            [`${prefixCls}-with-head-line-clamp`]: headCellLines,
            [`${prefixCls}-variant-${variant}`]: variant,
            [`${prefixCls}-loading-backdrop`]: (
                !loadingOption
                || (loadingOption.type === 'bar' && loadingOption.modal !== false)) && loading
        });
        columns = this.normalizeColumns(columns);
        let expandIconColumnIndex = (columns[0] && columns[0].key === 'selection-column') ? 1 : 0;
        if ('expandIconColumnIndex' in restProps) {
            expandIconColumnIndex = restProps.expandIconColumnIndex;
        }
        const table = (
            <TableComponent
                ref={this.tableRef}
                saveRef={this.saveRef}
                key="table"
                {...restProps}
                prefixCls={prefixCls}
                data={data}
                columns={columns}
                showHeader={showHeader}
                className={classString}
                expandIconColumnIndex={expandIconColumnIndex}
                expandIconAsCell={expandIconAsCell}
                emptyText={locale.emptyText}
                onDragStart={onDragStart}
                onDraging={onDraging}
                onDragEnd={onDragEnd}
                useStickyFixTop={useStickyFixTop}
                loading={loading}
                loadingOption={loadingOption}
                size={size}
                loadingText={locale.loadingText}
            />
        );
        const paginationPatchClass = (this.hasPagination() && data && data.length !== 0)
            ? `${prefixCls}-with-pagination` : `${prefixCls}-without-pagination`;
        const hasColumns = columns && columns.length;
        const clamps = {};
        if (cellLines) {
            clamps['--one-table-line-clamp'] = cellLines;
        }
        if (headCellLines) {
            clamps['--one-table-head-line-clamp'] = headCellLines;
        }
        return (
            <div
                className={classnames(`${prefixCls}-wrapper`, className, {
                    [`${prefixCls}-wrapper-no-header`]: !showHeader,
                    [`${prefixCls}-wrapper-no-columns`]: !hasColumns
                }, `${prefixCls}-wrapper-${type}`)}
                style={Object.keys(clamps).length ? {...clamps, ...style} : style}
                ref={this.root}
            >
                <div className={paginationPatchClass}>
                    {
                        hasColumns ? table : (
                            loading
                                ? (
                                    <Loading
                                        className={`${prefixCls}-loading-icon`}
                                        tip={locale.loadingText}
                                        size={size}
                                    >
                                        <div className={`${prefixCls}-no-columns`} />
                                    </Loading>
                                )
                                : <div className={`${prefixCls}-no-columns`} />
                        )
                    }
                    {this.renderPagination()}
                </div>
            </div>
        );
    }
}

export default Table;
