import React, {CSSProperties, PureComponent, useLayoutEffect, useState} from 'react';
import {connect} from 'mini-store';
import {findIndex} from 'lodash';
import ColGroup from './colGroup';
import TableHeader from './tableHeader';
import TableRow from './tableRow';
import ExpandableRow from './expandableRow';
import {
    formatTableWidthWithAllColumnsWidth,
    formatCellLeft
} from './utils';
import {TableColumnWidth} from '../interface';
import {InnerTableColumnProps} from './interface';
import {TableStore} from './table';
import Context from './context';
import classNames from 'classnames';

interface BaseTableProps {
    fixed: 'left' | 'right' | boolean,
    columns: InnerTableColumnProps[],
    tableClassName: string,
    hasHead: boolean,
    fixedHeader: boolean,
    hasBody: boolean,
    store: object,
    expander,
    getRowKey(record, index),
    isAnyColumnsFixed: boolean,
    dynamicWidth: number,
    allColumnsWidth: TableColumnWidth[],
    onDragStart(e: {inner: {showLine}}),
    onDraging(e: {curColumn, allColumns: TableColumnWidth[], inner: {dynamicWidth, curKeyLeft}}),
    onDragEnd(e: {inner: {showLine}}),
    onHeaderCellMouseEnter(e: {
        key,
        curKeyLeft,
        curColumn
    });
    onHeaderCellMouseLeave(e: {inner: {showLine}}),
};

const Empty = ({empty, containerWidth, prefixCls, loading, table}) => {
    const [width, setWidth] = useState(containerWidth);
    useLayoutEffect(() => {
        let handle;
        if (containerWidth === 0 && table.bodyTable) {
            handle = requestAnimationFrame(() => {
                handle = requestAnimationFrame(() => {
                    setWidth(table.bodyTable.offsetWidth || 'auto');
                });
            });
        }
        else {
            setWidth(containerWidth);
        }
        return () => cancelAnimationFrame(handle)
    }, [containerWidth]);
    return (
        <div
            className={
                classNames(`${prefixCls}-placeholder`, {
                    [`${prefixCls}-loading-tip`]: loading
                })
            }
            style={{width}}
        >
            {empty}
        </div>
    );
};

class BaseTable extends PureComponent<BaseTableProps> {

    static contextType = Context;

    renderRows = (renderData, indent, ancestorKeys = []) => {
        const table = this.context.table;
        const {columnManager} = table;
        const {
            prefixCls,
            childrenColumnName,
            rowClassName,
            rowRef,
            onRowClick,
            onRowDoubleClick,
            onRowContextMenu,
            onRowMouseEnter,
            onRowMouseLeave,
            onRow
        } = table.props;
        const {getRowKey, fixed, expander, isAnyColumnsFixed} = this.props;

        const rows = [];

        let leafColumns;
        if (fixed === 'left') {
            leafColumns = columnManager.leftLeafColumns();
        }
        else if (fixed === 'right') {
            leafColumns = columnManager.rightLeafColumns();
        }
        else {
            leafColumns = columnManager.leafColumns();
        }
        const columns = leafColumns.map(o => ({
            key: o.key,
            className: o.className,
            fixed: o.fixed,
            align: o.align,
            render: o.render,
            dataIndex: o.dataIndex,
            onCell: o.onCell,
            onCellClick: o.onCellClick
        }));
        const rowPrefixCls = `${prefixCls}-row`;

        for (let i = 0; i < renderData.length; i++) {
            const record = renderData[i];
            const key = getRowKey(record, i);
            const className = typeof rowClassName === 'string' ? rowClassName : rowClassName(record, i, indent);

            const row = (
                <ExpandableRow
                    {...expander.props}
                    fixed={fixed}
                    index={i}
                    prefixCls={rowPrefixCls}
                    record={record}
                    key={key}
                    rowKey={key}
                    onRowClick={onRowClick}
                    needIndentSpaced={expander.needIndentSpaced}
                    onExpandedChange={expander.handleExpandChange}
                    indent={indent}
                >
                    {expandableRow => (
                        <TableRow
                            fixed={fixed}
                            indent={indent}
                            className={className}
                            record={record}
                            index={i}
                            prefixCls={rowPrefixCls}
                            childrenColumnName={childrenColumnName}
                            columns={columns}
                            onRow={onRow}
                            onRowDoubleClick={onRowDoubleClick}
                            onRowContextMenu={onRowContextMenu}
                            onRowMouseEnter={onRowMouseEnter}
                            onRowMouseLeave={onRowMouseLeave}
                            rowKey={key}
                            ancestorKeys={ancestorKeys}
                            ref={rowRef(record, i, indent)}
                            isAnyColumnsFixed={isAnyColumnsFixed}
                            {...expandableRow}
                        />
                    )}
                </ExpandableRow>
            );

            rows.push(row);

            expander.renderRows(this.renderRows, rows, record, i, indent, fixed, key, ancestorKeys);
        }
        if (rows.length === 0) {
            rows.push(this.renderEmpty(leafColumns.length));
        }
        return rows;
    };

    renderEmpty = colSpan => {
        const table = this.context.table;
        const {
            props,
            containerWidth
        } = table;
        const {
            prefixCls,
            emptyText,
            loading,
            loadingOption,
            loadingText
        } = props;

        let empty;
        if (loading && (!loadingOption || loadingOption.type !== 'spinner')) {
            empty = loadingText;
        }
        else {
            empty = typeof emptyText === 'function' ? emptyText() : emptyText
        };
        return (
            <tr key="empty-row" className={`${prefixCls}-row-placeholder`}>
                <td colSpan={colSpan}>
                    <Empty
                        prefixCls={prefixCls}
                        loading={loading}
                        empty={empty}
                        containerWidth={containerWidth}
                        table={table}
                    />
                </td>
            </tr>
        );
    }

    onMoving = props => {
        const {allColumnsWidth, onDraging} = this.props;
        const columnsWidth = [...allColumnsWidth];
        let dynamicWidth = 0;
        const index = findIndex(columnsWidth, {key: props.key});
        const newObj = {
            ...columnsWidth[index],
            width: props.width,
            dragged: true
        };

        columnsWidth.splice(index, 1, newObj);
        let prevLeft = 0;
        let curKeyLeft = 0;
        const newAllColumnsWidth = columnsWidth.map(col => {
            prevLeft = formatCellLeft(col.width, prevLeft);
            dynamicWidth += col.width;
            if (col.key === props.key) {
                curKeyLeft = prevLeft;
            }
            return {
                ...col,
                left: prevLeft
            };
        });
        if (typeof onDraging === 'function') {
            onDraging({
                curColumn: {
                    ...props,
                    fixed: newObj.fixed
                },
                allColumns: newAllColumnsWidth,
                inner: {
                    dynamicWidth,
                    curKeyLeft
                }
            });
        }
    }

    onDragEnd = () => {
        const onDragEnd = this.props.onDragEnd;
        if (typeof onDragEnd === 'function') {
            onDragEnd({
                inner: {
                    showLine: false
                }
            });
        }
    }

    onDragStart = props => {
        const onDragStart = this.props.onDragStart;
        if (typeof onDragStart === 'function') {
            onDragStart({
                inner: {
                    showLine: true
                }
            });
        }
    }

    onHeaderCellMouseEnter = props => {
        const {allColumnsWidth, onHeaderCellMouseEnter} = this.props;
        if (typeof onHeaderCellMouseEnter === 'function') {
            const index = findIndex(allColumnsWidth, {key: props.key});
            let prevLeft = 0;
            let curKeyLeft = 0;
            allColumnsWidth.forEach(col => {
                prevLeft = formatCellLeft(col.width, prevLeft);
                if (col.key === props.key) {
                    curKeyLeft = prevLeft;
                }
            });
            onHeaderCellMouseEnter({
                key: props.key,
                curKeyLeft,
                curColumn: allColumnsWidth[index]
            });
        }
    }

    onHeaderCellMouseLeave = () => {
        const onHeaderCellMouseLeave = this.props.onHeaderCellMouseLeave;
        if (typeof onHeaderCellMouseLeave === 'function') {
            onHeaderCellMouseLeave({
                inner: {
                    showLine: false
                }
            });
        }
    }

    tableRef;

    getRef = ref => {
        this.tableRef = ref;
    }
    render() {
        const {table} = this.context;
        const {
            prefixCls,
            scroll,
            data,
            getBodyWrapper
        } = table.props;
        const {
            expander,
            tableClassName,
            hasHead,
            hasBody,
            fixed,
            columns,
            dynamicWidth,
            allColumnsWidth,
            fixedHeader
        } = this.props;
        const tableStyle: CSSProperties = {};

        if (!fixed && scroll.x) {
            tableStyle.tableLayout = 'fixed';
        }
        tableStyle.width = dynamicWidth
            || (scroll && scroll.x)
            || formatTableWidthWithAllColumnsWidth(allColumnsWidth)
            || '100%';

        let body;
        if (hasBody) {
            body = (
                <tbody className={`${prefixCls}-tbody`}>
                    {this.renderRows(data, 0)}
                </tbody>
            );
            if (getBodyWrapper) {
                body = getBodyWrapper(body);
            }
        }
        return (
            [
                <table className={tableClassName} style={tableStyle} key="table" ref={this.getRef}>
                    <ColGroup columns={columns} fixed={fixed} />
                    {hasHead
                        && <TableHeader
                            expander={expander}
                            columns={columns}
                            fixed={fixed}
                            fixedHeader={fixedHeader}
                            onMoving={this.onMoving}
                            onDragEnd={this.onDragEnd}
                            onDragStart={this.onDragStart}
                            onHeaderCellMouseEnter={this.onHeaderCellMouseEnter}
                            onHeaderCellMouseLeave={this.onHeaderCellMouseLeave}
                        />
                    }
                    {body}
                </table>
            ]
        );
    }

    componentDidUpdate() {
        if (!this.props.hasBody) {
            return;
        }
        const trackBodyUpdate = this.context.table.props.trackBodyUpdate;
        if (trackBodyUpdate) {
            trackBodyUpdate();
        }
    }
}

export default connect((state: TableStore) => {
    return {
        allColumnsWidth: state.allColumnsWidth,
        dynamicWidth: state.dynamicWidth
    };
})(BaseTable);
