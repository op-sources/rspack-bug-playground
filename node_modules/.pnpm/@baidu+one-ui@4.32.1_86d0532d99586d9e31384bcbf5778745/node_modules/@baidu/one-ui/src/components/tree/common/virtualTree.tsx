import React from 'react';
import {FixedSizeList} from 'react-window';
import {classnames} from '../../../core/commonTools';
import warning from 'warning';
import toArray from '../../../core/childrenTools';
import {
    flattenTreeData,
    convertDataToTree
} from './utils';
import {
    convertTreeToEntities,
    getDataAndAria,
    getPosition,
    parseCheckedKeys,
    conductExpandParent, calcSelectedKeys,
    arrAdd, arrDel, conductCheck,
    warnOnlyTreeNode
} from '../../../core/treeTools';
import {TreeNodeCheckInfo, TreeNodeSelectInfo, TreeProps} from '../interface';
import Context from './context';

interface TreeState {
    keyEntities?: {},

    selectedKeys?: string[],
    checkedKeys?: string[],
    halfCheckedKeys?: string[],
    loadedKeys?: string[],
    loadingKeys?: string[],

    expandedKeys?: string[],

    treeNode?: [],
    prevProps?: TreeProps
    flattenNodes?;
}

class VirtualTree extends React.Component<TreeProps, TreeState> {

    static defaultProps = {
        prefixCls: 'one-tree',
        showLine: false,
        showIcon: true,
        selectable: true,
        multiple: false,
        checkable: false,
        disabled: false,
        checkStrictly: false,
        draggable: false,
        defaultExpandParent: true,
        autoExpandParent: false,
        defaultExpandAll: false,
        defaultExpandedKeys: [],
        defaultCheckedKeys: [],
        defaultSelectedKeys: [],
        checkActionEqualSelet: false,
        size: 'medium',
        onScroll: () => {}
    };

    state: TreeState = {
        keyEntities: {},

        selectedKeys: [],
        checkedKeys: [],
        halfCheckedKeys: [],
        loadedKeys: [],
        loadingKeys: [],

        treeNode: [],
        flattenNodes: []
    };

    getContext() {
        const {
            prefixCls,
            selectable,
            showIcon,
            icon,
            checkable,
            checkStrictly,
            disabled,
            loadData, filterTreeNode,
            switcherIcon
        } = this.props;

        return {
            rcTree: {
                // root: this,

                prefixCls,
                selectable,
                showIcon,
                icon,
                switcherIcon,
                checkable,
                checkStrictly,
                disabled,

                loadData,
                filterTreeNode,
                renderTreeNode: this.renderTreeNode,
                isKeyChecked: this.isKeyChecked,

                onNodeClick: this.onNodeClick,
                onNodeDoubleClick: this.onNodeDoubleClick,
                onNodeExpand: this.onNodeExpand,
                onNodeSelect: this.onNodeSelect,
                onNodeCheck: this.onNodeCheck,
                onNodeLoad: this.onNodeLoad,
                onNodeMouseEnter: this.onNodeMouseEnter,
                onNodeMouseLeave: this.onNodeMouseLeave,
                onNodeContextMenu: this.onNodeContextMenu
            }
        };
    }

    static getDerivedStateFromProps(props, prevState) {
        const {prevProps} = prevState;
        const newState: TreeState = {
            prevProps: props
        };

        function needSync(name) {
            return (!prevProps && name in props) || (prevProps && prevProps[name] !== props[name]);
        }

        // ================== Tree Node ==================
        let treeNode = null;

        if (needSync('treeData')) {
            treeNode = convertDataToTree(props.treeData);
        }
        else if (needSync('children')) {
            treeNode = toArray(props.children);
        }

        // Tree support filter function which will break the tree structure in the vdm.
        // We cache the treeNodes in state so that we can return the treeNode in event trigger.
        if (treeNode) {
            newState.treeNode = treeNode;

            // Calculate the entities data for quick match
            const entitiesMap = convertTreeToEntities(treeNode);
            newState.keyEntities = entitiesMap.keyEntities;
        }

        const keyEntities = newState.keyEntities || prevState.keyEntities;

        // ================ expandedKeys =================
        if (needSync('expandedKeys') || (prevProps && needSync('autoExpandParent'))) {
            newState.expandedKeys = (props.autoExpandParent || (!prevProps && props.defaultExpandParent))
                ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
        }
        else if (!prevProps && props.defaultExpandAll) {
            newState.expandedKeys = Object.keys(keyEntities);
        }
        else if (!prevProps && props.defaultExpandedKeys) {
            newState.expandedKeys = (props.autoExpandParent || props.defaultExpandParent)
                ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
        }

        if (!newState.expandedKeys) {
            delete newState.expandedKeys;
        }

        // ================ flattenNodes =================
        if (treeNode || newState.expandedKeys) {
            const flattenNodes = flattenTreeData(
                treeNode,
                newState.expandedKeys || prevState.expandedKeys,
            );
            newState.flattenNodes = flattenNodes;
        }

        // ================ selectedKeys =================
        if (props.selectable) {
            if (needSync('selectedKeys')) {
                newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
            }
            else if (!prevProps && props.defaultSelectedKeys) {
                newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
            }
        }

        // ================= checkedKeys =================
        if (props.checkable) {
            let checkedKeyEntity;

            if (needSync('checkedKeys')) {
                checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
            }
            else if (!prevProps && props.defaultCheckedKeys) {
                checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
            }
            else if (treeNode) {
                // If treeNode changed, we also need check it
                checkedKeyEntity = {
                    checkedKeys: prevState.checkedKeys,
                    halfCheckedKeys: prevState.halfCheckedKeys
                };
            }

            if (checkedKeyEntity) {
                let {checkedKeys = [], halfCheckedKeys = []} = checkedKeyEntity;

                if (!props.checkStrictly) {
                    const conductKeys = conductCheck(checkedKeys, true, keyEntities);
                    checkedKeys = conductKeys.checkedKeys;
                    halfCheckedKeys = conductKeys.halfCheckedKeys;
                }

                newState.checkedKeys = checkedKeys;
                newState.halfCheckedKeys = halfCheckedKeys;
            }
        }
        // ================= loadedKeys ==================
        if (needSync('loadedKeys')) {
            newState.loadedKeys = props.loadedKeys;
        }

        return newState;
    }

    onNodeClick = (e, treeNode) => {
        const {onClick} = this.props;
        if (onClick) {
            onClick(e, treeNode);
        }
    };

    onNodeDoubleClick = (e, treeNode) => {
        const {onDoubleClick} = this.props;
        if (onDoubleClick) {
            onDoubleClick(e, treeNode);
        }
    };

    onNodeSelect = (e, treeNode) => {
        let {selectedKeys} = this.state;
        const {keyEntities} = this.state;
        const {onSelect, multiple, checkActionEqualSelet, loadData} = this.props;
        const {selected, eventKey, isLeaf} = treeNode.props;
        const targetSelected = !selected;

        // Update selected keys
        if (!targetSelected) {
            selectedKeys = arrDel(selectedKeys, eventKey);
        }
        else if (!multiple) {
            selectedKeys = [eventKey];
        }
        else {
            selectedKeys = arrAdd(selectedKeys, eventKey);
        }

        // [Legacy] Not found related usage in doc or upper libs
        const selectedNodes = selectedKeys.map(key => {
            const entity = keyEntities[key];
            if (!entity) {
                return null;
            };

            return entity.node;
        }).filter(node => node);

        this.setUncontrolledState({selectedKeys});

        if (onSelect) {
            const eventObj: TreeNodeSelectInfo = {
                event: 'select',
                selected: targetSelected,
                node: treeNode,
                selectedNodes,
                nativeEvent: e.nativeEvent,
                keyEntities: keyEntities,
                eventKey
            };
            if (checkActionEqualSelet) {
                const {keyEntities, checkedKeys: oriCheckedKeys, halfCheckedKeys: oriHalfCheckedKeys} = this.state;
                const {checkedKeys, halfCheckedKeys} = conductCheck([eventKey], targetSelected, keyEntities, {
                    checkedKeys: oriCheckedKeys, halfCheckedKeys: oriHalfCheckedKeys
                });
                eventObj.checkedKeys = checkedKeys;
                eventObj.halfCheckedKeys = halfCheckedKeys;
            }
            onSelect(selectedKeys, eventObj);
        }

        if (loadData && isLeaf !== true) {
            this.onNodeLoad(treeNode, 'select');
        }
    };

    onNodeCheck = (e, treeNode, checked) => {
        const {keyEntities, checkedKeys: oriCheckedKeys, halfCheckedKeys: oriHalfCheckedKeys} = this.state;
        const {checkStrictly, onCheck, loadData} = this.props;
        const {props: {eventKey, isLeaf}} = treeNode;

        // Prepare trigger arguments
        let checkedObj;
        const eventObj: TreeNodeCheckInfo = {
            event: 'check',
            node: treeNode,
            checked,
            nativeEvent: e.nativeEvent,
            keyEntities: keyEntities,
            eventKey
        };

        if (checkStrictly) {
            const checkedKeys = checked ? arrAdd(oriCheckedKeys, eventKey) : arrDel(oriCheckedKeys, eventKey);
            const halfCheckedKeys = arrDel(oriHalfCheckedKeys, eventKey);
            checkedObj = {checked: checkedKeys, halfChecked: halfCheckedKeys};

            eventObj.checkedNodes = checkedKeys
                .map(key => keyEntities[key])
                .filter(entity => entity)
                .map(entity => entity.node);

            this.setUncontrolledState({checkedKeys});
        }
        else {
            const {checkedKeys, halfCheckedKeys} = conductCheck([eventKey], checked, keyEntities, {
                checkedKeys: oriCheckedKeys, halfCheckedKeys: oriHalfCheckedKeys
            });

            checkedObj = checkedKeys;

            // [Legacy] This is used for `rc-tree-select`
            eventObj.checkedNodes = [];
            eventObj.checkedNodesPositions = [];
            eventObj.halfCheckedKeys = halfCheckedKeys;

            checkedKeys.forEach(key => {
                const entity = keyEntities[key];
                if (!entity) {
                    return;
                };

                const {node, pos} = entity;

                eventObj.checkedNodes.push(node);
                eventObj.checkedNodesPositions.push({node, pos});
            });

            this.setUncontrolledState({
                checkedKeys,
                halfCheckedKeys
            });
        }

        if (onCheck) {
            onCheck(checkedObj, eventObj);
        }

        if (loadData && isLeaf !== true) {
            this.onNodeLoad(treeNode, 'check');
        }
    };

    onNodeLoad = (treeNode, eventType) => (
        new Promise(resolve => {
            // We need to get the latest state of loading/loaded keys
            this.setState(({loadedKeys = [], loadingKeys = []}) => {
                const {loadData, onLoad} = this.props;
                const {eventKey} = treeNode.props;

                if (!loadData
                    || loadedKeys.indexOf(eventKey) !== -1
                    || loadingKeys.indexOf(eventKey) !== -1
                ) {
                    // react 15 will warn if return null
                    return {};
                }

                // Process load data
                const promise = loadData(treeNode, eventKey, eventType);
                promise.then(() => {
                    const newLoadedKeys = arrAdd(this.state.loadedKeys, eventKey);
                    const newLoadingKeys = arrDel(this.state.loadingKeys, eventKey);

                    // onLoad should trigger before internal setState to avoid `loadData` trigger twice.
                    // https://github.com/ant-design/ant-design/issues/12464
                    if (onLoad) {
                        const eventObj = {
                            event: 'load',
                            node: treeNode
                        };
                        onLoad(newLoadedKeys, eventObj);
                    }

                    this.setUncontrolledState({
                        loadedKeys: newLoadedKeys
                    });
                    this.setState({
                        loadingKeys: newLoadingKeys
                    });

                    resolve(true);
                });

                return {
                    loadingKeys: arrAdd(loadingKeys, eventKey)
                };
            });
        })
    );

    onNodeExpand = (e, treeNode) => {
        let {expandedKeys} = this.state;
        const {onExpand, loadData} = this.props;
        const {eventKey, expanded} = treeNode.props;

        // Update selected keys
        const index = expandedKeys.indexOf(eventKey);
        const targetExpanded = !expanded;

        warning(
            (expanded && index !== -1) || (!expanded && index === -1),
            'Expand state not sync with index check',
        );

        if (targetExpanded) {
            expandedKeys = arrAdd(expandedKeys, eventKey);
        }
        else {
            expandedKeys = arrDel(expandedKeys, eventKey);
        }
        const flattenNodes = flattenTreeData(this.state.treeNode, expandedKeys);
        this.setUncontrolledState({
            expandedKeys,
            flattenNodes
        });

        if (onExpand) {
            onExpand(expandedKeys, {
                node: treeNode,
                expanded: targetExpanded,
                nativeEvent: e.nativeEvent
            });
        }

        // Async Load data
        if (targetExpanded && loadData) {
            const loadPromise = this.onNodeLoad(treeNode, 'expand');
            return loadPromise ? loadPromise.then(() => {
                // [Legacy] Refresh logic
                this.setUncontrolledState({expandedKeys});
            }) : null;
        }

        return null;
    };

    onNodeMouseEnter = (event, node) => {
        const {onMouseEnter} = this.props;
        if (onMouseEnter) {
            onMouseEnter({event, node});
        }
    };

    onNodeMouseLeave = (event, node) => {
        const {onMouseLeave} = this.props;
        if (onMouseLeave) {
            onMouseLeave({event, node});
        }
    };

    onNodeContextMenu = (event, node) => {
        const {onRightClick} = this.props;
        if (onRightClick) {
            event.preventDefault();
            onRightClick({event, node});
        }
    };

    /**
     * Only update the value which is not in props
     */
    setUncontrolledState = state => {
        let needSync = false;
        const newState = {};

        Object.keys(state).forEach(name => {
            if (name in this.props) {
                return;
            }

            needSync = true;
            newState[name] = state[name];
        });

        if (needSync) {
            this.setState(newState);
        }
    };

    isKeyChecked = key => {
        const {checkedKeys = []} = this.state;
        return checkedKeys.indexOf(key) !== -1;
    };

    /**
     * [Legacy] Original logic use `key` as tracking clue.
     * We have to use `cloneElement` to pass `key`.
     */
    renderTreeNode = (child, index, level = 0) => {
        const {
            keyEntities,
            expandedKeys = [],
            selectedKeys = [],
            halfCheckedKeys = [],
            loadedKeys = [],
            loadingKeys = []
        } = this.state;
        const pos = getPosition(level, index);
        const key = child.key || pos;

        if (!keyEntities[key]) {
            warnOnlyTreeNode();
            return null;
        }

        return React.cloneElement(child, {
            key,
            eventKey: key,
            expanded: expandedKeys.indexOf(key) !== -1,
            selected: selectedKeys.indexOf(key) !== -1,
            loaded: loadedKeys.indexOf(key) !== -1,
            loading: loadingKeys.indexOf(key) !== -1,
            checked: this.isKeyChecked(key),
            halfChecked: halfCheckedKeys.indexOf(key) !== -1,
            pos,
            level: child.level
        });
    };

    renderNode = ({index, style}) => {
        const flattenNodes = this.state.flattenNodes;
        return (
            <div className={`${this.props.prefixCls}-list-item`} style={style}>
                {this.renderTreeNode(flattenNodes[index], index)}
            </div>
        );
    }

    render() {
        const {
            prefixCls,
            className,
            size,
            parentContainerHeight,
            treeNodeHeight,
            onScroll,
            style
        } = this.props;

        const domProps = getDataAndAria(this.props);

        const flattenNodes = this.state.flattenNodes;
        return (
            <Context.Provider value={this.getContext()}>
                <ul
                    {...domProps}
                    className={classnames(prefixCls, `${prefixCls}-virtual-tree`, className)}
                    style={style}
                    role="tree"
                    unselectable="on"
                >
                    <FixedSizeList
                        className={`${prefixCls}-list`}
                        height={parentContainerHeight}
                        itemCount={flattenNodes.length}
                        itemData={this.state}
                        itemSize={treeNodeHeight || (size === 'small' ? 28 : 32)}
                        onScroll={onScroll}
                    >
                        {
                            this.renderNode
                        }
                    </FixedSizeList>
                </ul>
            </Context.Provider>
        );
    }
}

export default VirtualTree;
