import {
    formatNormalWidth,
    formatCellLeft,
    formatCellWidth
} from './utils';

export default class ColumnManager {
    _cached = {};

    columns;

    constructor(columns) {
        this.columns = columns;
    }

    isAnyColumnsFixed() {
        return this._cache('isAnyColumnsFixed', () => {
            return this.columns.some(column => !!column.fixed);
        });
    }

    isAnyColumnsLeftFixed() {
        return this._cache('isAnyColumnsLeftFixed', () => {
            return this.columns.some(column => column.fixed === 'left' || column.fixed === true);
        });
    }

    isAnyColumnsRightFixed() {
        return this._cache('isAnyColumnsRightFixed', () => {
            return this.columns.some(column => column.fixed === 'right');
        });
    }

    leftColumns() {
        return this._cache('leftColumns', () => {
            return this.groupedColumns().filter(
                column => column.fixed === 'left' || column.fixed === true,
            );
        });
    }

    rightColumns() {
        return this._cache('rightColumns', () => {
            return this.groupedColumns().filter(column => column.fixed === 'right');
        });
    }

    leafColumns() {
        return this._cache('leafColumns', () => this._leafColumns(this.columns));
    }

    leftLeafColumns() {
        return this._cache('leftLeafColumns', () => this._leafColumns(this.leftColumns()));
    }

    rightLeafColumns() {
        return this._cache('rightLeafColumns', () => this._leafColumns(this.rightColumns()));
    }

    allColumnsWidth(tableWidth, refresh = false) {
        const leafColumns = this.leafColumns();
        const fixedWidthColumns = leafColumns.filter(col => col.fixedWidth);
        const fixedWidth = fixedWidthColumns.reduce((width, col) => col.width + width, 0);
        const tableCalcWidth = tableWidth - fixedWidth;
        const normalWidth = formatNormalWidth(tableWidth, leafColumns);
        let curWidth = 0;
        return this._cache('columnsWidth', () => {
            return leafColumns.map(
                column => {
                    const key = column.key || column.dataIndex;
                    const width = column.fixedWidth
                        ? column.width
                        : formatCellWidth((column.width || normalWidth), tableCalcWidth);
                    const minWidth = column.fixedWidth
                        ? column.width
                        : formatCellWidth((column.minWidth || column.width || normalWidth), tableCalcWidth);
                    const maxWidth = column.fixedWidth
                        ? column.width
                        : formatCellWidth(column.maxWidth, tableCalcWidth) || null;
                    curWidth = formatCellLeft(width, curWidth, tableCalcWidth);
                    return {
                        key,
                        width,
                        minWidth,
                        maxWidth,
                        left: curWidth,
                        fixed: column.fixed,
                        fixedWidth: column.fixedWidth
                    };
                }
            );
        }, refresh);
    }

    // add appropriate rowspan and colspan to column
    groupedColumns() {
        return this._cache('groupedColumns', () => {
            const getGroupColumns = (columns, currentRow = 0, parentColumn = {colSpan: 0}, rows = []) => {
                // track how many rows we got
                rows[currentRow] = rows[currentRow] || [];
                const grouped = [];
                const setRowSpan = column => {
                    const rowSpan = rows.length - currentRow;
                    if (column && !column.children && rowSpan > 1 && (!column.rowSpan || column.rowSpan < rowSpan)) {
                        column.rowSpan = rowSpan;
                    }
                };
                columns.forEach((column, index) => {
                    const newColumn = {...column};
                    rows[currentRow].push(newColumn);
                    parentColumn.colSpan = parentColumn.colSpan || 0;
                    if (newColumn.children && newColumn.children.length > 0) {
                        newColumn.children = getGroupColumns(newColumn.children, currentRow + 1, newColumn, rows);
                        parentColumn.colSpan += newColumn.colSpan;
                    }
                    else {
                        parentColumn.colSpan++;
                    }
                    // update rowspan to all same row columns
                    for (let i = 0; i < rows[currentRow].length - 1; ++i) {
                        setRowSpan(rows[currentRow][i]);
                    }
                    // last column, update rowspan immediately
                    if (index + 1 === columns.length) {
                        setRowSpan(newColumn);
                    }
                    grouped.push(newColumn);
                });
                return grouped;
            };
            return getGroupColumns(this.columns);
        });
    }

    reset(columns) {
        this.columns = columns;
        this._cached = {};
    }

    _cache(name, fn, refresh?) {
        if (name in this._cached && !refresh) {
            return this._cached[name];
        }
        this._cached[name] = fn();
        return this._cached[name];
    }

    _leafColumns(columns) {
        const leafColumns = [];
        columns.forEach(column => {
            if (!column.children) {
                leafColumns.push(column);
            }
            else {
                leafColumns.push(...this._leafColumns(column.children));
            }
        });
        return leafColumns;
    }
}
