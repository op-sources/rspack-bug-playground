import React, {Component, forwardRef} from 'react';
import ReactDOM from 'react-dom';
import AsyncValidator from 'async-validator';
import scrollIntoView from 'dom-scroll-into-view';
import {get, set, isEqual, has, map} from 'lodash';
import createFieldsStore, {FieldsStore} from './createFieldsStore';
import {
    identity,
    normalizeValidateRules,
    getValidateTriggers,
    getValueFromEvent,
    hasRules,
    getParams,
    isEmptyObject,
    flattenArray
} from '../../../core/formTools';
import {FormField, FormOption, FormProps} from '../interface';
import {FIELD_META_PROP, FIELD_DATA_PROP} from '../formItem';
import shallowEqual from 'shallowequal';
import {LegacyFormContext, FormContext} from '../context';
import {getScrollableContainer} from '../../../util/dom';

const DEFAULT_TRIGGER = 'onChange';

export interface FormState {
    fieldsStore: FieldsStore;
    submitting: boolean;
    formValidating: boolean;
    prevProps: FormProps;
    mapPropsToFields: (props: FormProps) => {
        [key: string]: FormField;
    }
};

export class BaseForm extends Component<FormProps, FormState> {
    static defaultProps = {
        mapProps: identity,
        formPropName: 'form',
        size: 'medium',
        fieldNameProp: 'id'
    };

    static contextType = FormContext;

    constructor(props) {
        super(props);
        const mapPropsToFields = this.props.mapPropsToFields;
        const fields = mapPropsToFields && mapPropsToFields(this.props);
        this.fieldsStore = createFieldsStore(fields || {});
        this.instances = {};
        this.cachedBind = {};
        this.clearedFieldMetaCache = {};
        this.renderFields = {};
        this.domFields = {};
        [
            'getFieldsValue',
            'getFieldValue',
            'setFieldsInitialValue',
            'getFieldsError',
            'getFieldError',
            'getFieldsWarning',
            'getFieldWarning',
            'getFieldsSuccess',
            'getFieldSuccess',
            'isFieldValidating',
            'isFieldsValidating',
            'isFieldsTouched',
            'isFieldTouched']
            .forEach(key => {
                this[key] = (...args) => {
                    return this.fieldsStore[key](...args);
                };
            });
        this.state = {
            submitting: false,
            formValidating: false,
            fieldsStore: this.fieldsStore,
            mapPropsToFields,
            prevProps: props
        };
        this.form = this.getForm();
    }

    form;
    fieldsStore;
    renderFields;
    domFields;
    clearedFieldMetaCache;
    instances;
    cachedBind;

    componentDidMount() {
        this.cleanUpUselessFields();
    }

    static getDerivedStateFromProps(props, state) {
        const {
            mapPropsToFields,
            fieldsStore,
            prevProps
        } = state;
        if (mapPropsToFields && !shallowEqual(props, prevProps)) {
            fieldsStore.updateFields(mapPropsToFields(props));
        }
        return {
            prevProps: props
        };
    }

    componentDidUpdate() {
        this.cleanUpUselessFields();
    }

    cleanUpUselessFields() {
        const fieldList = this.fieldsStore.getAllFieldsName();
        const removedList = fieldList.filter(field => {
            const fieldMeta = this.fieldsStore.getFieldMeta(field);
            return (!this.renderFields[field] && !this.domFields[field] && !fieldMeta.preserve);
        });
        if (removedList.length) {
            removedList.forEach(this.clearField);
        }
        this.renderFields = {};
    }

    onCollectCommon(name, action, args) {
        const fieldMeta = this.fieldsStore.getFieldMeta(name);
        if (fieldMeta[action]) {
            fieldMeta[action](...args);
        } else if (fieldMeta.originalProps && fieldMeta.originalProps[action]) {
            fieldMeta.originalProps[action](...args);
        }
        const value = fieldMeta.getValueFromEvent ? fieldMeta.getValueFromEvent(...args)
            : getValueFromEvent(...args);
        const {
            onValuesChange,
            formPropName
        } = this.props;
        if (onValuesChange && value !== this.fieldsStore.getFieldValue(name)) {
            const valuesAll = this.fieldsStore.getAllValues();
            const valuesAllSet = {};
            valuesAll[name] = value;
            Object.keys(valuesAll).forEach(key => set(valuesAllSet, key, valuesAll[key]));
            onValuesChange({
                [formPropName]: this.form,
                ...this.props
            }, set({}, name, value), valuesAllSet);
        }
        const field = this.fieldsStore.getField(name);
        return ({name, field: {...field, value, touched: true}, fieldMeta});
    }

    onCollect(nameCurrent, action, ...args) {
        const {name, field, fieldMeta} = this.onCollectCommon(nameCurrent, action, args);
        const validate = fieldMeta.validate;
        this.fieldsStore.setFieldsAsDirty();
        const newField = {
            ...field,
            dirty: hasRules(validate)
        };
        this.setFields({
            [name]: newField
        });
    }

    onCollectValidate(nameCurrent, action, ...args) {
        const {field, fieldMeta} = this.onCollectCommon(nameCurrent, action, args);
        const newField = {
            ...field,
            dirty: true
        };
        this.fieldsStore.setFieldsAsDirty();
        this.validateFieldsInternal([newField], {
            action,
            options: {
                firstFields: !!fieldMeta.validateFirst
            }
        });
    }

    getCacheBind(name, action, fn) {
        if (!this.cachedBind[name]) {
            this.cachedBind[name] = {};
        }
        const cache = this.cachedBind[name];
        if (!cache[action] || cache[action].oriFn !== fn) {
            cache[action] = {
                fn: fn.bind(this, name, action),
                oriFn: fn
            };
        }
        return cache[action].fn;
    }

    getFieldDecorator = (name, fieldOption) => {
        const props = this.getFieldProps(name, fieldOption);
        return fieldElem => {
            this.renderFields[name] = true;
            const fieldMeta = this.fieldsStore.getFieldMeta(name);
            const originalProps = fieldElem.props;
            fieldMeta.originalProps = originalProps;
            fieldMeta.ref = fieldElem.ref;
            return React.cloneElement(fieldElem, {
                size: originalProps.size || this.props.size,
                ...props,
                ...this.fieldsStore.getFieldValuePropValue(fieldMeta)
            });
        };
    }

    getFieldProps = (name, usersFieldOption) => {
        if (!name) {
            throw new Error('Must call `getFieldProps` with valid name string!');
        }
        delete this.clearedFieldMetaCache[name];
        const fieldOption = {
            name,
            trigger: DEFAULT_TRIGGER,
            valuePropName: 'value',
            validate: [],
            ...usersFieldOption
        };
        const {
            rules,
            trigger,
            validateTrigger = trigger,
            validate
        } = fieldOption;
        const fieldMeta = this.fieldsStore.getFieldMeta(name);
        if ('initialValue' in fieldOption) {
            fieldMeta.initialValue = fieldOption.initialValue;
        }
        const inputProps = {
            ...this.fieldsStore.getFieldValuePropValue(fieldOption),
            ref: this.getCacheBind(name, `${name}__ref`, this.saveRef)
        };
        const {
            fieldNameProp,
            name: formName
        } = this.props;
        if (fieldNameProp) {
            inputProps[fieldNameProp] = formName ? `${formName}_${name}` : name;
        }
        const validateRules = normalizeValidateRules(validate, rules, validateTrigger);
        const validateTriggers = getValidateTriggers(validateRules);
        validateTriggers.forEach(action => {
            if (inputProps[action]) {
                return;
            }
            inputProps[action] = this.getCacheBind(name, action, this.onCollectValidate);
        });
        // make sure that the value will be collect
        if (trigger && validateTriggers.indexOf(trigger) === -1) {
            inputProps[trigger] = this.getCacheBind(name, trigger, this.onCollect);
        }
        const meta = {
            ...fieldMeta,
            ...fieldOption,
            validate: validateRules
        };
        this.fieldsStore.setFieldMeta(name, meta);

        inputProps[FIELD_META_PROP] = meta;
        inputProps[FIELD_DATA_PROP] = this.fieldsStore.getField(name);

        // This field is rendered, record it
        this.renderFields[name] = true;
        return inputProps;
    }

    getFieldInstance = (name) => {
        return this.instances[name];
    }

    getRules(fieldMeta, action) {
        const actionRules = fieldMeta.validate.filter(item => {
            return !action || item.trigger.indexOf(action) >= 0;
        }).map(item => item.rules);
        return flattenArray(actionRules);
    }

    setFields = (maybeNestedFields, callback?) => {
        const fields = this.fieldsStore.flattenRegisteredFields(maybeNestedFields);
        this.fieldsStore.setFields(fields);
        const {
            onFieldsChange,
            formPropName
        } = this.props;
        if (onFieldsChange) {
            const changedFields = Object.keys(fields)
                .reduce((acc, name) => set(acc, name, this.fieldsStore.getField(name)), {});
            onFieldsChange({
                [formPropName]: this.form,
                ...this.props
            }, changedFields, this.fieldsStore.getNestedAllFields());
        }
        this.forceUpdate(callback);
    }

    setFieldsValue = (changedValues, callback) => {
        const fieldsMeta = this.fieldsStore.fieldsMeta;
        const values = this.fieldsStore.flattenRegisteredFields(changedValues);
        const newFields = Object.keys(values).reduce((acc, name) => {
            const isRegistered = fieldsMeta[name];
            if (isRegistered) {
                const value = values[name];
                acc[name] = {
                    value
                };
            }
            return acc;
        }, {});
        this.setFields(newFields, callback);
        const {
            onValuesChange,
            formPropName
        } = this.props;
        if (onValuesChange) {
            const allValues = this.fieldsStore.getAllValues();
            onValuesChange({
                [formPropName]: this.form,
                ...this.props
            }, changedValues, allValues);
        }
    }

    setFieldsError = (errors, callback) => {
        const fieldsMeta = this.fieldsStore.fieldsMeta;
        const fieldsError = this.fieldsStore.flattenRegisteredFields(errors);
        const newFields = Object.keys(fieldsError).reduce((fields, name) => {
            const isRegistered = fieldsMeta[name];
            if (isRegistered) {
                const errors = fieldsError[name];
                fields[name] = {
                    ...this.fieldsStore.getField(name),
                    errors
                };
            }
            return fields;
        }, {});
        this.setFields(newFields, callback);
    }

    saveRef(name, _, component) {
        if (!component) {
            const fieldMeta = this.fieldsStore.getFieldMeta(name);
            if (!fieldMeta.preserve) {
                // after destroy, delete data
                this.clearedFieldMetaCache[name] = {
                    field: this.fieldsStore.getField(name),
                    meta: fieldMeta
                };
                this.clearField(name);
            }
            delete this.domFields[name];
            return;
        }
        this.domFields[name] = true;
        this.recoverClearedField(name);
        const fieldMeta = this.fieldsStore.getFieldMeta(name);
        if (fieldMeta) {
            const ref = fieldMeta.ref;
            if (ref) {
                if (typeof ref === 'string') {
                    throw new Error(`can not set ref string for ${name}`);
                } else if (typeof ref === 'function') {
                    ref(component);
                } else if (Object.prototype.hasOwnProperty.call(ref, 'current')) {
                    ref.current = component;
                }
            }
        }
        this.instances[name] = component;
    }

    clearField = (name) => {
        this.fieldsStore.clearField(name);
        delete this.instances[name];
        delete this.cachedBind[name];
    }

    resetFields = (ns?) => {
        const newFields = this.fieldsStore.resetFields(ns);
        if (Object.keys(newFields).length > 0) {
            this.setFields(newFields);
        }
        if (ns) {
            const names = Array.isArray(ns) ? ns : [ns];
            names.forEach(name => delete this.clearedFieldMetaCache[name]);
        } else {
            this.clearedFieldMetaCache = {};
        }
    }

    recoverClearedField(name) {
        if (this.clearedFieldMetaCache[name]) {
            this.fieldsStore.setFields({
                [name]: this.clearedFieldMetaCache[name].field
            });
            this.fieldsStore.setFieldMeta(name, this.clearedFieldMetaCache[name].meta);
            delete this.clearedFieldMetaCache[name];
        }
    }

    getAsyncValidator(rule, value, options) {
        const validator = new AsyncValidator(rule);
        const validateMessages = this.props.validateMessages;
        if (validateMessages) {
            // @ts-ignore
            validator.messages(validateMessages);
        }
        return validator.validate(value, options);
    }

    mixValidateFields(rules, values, options) {
        let errors = [];
        let warnings = [];
        let successes = [];
        return Promise.all(map(values, (value, key) => {
            const fieldRules = rules[key];
            const errorRules = fieldRules.filter(rule => !rule.asyncValidator && rule.invalidType !== 'warning');
            const warningRules = fieldRules.filter(rule => !rule.asyncValidator && rule.invalidType === 'warning');
            const asyncRules = fieldRules.filter(rule => !!rule.asyncValidator);
            const fieldValue = {[key]: value};

            return this.getAsyncValidator({[key]: errorRules}, fieldValue, options) // errors
                .then(() => {
                    // warnings
                    return this.getAsyncValidator({[key]: warningRules}, fieldValue, options).catch(err => {
                        const errors = err.errors || {field: key, message: String(err)};
                        warnings = warnings.concat(errors);
                    });
                })
                .then(() => {
                    // async
                    return this.getAsyncValidator({[key]: asyncRules}, fieldValue, options);
                })
                .then(() => {
                    // success message
                    const success = fieldRules
                        .filter(rule => rule.successMessage)
                        .map(rule => ({field: key, message: rule.successMessage}));
                    if  (success.length) {
                        successes = successes.concat(success);
                    }
                })
                .catch(err => {
                    const errs = err.errors || {field: key, message: String(err)};
                    errors = errors.concat(errs);
                });
        })).then(() => ({errors, warnings, successes}));
    }

    validateFieldsInternal(fields: FormField[], fieldOptions, callback?) {
        const {
            fieldNames,
            action,
            options = {}
        } = fieldOptions;
        const allRules = {};
        const allValues = {};
        const allFields = {};
        const alreadyErrors = {};
        const alreadyWarnings = {};
        const alreadySuccesses = {};
        fields.forEach(field => {
            const {
                name,
                dirty,
                errors,
                warnings,
                successes,
                value
            } = field;
            if (options.force !== true && dirty === false) {
                if (errors && errors.length) {
                    set(alreadyErrors, name, {errors});
                }
                if (warnings && warnings.length) {
                    set(alreadyWarnings, name, {warnings});
                }
                if (successes && successes.length) {
                    set(alreadySuccesses, name, {successes});
                }
                return;
            }
            const fieldMeta = this.fieldsStore.getFieldMeta(name);
            allRules[name] = this.getRules(fieldMeta, action);
            allValues[name] = value;
            allFields[name] = {
                ...field,
                errors: undefined,
                warnings: undefined,
                successes: undefined,
                validating: true,
                dirty: true
            };
        });
        this.setFields(allFields);
        // in case normalize
        Object.keys(allValues).forEach(f => {
            allValues[f] = this.fieldsStore.getFieldValue(f);
        });
        if (callback && isEmptyObject(allFields)) {
            callback(isEmptyObject(alreadyErrors) ? null : alreadyErrors,
                this.fieldsStore.getFieldsValue(fieldNames));
            return;
        }

        this.mixValidateFields(allRules, allValues, options).then(messages => {
            const errorsGroup = this.getMessageGroup('errors', messages, allRules, alreadyErrors);
            const warningsGroup = this.getMessageGroup('warnings', messages, allRules, alreadyWarnings);
            const successesGroup = this.getMessageGroup('successes', messages, allRules, alreadySuccesses);
            const expired = [];
            const nowAllFields = {};
            Object.keys(allRules).forEach(name => {
                const fieldErrors = get(errorsGroup, name);
                const fieldWarnings = get(warningsGroup, name);
                const fieldSuccesses = get(successesGroup, name);
                const nowField = this.fieldsStore.getField(name);
                // avoid concurrency problems
                if (!isEqual(nowField.value, allValues[name])) {
                    expired.push({
                        name
                    });
                } else {
                    nowField.errors = fieldErrors && fieldErrors.errors;
                    nowField.warnings = fieldWarnings && fieldWarnings.warnings;
                    nowField.successes = fieldSuccesses && fieldSuccesses.successes;
                    nowField.value = allValues[name];
                    nowField.validating = false;
                    nowField.dirty = false;
                    nowAllFields[name] = nowField;
                }
            });
            this.setFields(nowAllFields);
            if (callback) {
                if (expired.length) {
                    expired.forEach(({name}) => {
                        const fieldErrors = [{
                            message: `${name} need to revalidate`,
                            field: name
                        }];
                        set(errorsGroup, name, {
                            expired: true,
                            errors: fieldErrors
                        });
                    });
                }

                callback(isEmptyObject(errorsGroup) ? null : errorsGroup,
                    this.fieldsStore.getFieldsValue(fieldNames));
            }
        });
    }

    validateFields = (ns?, opt?, cb?) => {
        const pending = new Promise((resolve, reject) => {
            const {names, options} = getParams(ns, opt, cb);
            let {callback} = getParams(ns, opt, cb);
            if (!callback || typeof callback === 'function') {
                const oldCb = callback;
                callback = (errors, values) => {
                    if (oldCb) {
                        oldCb(errors, values);
                    } else if (errors) {
                        reject({errors, values});
                    } else {
                        resolve(values);
                    }
                };
            }
            const fieldNames = names ? this.fieldsStore.getValidFieldsFullName(names)
                : this.fieldsStore.getValidFieldsName();
            const fields = fieldNames
                .filter(name => {
                    const fieldMeta = this.fieldsStore.getFieldMeta(name);
                    return hasRules(fieldMeta.validate);
                }).map(name => {
                    const field = this.fieldsStore.getField(name);
                    field.value = this.fieldsStore.getFieldValue(name);
                    return field;
                });
            if (!fields.length) {
                callback(null, this.fieldsStore.getFieldsValue(fieldNames));
                return;
            }
            if (!('firstFields' in options)) {
                options.firstFields = fieldNames.filter(name => {
                    const fieldMeta = this.fieldsStore.getFieldMeta(name);
                    return !!fieldMeta.validateFirst;
                });
            }
            this.validateFieldsInternal(fields, {
                fieldNames,
                options
            }, callback);
        });
        pending.catch(e => {
            return e;
        });
        return pending;
    }

    isSubmitting = () => {
        return this.state.submitting;
    }

    submit = (callback) => {
        const fn = () => {
            this.setState({
                submitting: false
            });
        };
        this.setState({
            submitting: true
        });
        callback(fn);
    }

    validateFieldsAndScroll = (ns?, opt?, cb?) => {
        const {names, callback, options} = getParams(ns, opt, cb);

        const newCb = ({errors, values}) => {
            if (errors) {
                const validNames = this.fieldsStore.getValidFieldsName();
                let firstNode;
                let firstTop;

                validNames.forEach(name => {
                    if (has(errors, name)) {
                        const instance = this.getFieldInstance(name);
                        if (instance) {
                            const node = ReactDOM.findDOMNode(instance) as Element;
                            const top = node.getBoundingClientRect().top;
                            if (firstTop === undefined || firstTop > top) {
                                firstTop = top;
                                firstNode = node;
                            }
                        }
                    }
                });

                if (firstNode) {
                    const c = options.container || getScrollableContainer(firstNode);
                    scrollIntoView(firstNode, c, {
                        onlyScrollIfNeeded: true,
                        ...options.scroll
                    });
                }
            }

            if (typeof callback === 'function') {
                callback(errors, values);
            }
        };
        const validate = this.validateFields(names, options);
        validate.then(
            values => {
                if (typeof callback === 'function') {
                    callback(undefined, values);
                }
            },
            newCb
        );
        return validate;
    }

    scrollToField = (name: string, options: {container?: HTMLElement} = {}) => {
        const instance = this.getFieldInstance(name);
        if (instance) {
            const node = ReactDOM.findDOMNode(instance) as HTMLElement;
            const container = options.container || getScrollableContainer(node);
            scrollIntoView(node, container, {
                onlyScrollIfNeeded: true
            });
        }
    }

    isFormValidating = () => {
        return this.state.formValidating;
    }

    validateForm = (scrollToError) => {
        this.setState({
            formValidating: true
        });
        let validate;
        if (scrollToError) {
            validate = this.validateFieldsAndScroll();
        }
        validate = this.validateFields();
        validate.catch(() => {}).finally(() => this.setState({formValidating: false}));
        return validate;
    }

    private getMessageGroup(
        type: 'errors' | 'successes' | 'warnings',
        messages: {},
        allRules: {},
        typedMessages: {}
    ) {
        const newMessages = messages[type];
        const messagesGroup = {...typedMessages};
        newMessages.forEach(e => {
            const fieldName = this.getFieldName(e.field, allRules);
            const field = get(messagesGroup, fieldName);
            if (typeof field !== 'object' || Array.isArray(field)) {
                set(messagesGroup, fieldName, {[type]: []});
            }
            const data = get(messagesGroup, fieldName.concat(`.${type}`));
            data.push(e);
        });
        return messagesGroup;
    }

    private getFieldName(errorFieldName: string, allRules: {}) {
        let fieldName = errorFieldName;
        Object.keys(allRules).some(ruleFieldName => {
            const rules = allRules[ruleFieldName] || [];
            // Exist if match rule
            if (ruleFieldName === errorFieldName) {
                fieldName = ruleFieldName;
                return true;
            }
            // Skip if not match array type
            if (rules.every(({ type }) => type !== 'array')
                && errorFieldName.indexOf(ruleFieldName) !== 0) {
                return false;
            }
            // Exist if match the field name
            const restPath = errorFieldName.slice(ruleFieldName.length + 1);
            if (/^\d+$/.test(restPath)) {
                fieldName = ruleFieldName;
                return true;
            }
            return false;
        });
        return fieldName;
    }

    getForm() {
        return {
            getFieldsValue: this.fieldsStore.getFieldsValue,
            getFieldValue: this.fieldsStore.getFieldValue,
            getFieldInstance: this.getFieldInstance,
            setFieldsValue: this.setFieldsValue,
            setFieldsError: this.setFieldsError,
            setFields: this.setFields,
            setFieldsInitialValue: this.fieldsStore.setFieldsInitialValue,
            getFieldDecorator: this.getFieldDecorator,
            getFieldProps: this.getFieldProps,
            getFieldsError: this.fieldsStore.getFieldsError,
            getFieldError: this.fieldsStore.getFieldError,
            getFieldsSuccess: this.fieldsStore.getFieldsSuccess,
            getFieldSuccess: this.fieldsStore.getFieldSuccess,
            getFieldsWarning: this.fieldsStore.getFieldsWarning,
            getFieldWarning: this.fieldsStore.getFieldWarning,
            isFieldValidating: this.fieldsStore.isFieldValidating,
            isFieldsValidating: this.fieldsStore.isFieldsValidating,
            isFieldsTouched: this.fieldsStore.isFieldsTouched,
            isFieldTouched: this.fieldsStore.isFieldTouched,
            isSubmitting: this.isSubmitting,
            submit: this.submit,
            validateForm: this.validateForm,
            isFormValidating: this.isFormValidating,
            validateFields: this.validateFields,
            resetFields: this.resetFields,
            validateFieldsAndScroll: this.validateFieldsAndScroll,
            scrollToField: this.scrollToField
        };
    }

    render() {
        const {wrappedComponentRef, LegacyForm, formPropName, mapProps, ...restProps} = this.props;
        const formProps = {
            [formPropName]: this.getForm()
        };
        formProps.ref = wrappedComponentRef;
        const props = mapProps.call(this, {
            ...formProps,
            ...restProps
        });
        if (LegacyForm) {
            return <LegacyForm {...props} />;
        }
        return (
            <FormContext.Provider value={{...this.context, form: this}}>
                {this.props.children}
            </FormContext.Provider>
        );
    }
};

const createBaseForm =
    (option: FormOption = {}) => LegacyForm => forwardRef<BaseForm>((props, ref) => (
        <LegacyFormContext.Provider value={{legacy: true}}>
            <BaseForm {...option} {...props} LegacyForm={LegacyForm} ref={ref} />
        </LegacyFormContext.Provider>
    ));

export default createBaseForm;
