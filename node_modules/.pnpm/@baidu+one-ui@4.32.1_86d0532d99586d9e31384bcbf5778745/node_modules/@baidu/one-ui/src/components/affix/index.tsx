import React, {Component, CSSProperties} from 'react';
import addEventListener from 'rc-util/lib/Dom/addEventListener';
import shallowequal from 'shallowequal';
import omit from 'omit.js';
import {throttle, noop} from 'lodash';
import {classnames} from '../../core/commonTools';
import {getScroll} from '../../core/affixTools';
import {AffixProps} from './interface';
import {withConfigConsumer} from '../providerConfig/context';

const getTargetRect = (target: HTMLElement | Window) => {
    return target !== window
        ? (target as HTMLElement).getBoundingClientRect()
        : {top: 0, left: 0, bottom: 0};
};

const getOffset = (element: HTMLElement, target: HTMLElement | Window) => {
    const elemRect = element.getBoundingClientRect();
    const targetRect = getTargetRect(target);

    const scrollTop = getScroll(target, true);
    const scrollLeft = getScroll(target, false);

    const docElem = window.document.body;
    const clientTop = docElem.clientTop || 0;
    const clientLeft = docElem.clientLeft || 0;

    return {
        top: (elemRect.top - targetRect.top) + (scrollTop - clientTop),
        left: (elemRect.left - targetRect.left) + (scrollLeft - clientLeft),
        width: elemRect.width,
        height: elemRect.height
    };
};

type AffixState = {
    affixStyle?: CSSProperties;
    placeholderStyle?: {
        width: number;
        height: number;
    }
}

type EventHandler = ({remove: () => {}})
type EventHandlers = {[key: string]: EventHandler}

@withConfigConsumer('affix')
class Affix extends Component<AffixProps, AffixState> {
    static defaultProps = {
        prefixCls: 'one-affix',
        target: () => window,
        onChange: noop,
        zIndex: 1
    };

    timeout?: number;
    fixedNode: HTMLElement | undefined;
    affixNode;

    state: AffixState = {
        affixStyle: null,
        placeholderStyle: null
    };

    componentDidMount() {
        const target = this.props.target;
        this.timeout = setTimeout(() => {
            this.setTargetEventListeners(target);
            this.updatePosition();
        });
    }

    componentDidUpdate(prevProps: AffixProps) {
        if (this.props.target !== prevProps.target) {
            this.clearEventListeners();
            this.setTargetEventListeners(this.props.target);
        }
        this.updatePosition();
    }

    componentWillUnmount() {
        this.clearEventListeners();
        clearTimeout(this.timeout);
    }

    setTargetEventListeners = (getTarget) => {
        const target = getTarget();
        if (!target) {
            return;
        }
        this.clearEventListeners();

        this.events.forEach(eventName => {
            this.eventHandlers[eventName] = addEventListener(target, eventName, throttle(this.updatePosition, 10));
        });
    }

    setAffixStyle = (eventType: string, affixStyle?: CSSProperties) => {
        const {onChange, target} = this.props;
        const originalAffixStyle = this.state.affixStyle;
        const isWindow = target() === window;
        if (eventType === 'scroll' && originalAffixStyle && affixStyle && isWindow) {
            return;
        }
        if (shallowequal(affixStyle, originalAffixStyle)) {
            return;
        }
        this.setState({affixStyle}, () => {
            const affixed = !!this.state.affixStyle;
            if ((affixStyle && !originalAffixStyle)
                || (!affixStyle && originalAffixStyle)) {
                onChange(affixed);
            }
        });
    }

    saveAffixNode = affixNode => {
        this.affixNode = affixNode;
    }

    setPlaceholderStyle = (placeholderStyle) => {
        const originalPlaceholderStyle = this.state.placeholderStyle;
        if (shallowequal(placeholderStyle, originalPlaceholderStyle)) {
            return;
        }
        this.setState({placeholderStyle});
    }

    getFixedNode = (node: HTMLDivElement): void => {
        this.fixedNode = node;
    }

    updatePosition = (event?: Event) => {
        if (!this.fixedNode) {
            return;
        }
        let eventType = null;
        if (event) {
            eventType = event.type;
        }
        const {
            offsetBottom,
            target,
            zIndex
        } = this.props;
        let offsetTop = this.props.offsetTop;
        const targetNode = target();
        const scrollTop = getScroll(targetNode, true);
        const elemOffset = getOffset(this.affixNode, targetNode);
        const elemSize = {
            width: this.fixedNode.offsetWidth,
            height: this.fixedNode.offsetHeight
        };

        const offsetMode = {
            top: false,
            bottom: false
        };

        if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {
            offsetMode.top = true;
            offsetTop = 0;
        }
        else {
            offsetMode.top = typeof offsetTop === 'number';
            offsetMode.bottom = typeof offsetBottom === 'number';
        }

        const targetRect = getTargetRect(targetNode);
        const targetInnerHeight = (targetNode as Window).innerHeight || (targetNode as HTMLElement).clientHeight;

        if (
            offsetMode.top
            && scrollTop > elemOffset.top - offsetTop
        ) {
            // Fixed Top
            const width = elemOffset.width;
            this.setAffixStyle(eventType, {
                position: 'fixed',
                top: targetRect.top + offsetTop,
                left: targetRect.left + elemOffset.left,
                width,
                zIndex
            });
            this.setPlaceholderStyle({
                width,
                height: elemSize.height
            });
        }
        else if (offsetMode.bottom
            && scrollTop < ((elemOffset.top + elemSize.height) + (offsetBottom - targetInnerHeight))
        ) {
            const targetBottomOffet = targetNode === window ? 0 : (window.innerHeight - targetRect.bottom);
            const width = elemOffset.width;
            this.setAffixStyle(eventType, {
                position: 'fixed',
                bottom: (targetBottomOffet + offsetBottom),
                left: (targetRect.left + elemOffset.left),
                width,
                zIndex
            });
            this.setPlaceholderStyle({
                width,
                height: elemOffset.height
            });
        }
        else {
            const affixStyle = this.state.affixStyle;
            const affixNodeOffsetWidth = this.affixNode.offsetWidth;
            if (eventType === 'resize' && affixStyle && affixStyle.position === 'fixed' && affixNodeOffsetWidth) {
                this.setAffixStyle(eventType, {...affixStyle, width: affixNodeOffsetWidth});
            }
            else {
                this.setAffixStyle(eventType, null);
            }
            this.setPlaceholderStyle(null);
        }
    }

    eventHandlers: EventHandlers = {};

    clearEventListeners = () => {
        this.events.forEach(eventName => {
            const handler = this.eventHandlers[eventName];
            if (handler && handler.remove) {
                handler.remove();
            }
        });
    }

    events = [
        'resize',
        'scroll',
        'touchstart',
        'touchmove',
        'touchend',
        'pageshow',
        'load'
    ];

    render() {
        const {
            affixStyle,
            placeholderStyle
        } = this.state;
        const {prefixCls, style, children} = this.props;
        const className = classnames({
            [prefixCls]: affixStyle
        });

        const props = omit(this.props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'zIndex']);
        return (
            <div {...props} style={style} ref={this.saveAffixNode}>
                {placeholderStyle && <div aria-hidden style={placeholderStyle} />}
                <div className={className} ref={this.getFixedNode} style={affixStyle}>
                    {children}
                </div>
            </div>
        );
    }
}

export default Affix;
export type {AffixProps};
