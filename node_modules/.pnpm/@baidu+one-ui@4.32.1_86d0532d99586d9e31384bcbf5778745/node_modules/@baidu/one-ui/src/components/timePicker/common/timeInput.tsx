import React, {KeyboardEventHandler, PureComponent} from 'react';
import moment, {Moment} from 'moment';
import {
    IconClock,
    IconTimesCircle
} from 'dls-icons-react';
import {fomatStr, addZero} from '../../../core/timePickerTools';
import Input from '../../input';
import {classnames} from '../../../core/commonTools';
import {BaseProps} from '../../interface';

interface TimeInputProps extends BaseProps {
    format: string,
    placeholder: string,
    value: Moment,
    defaultOpenValue: Moment,
    inputReadOnly: boolean,
    hourOptions: number[],
    minuteOptions: number[],
    secondOptions: number[],
    disabledHours(): number[],
    disabledMinutes(hour: number): number[],
    disabledSeconds(hour: number, minute: number): number[],
    allowEmpty: boolean,
    disabled: boolean,
    errorMessage: string,
    onChange(value: Moment),
    onEsc(),
    onKeyDown: KeyboardEventHandler,
    onFocus(),
    onBlur(),
    onClear(e),
    size: 'small' | 'medium',
    width: number,
    name: string,
};

interface TimeInputState {
    str?: string;
    value?: Moment;
    invalid?: boolean;
    isFocus?: boolean;
    prevProps?: TimeInputProps
}

class TimeInput extends PureComponent<TimeInputProps, TimeInputState> {

    static defaultProps = {
        inputReadOnly: false,
        style: {}
    };

    constructor(props) {
        super(props);
        const {value, format} = props;
        this.state = {
            str: (value && value.format(format)) || '',
            invalid: false,
            isFocus: false,
            prevProps: props
        };
    }

    static getDerivedStateFromProps = (nextProps, prevState) => {
        const {value, format} = nextProps;
        const {value: originValue} = prevState.prevProps;
        const newState: TimeInputState = {
            prevProps: nextProps
        };
        const currentStr = (originValue && originValue.format(format)) || '';
        const nextStr = (value && value.format(format)) || '';
        if (nextStr !== currentStr) {
            newState.str = nextStr;
            newState.invalid = false;
        }
        return newState;
    }

    refInput;
    ___stopBlur___;

    onEsc = () => {
        this.props.onEsc();
        this.refInput.focus();
    };

    onInputChange = event => {
        let str = event.value;
        const preFn = event.preFn;
        str = fomatStr(str);
        this.setState({str});
        const {
            format,
            hourOptions,
            minuteOptions,
            secondOptions,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            onChange,
            allowEmpty
        } = this.props;

        if (str) {
            const {value: originalValue} = this.props;
            const value = this.getProtoValue().clone();
            const parsed = moment(str, format, true);
            let newState: TimeInputState = {invalid: true};
            const originalStr = (originalValue && originalValue.format(this.props.format)) || '';
            if (!parsed.isValid()) {
                if (preFn === 'onBlur') {
                    newState = {
                        str: originalStr,
                        invalid: false
                    };
                }
                this.setState(newState);
                return;
            }
            value
                .hour(parsed.hour())
                .minute(parsed.minute())
                .second(parsed.second());

            // if time value not allowed, response warning.
            if (
                hourOptions.indexOf(value.hour()) < 0
                || minuteOptions.indexOf(value.minute()) < 0
                || secondOptions.indexOf(value.second()) < 0
            ) {
                if (preFn === 'onBlur') {
                    newState = {
                        str: originalStr,
                        invalid: false
                    };
                }
                this.setState(newState);
                return;
            }

            // if time value is disabled, response warning.
            const disabledHourOptions = disabledHours();
            const disabledMinuteOptions = disabledMinutes(value.hour());
            const disabledSecondOptions = disabledSeconds(value.hour(), value.minute());
            if (
                (disabledHourOptions && disabledHourOptions.indexOf(value.hour()) >= 0)
                || (disabledMinuteOptions && disabledMinuteOptions.indexOf(value.minute()) >= 0)
                || (disabledSecondOptions && disabledSecondOptions.indexOf(value.second()) >= 0)
            ) {
                if (preFn === 'onBlur') {
                    newState = {
                        str: originalStr,
                        invalid: false
                    };
                }
                this.setState(newState);
                return;
            }
            if (originalValue) {
                const changedValue = originalValue.clone();
                changedValue.hour(value.hour());
                changedValue.minute(value.minute());
                changedValue.second(value.second());
                onChange(changedValue);
            }
            else if (originalValue !== value) {
                onChange(value);
            }
        }
        else if (allowEmpty) {
            onChange(null);
        }
        else {
            this.setState({
                invalid: true
            });
            return;
        }

        this.setState({
            invalid: false
        });
    };

    onKeyDown = e => {
        if (e.keyCode === 27) {
            this.onEsc();
        }
        else if (e.keyCode === 13) {
            this.onBlur();
        }

        this.props.onKeyDown(e);
    };

    onFocus = () => {
        this.setState({isFocus: true});
        this.props.onFocus();
    }

    blurTimeout;

    onBlur = () => {
        this.blurTimeout = setTimeout(() => {
            if (this.___stopBlur___) {
                this.___stopBlur___ = false;
                return;
            }
            const {str, invalid} = this.state;
            if (str && invalid) {
                // 为了小于10的数补上0
                this.onInputChange({value: addZero(str), preFn: 'onBlur'});
            }
            this.setState({isFocus: false});
        }, 200);
        this.props.onBlur();
    }

    componentWillUnmount(): void {
        clearTimeout(this.blurTimeout);
    }

    onClear = e => {
        this.___stopBlur___ = true;
        this.props.onClear(e);
    }

    getProtoValue = () => {
        const {value, defaultOpenValue} = this.props;
        return value || defaultOpenValue;
    }

    renderClearButton = () => {
        const {str, isFocus} = this.state;
        const {prefixCls, allowEmpty} = this.props;
        if (!allowEmpty) {
            return null;
        }

        return (
            isFocus && str
                ? <IconTimesCircle onClick={this.onClear} className={`${prefixCls}-icon-close`} />
                : <IconClock className={`${prefixCls}-icon-clock`} />
        );
    }

    renderInput = () => {
        const {
            prefixCls,
            placeholder,
            inputReadOnly,
            disabled,
            style,
            size,
            name,
            width
        } = this.props;
        const {invalid, str} = this.state;
        const invalidClass = invalid ? `${prefixCls}-input-invalid` : '';
        return (
            <Input
                style={style}
                className={`${prefixCls}-input  ${invalidClass}`}
                ref={ref => {
                    this.refInput = ref;
                }}
                onKeyDown={this.onKeyDown}
                value={str}
                placeholder={placeholder}
                onChange={this.onInputChange}
                readOnly={!!inputReadOnly}
                isRequired={false}
                onFocus={this.onFocus}
                onBlur={this.onBlur}
                disabled={disabled}
                name={name}
                size={size}
                width={width}
            />
        );
    }

    render() {
        const {prefixCls, errorMessage} = this.props;
        const wrapClass = classnames(
            `${prefixCls}-input-wrap`,
            {
                [`${prefixCls}-input-wrap-error`]: errorMessage
            }
        );
        return (
            <div className={wrapClass}>
                {this.renderInput()}
                {this.renderClearButton()}
            </div>
        );
    }
}

export default TimeInput;
