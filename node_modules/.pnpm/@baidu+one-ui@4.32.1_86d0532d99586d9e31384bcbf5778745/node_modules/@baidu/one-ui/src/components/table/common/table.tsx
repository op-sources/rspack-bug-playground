import React, {PureComponent, ReactNode} from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import addEventListener from 'rc-util/lib/Dom/addEventListener';
import {Provider, create} from 'mini-store';
import {debounce, findIndex, throttle} from 'lodash';
import {classnames, getWindowHeight} from '../../../core/commonTools';
import classes from 'component-classes';
import Loading from '../../loading';
import ColumnManager from './columnManager';
import HeadTable from './headTable';
import BodyTable from './bodyTable';
import ExpandableTable from './expandableTable';
import DragLine from './dragLine';
import {
    formatTableWidth,
    isColumnWidthChange,
    recalcWidthWhenColumnsChange,
    resetWidthByColumnsWidth,
    uniformCalcWidth
} from './utils';
import {TableColumnWidth, TableProps} from '../interface';
import {InnerTableColumnProps} from './interface';
import Context from './context';
import classNames from 'classnames';

export interface InnerTableProps extends TableProps {
    loadingText?: ReactNode | (() => ReactNode);
    emptyText?: ReactNode | (() => ReactNode);
    data?: object[];

    id?: string;
    onHeaderRow;

    /**
     * @deprecated
     */
    title?(data);

    /**
     * @deprecated
     */
    footer?(data);
}

interface InnerTableState {
    isBottomScrollShow?: boolean;
    columns?: InnerTableColumnProps[];
    containerWidth?: number;
}

export interface TableStore {
    dynamicWidth: number,
    allColumnsWidth: TableColumnWidth[],
    dragging: boolean,
    expandedRowKeys: Array<string | number>
}

class ComponentTable extends PureComponent<InnerTableProps, InnerTableState> {

    static defaultProps = {
        headerFixTop: null,
        data: [],
        useFixedHeader: false,
        rowKey: 'key',
        rowClassName: () => '',
        onRow() { },
        onHeaderRow() { },
        prefixCls: 'one-table',
        bodyStyle: {},
        style: {},
        showHeader: true,
        scroll: {},
        bottomScroll: {
            bottom: null,
            style: {}
        },
        rowRef: () => null,
        emptyText: () => '暂无数据',
        updateWidthChange: false,
        useStickyFixTop: true
    };

    columnManager;
    store;
    debouncedWindowResize;
    debouncedWindowScroll;
    resizeEvent;
    scrollEvent;
    headTableWheelEvent;

    headTable;
    bottomScroll;
    scrollPosition;
    bodyTable;
    tableNode;
    fixedHeadTable;
    lastScrollLeft;
    lastScrollTop;
    expander;
    tableContainerRef;
    dragLeftRef;
    curAllColumnsWidth;
    curDynamicWidth;

    constructor(props) {
        super(props);
        this.columnManager = new ColumnManager(props.columns);
        this.store = create({
            fixedColumnsHeadRowsHeight: [],
            fixedColumnsBodyRowsHeight: [],
            dynamicWidth: 0,
            allColumnsWidth: [],
            dragging: false
        });

        this.state = {};

        this.setScrollPosition('left');
        this.debouncedWindowResize = debounce(this.handleWindowResize, 150);
        this.debouncedWindowScroll = this.handleWindowScroll.bind(this);
        this.renderBottomScroll = this.renderBottomScroll.bind(this);
    }

    resizeObserver = null;

    getContext() {
        return {
            table: {
                props: this.props,
                columnManager: this.columnManager,
                saveRef: this.saveRef,
                headTable: this.headTable,
                bottomScroll: this.bottomScroll,
                bodyTable: this.bodyTable,
                containerWidth: this.getContainerWidth()
            }
        };
    }

    static getDerivedStateFromProps(nextProps, prevState) {
        if (nextProps.columns && nextProps.columns !== prevState.columns) {
            return {
                columns: nextProps.columns
            };
        }
        return null;
    }

    setTableScrollbar() {
        // 当body scrollY有占位时候，head会出现对齐问题，所以同时设定为scroll保持一致占位
        if (this.headTable && this.bodyTable) {
            if (this.bodyTable.scrollHeight > this.bodyTable.offsetHeight) {
                this.headTable.style.overflowY = 'scroll';
                this.bodyTable.style.overflowY = 'scroll';
            }
            else {
                this.headTable.style.overflowY = '';
                this.bodyTable.style.overflowY = this.props.bodyStyle.overflowY || 'auto';
            }
        }
    }

    handleHeadWheel = ({nativeEvent}) => {
        const {
            deltaX,
            currentTarget
        } = nativeEvent;
        if (deltaX) {
            currentTarget.scrollLeft = currentTarget.scrollLeft + deltaX;
            nativeEvent.preventDefault();
            this.handleBodyScrollLeft({
                currentTarget,
                target: currentTarget

            });
        }
    }

    componentDidMount() {
        const bodyTable = this.bodyTable;
        this.setState({
            containerWidth: this.getContainerWidth()
        });
        const scroll = this.props.scroll || {};
        let bodyWidth = formatTableWidth(bodyTable, scroll, this.props.expandedRowRender);
        const allColumnsWidth = this.columnManager.allColumnsWidth(bodyWidth);
        this.store.setState({
            allColumnsWidth: uniformCalcWidth(allColumnsWidth, bodyWidth)
        });
        if (this.columnManager.isAnyColumnsFixed()) {
            const that = this;
            that.handleWindowResize();
            this.resizeEvent = addEventListener(window, 'resize', this.debouncedWindowResize);
        }
        if (this.props.headerFixTop !== null || this.props.bottomScroll.bottom !== null) {
            this.handleWindowScroll();
            this.scrollEvent = addEventListener(window, 'scroll', this.debouncedWindowScroll);
        }
        if (this.headTable) {
            this.headTableWheelEvent = addEventListener(this.headTable, 'wheel', this.handleHeadWheel);
        }
        this.setTableScrollbar();
        if (this.props.updateWidthChange) {
            const resize = throttle(() => {
                const {scroll, expandedRowRender} = this.props;
                const curBodyWidth = formatTableWidth(
                    this.bodyTable,
                    scroll,
                    expandedRowRender
                );
                if (curBodyWidth === bodyWidth) {
                    return;
                }
                // 宽度发生变化的时候的时候，强制重绘
                const allColumnsWidth = recalcWidthWhenColumnsChange(
                    this.store.getState().allColumnsWidth,
                    this.props.columns,
                    this.props.columns,
                    curBodyWidth
                );
                this.store.setState({
                    dynamicWidth: 0,
                    allColumnsWidth: uniformCalcWidth(allColumnsWidth, curBodyWidth)
                });
                this.forceUpdate();
                bodyWidth = curBodyWidth;
            }, 16);
            this.resizeObserver = new ResizeObserver(entries => {
                entries.forEach(({target, contentRect}) => {
                    if (target === this.tableNode) {
                        resize();
                    }
                });
            });
            if (this.tableNode) {
                this.resizeObserver.observe(this.tableNode);
            }
        }
    }

    componentDidUpdate(prevProps) {
        if (this.columnManager.isAnyColumnsFixed()) {
            this.handleWindowResize();
            if (!this.resizeEvent) {
                this.resizeEvent = addEventListener(window, 'resize', this.debouncedWindowResize);
            }
        }
        // when table changes to empty, reset scrollLeft
        if (prevProps.data.length > 0 && this.props.data.length === 0 && this.hasScrollX()) {
            this.resetScrollX();
        }

        if (this.props.headerFixTop !== null || this.props.bottomScroll.bottom !== null) {
            this.handleWindowScroll();
            if (!this.scrollEvent) {
                this.scrollEvent = addEventListener(window, 'scroll', this.debouncedWindowScroll);
            }
            if (this.headTable) {
                this.headTable.scrollLeft = this.lastScrollLeft;
            }
            if (this.fixedHeadTable) {
                this.fixedHeadTable.scrollLeft = this.lastScrollLeft;
            }
            if (this.bottomScroll) {
                this.bottomScroll.scrollLeft = this.lastScrollLeft;
            }
        }
        if (!this.headTable && this.headTableWheelEvent) {
            this.headTableWheelEvent.remove();
            this.headTableWheelEvent = null;
        }
        else if (this.headTable && !this.headTableWheelEvent) {
            this.headTableWheelEvent = addEventListener(this.headTable, 'wheel', this.handleHeadWheel);
        }
        this.setTableScrollbar();
        if (this.props.columns && prevProps.columns !== this.props.columns
        && isColumnWidthChange(prevProps.columns, this.props.columns)) {
            const bodyTable = this.bodyTable;
            const bodyWidth = formatTableWidth(bodyTable, this.props.scroll, this.props.expandedRowRender);
            const allColumnsWidth = this.store.getState().allColumnsWidth;
            const columns = recalcWidthWhenColumnsChange(
                allColumnsWidth,
                this.props.columns,
                prevProps.columns,
                bodyWidth
            );
            const newColumns = uniformCalcWidth(columns, bodyWidth);
            this.store.setState({
                dynamicWidth: 0,
                allColumnsWidth: newColumns
            });
            this.forceUpdate();
        }
    }

    componentWillUnmount() {
        if (this.resizeEvent) {
            this.resizeEvent.remove();
            this.resizeEvent = null;
        }
        if (this.debouncedWindowResize) {
            this.debouncedWindowResize.cancel();
            this.debouncedWindowResize = null;
        }
        if (this.scrollEvent) {
            this.scrollEvent.remove();
            this.scrollEvent = null;
        }

        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }

        if (this.headTableWheelEvent) {
            this.headTableWheelEvent.remove();
            this.headTableWheelEvent = null;
        }
    }


    updateColumnWidths(columns) {
        const bodyTable = this.bodyTable;
        const bodyWidth = formatTableWidth(bodyTable, this.props.scroll, this.props.expandedRowRender);
        const resetColumns = columns || this.props.columns;
        const resetColumnsSelection = resetColumns.filter(col => col.key === 'selection-column')[0];
        const oriAllColumnsWidth = this.store.getState().allColumnsWidth;
        const oriSelection = oriAllColumnsWidth.filter(col => col.key === 'selection-column')[0];
        if (oriSelection && !resetColumnsSelection) {
            const index = findIndex(oriAllColumnsWidth, {key: 'selection-column'});
            resetColumns.splice(index, 0, oriSelection);
        }
        const allColumnsWidth = resetWidthByColumnsWidth(
            resetColumns,
            bodyWidth
        );
        const newColumns = uniformCalcWidth(allColumnsWidth, bodyWidth);
        this.store.setState({
            dynamicWidth: 0,
            allColumnsWidth: newColumns
        });
    }

    getRowKey = (record, index) => {
        const rowKey = this.props.rowKey;
        const key = typeof rowKey === 'function' ? rowKey(record, index) : record[rowKey];
        return key === undefined ? index : key;
    };

    setScrollPosition(position) {
        this.scrollPosition = position;
        if (this.tableNode) {
            const {prefixCls} = this.props;
            if (position === 'both') {
                classes(this.tableNode)
                    .remove(new RegExp(`^${prefixCls}-scroll-position-.+$`))
                    .add(`${prefixCls}-scroll-position-left`)
                    .add(`${prefixCls}-scroll-position-right`);
            }
            else {
                classes(this.tableNode)
                    .remove(new RegExp(`^${prefixCls}-scroll-position-.+$`))
                    .add(`${prefixCls}-scroll-position-${position}`);
            }
        }
    }

    setScrollPositionClassName() {
        const node = this.bodyTable;
        const scrollToLeft = node.scrollLeft === 0;
        const scrollToRight = node.scrollLeft
            >= node.children[0].getBoundingClientRect().width - node.getBoundingClientRect().width;
        if (scrollToLeft && scrollToRight) {
            this.setScrollPosition('both');
        }
        else if (scrollToLeft) {
            this.setScrollPosition('left');
        }
        else if (scrollToRight) {
            this.setScrollPosition('right');
        }
        else if (this.scrollPosition !== 'middle') {
            this.setScrollPosition('middle');
        }
    }

    handleWindowResize = () => {
        this.setScrollPositionClassName();
    };

    handleWindowScroll = () => {
        if (this.props.bottomScroll.bottom == null) {
            return null;
        }
        const {headTable, bodyTable} = this;
        if (headTable && bodyTable) {
            const bodyTableRect = bodyTable.getBoundingClientRect();
            const allColumnsWidth = this.store.getState().allColumnsWidth;
            let tableWidth = 0;
            allColumnsWidth.forEach(col => {
                tableWidth += col.width;
            });
            const isBottomScrollShow = (bodyTableRect.bottom
                > getWindowHeight() - this.props.bottomScroll.bottom)
                && tableWidth > bodyTableRect.width;
            if (
                isBottomScrollShow !== this.state.isBottomScrollShow
            ) {
                this.setState({
                    isBottomScrollShow
                });
            }
        }
    };

    resetScrollX() {
        if (this.headTable) {
            this.headTable.scrollLeft = 0;
        }
        if (this.fixedHeadTable) {
            this.fixedHeadTable.scrollLeft = 0;
        }
        if (this.bodyTable) {
            this.bodyTable.scrollLeft = 0;
        }
        if (this.bottomScroll) {
            this.bottomScroll.scrollLeft = 0;
        }
    }

    hasScrollX() {
        const {scroll = {}} = this.props;
        return 'x' in scroll;
    }

    handleBodyScrollLeft = e => {
        if (e.currentTarget !== e.target) {
            return;
        }
        const target = e.target;
        const {scroll = {}} = this.props;
        const dynamicWidth = this.store.getState().dynamicWidth;
        const {headTable, bodyTable, fixedHeadTable, bottomScroll} = this;
        const scrollX = scroll.x === undefined ? true : scroll.x;
        if (
            target.scrollLeft !== this.lastScrollLeft
            && (scrollX || dynamicWidth >= bodyTable.getBoundingClientRect().width)
        ) {
            if (target === bodyTable) {
                if (headTable) {
                    headTable.scrollLeft = target.scrollLeft;
                }
                if (fixedHeadTable) {
                    fixedHeadTable.scrollLeft = target.scrollLeft;
                }
                if (bottomScroll) {
                    bottomScroll.scrollLeft = target.scrollLeft;
                }
            }
            else if (target === headTable) {
                if (fixedHeadTable) {
                    fixedHeadTable.scrollLeft = target.scrollLeft;
                }
                if (bodyTable) {
                    bodyTable.scrollLeft = target.scrollLeft;
                }
                if (bottomScroll) {
                    bottomScroll.scrollLeft = target.scrollLeft;
                }
            }
            else if (target === fixedHeadTable) {
                if (headTable) {
                    headTable.scrollLeft = target.scrollLeft;
                }
                if (bodyTable) {
                    bodyTable.scrollLeft = target.scrollLeft;
                }
                if (bottomScroll) {
                    bottomScroll.scrollLeft = target.scrollLeft;
                }
            }
            else if (target === bottomScroll) {
                if (headTable) {
                    headTable.scrollLeft = target.scrollLeft;
                }
                if (bodyTable) {
                    bodyTable.scrollLeft = target.scrollLeft;
                }
                if (fixedHeadTable) {
                    fixedHeadTable.scrollLeft = target.scrollLeft;
                }
            }

            this.setScrollPositionClassName();
        }
        // Remember last scrollLeft for scroll direction detecting.
        this.lastScrollLeft = target.scrollLeft;
    };

    handleBodyScrollTop = e => {
        const target = e.target;
        if (e.currentTarget !== target) {
            return;
        }
        const {scroll = {}} = this.props;
        const {headTable, bodyTable} = this;
        if (target.scrollTop !== this.lastScrollTop && scroll.y && target !== headTable) {
            const scrollTop = target.scrollTop;
            if (bodyTable && target !== bodyTable) {
                bodyTable.scrollTop = scrollTop;
            }
        }
        // Remember last scrollTop for scroll direction detecting.
        this.lastScrollTop = target.scrollTop;
    };

    handleBodyScroll = e => {
        this.handleBodyScrollLeft(e);
        this.handleBodyScrollTop(e);
    };

    handleWheel = event => {
        const {scroll = {}} = this.props;
        if (window.navigator.userAgent.match(/Trident\/7\./) && scroll.y) {
            event.preventDefault();
            const wd = event.deltaY;
            const target = event.target;
            const {bodyTable} = this;
            let scrollTop = 0;

            if (this.lastScrollTop) {
                scrollTop = this.lastScrollTop + wd;
            }
            else {
                scrollTop = wd;
            }

            if (bodyTable && target !== bodyTable) {
                bodyTable.scrollTop = scrollTop;
            }
        }
    };

    saveRef = name => node => {
        this[name] = node;
        this.props.saveRef(name, node);
    };

    getContainerWidth = () => {
        return this.bodyTable && this.bodyTable.getBoundingClientRect().width;
    };

    renderMainTable = expander => {
        this.expander = expander;
        const {scroll, prefixCls} = this.props;
        const isAnyColumnsFixed = this.columnManager.isAnyColumnsFixed();
        const scrollable = isAnyColumnsFixed || scroll.x || scroll.y;

        const table = [
            this.renderTable({
                columns: this.columnManager.groupedColumns(),
                isAnyColumnsFixed
            }),
            this.renderFooter()
        ];

        return (
            <div
                className={
                    classNames(`${prefixCls}-main`, {
                        [`${prefixCls}-scroll`]: scrollable
                    })
                }
            >
                {table}
            </div>
        );
    }

    calcDragLeft = (dragLeft, isMovingFixedKey) => {
        const curDragLeft = dragLeft
            - (isMovingFixedKey ? 0 : (this.lastScrollLeft || 0));
        return curDragLeft;
    }

    onDragStart = props => {
        if (typeof this.props.onDragStart === 'function') {
            this.props.onDragStart(props);
        }
        const dragLineRef = this.dragLeftRef;
        dragLineRef.setShowLine(true);
        this.store.setState({
            dragging: true
        });
    }

    onDraging = props => {
        const {
            allColumns,
            inner,
            curColumn
        } = props;
        const isMovingFixedKey = curColumn.fixed;
        const dragLineRef = this.dragLeftRef;
        dragLineRef.setShowLine(true);
        if (typeof this.props.onDraging === 'function') {
            this.props.onDraging(props);
        }
        const tableWidth = this.bodyTable && this.bodyTable.clientWidth;
        const gapWidth = tableWidth > inner.dynamicWidth ? (tableWidth - inner.dynamicWidth) : 0;
        allColumns[allColumns.length - 1].width = allColumns[allColumns.length - 1].width + gapWidth;
        this.curAllColumnsWidth = [...allColumns];
        this.curDynamicWidth = tableWidth > inner.dynamicWidth ? tableWidth : inner.dynamicWidth;
        const curDragLeft = this.calcDragLeft(inner.curKeyLeft, isMovingFixedKey);
        dragLineRef.setDragLeft(curDragLeft);
    }

    onDragEnd = props => {
        const {curAllColumnsWidth, curDynamicWidth} = this;
        const dragLineRef = this.dragLeftRef;
        dragLineRef.setShowLine(false);
        const {
            allColumnsWidth,
            dynamicWidth
        } = this.store.getState();
        this.store.setState({
            allColumnsWidth: curAllColumnsWidth || allColumnsWidth,
            dynamicWidth: curDynamicWidth || dynamicWidth,
            dragging: false
        });
        if (typeof this.props.onDragEnd === 'function') {
            this.props.onDragEnd(curAllColumnsWidth);
        }
        this.handleWindowScroll();
    }

    onHeaderCellMouseEnter = props => {
        if (!this.store.getState().dragging) {
            const {curKeyLeft, curColumn} = props;
            const dragLineRef = this.dragLeftRef;
            const curDragLeft = this.calcDragLeft(curKeyLeft, curColumn.fixed);
            dragLineRef.setDragLeft(curDragLeft);
            dragLineRef.setShowLine(true);
        }
    };

    onHeaderCellMouseLeave = () => {
        if (!this.store.getState().dragging) {
            const dragLineRef = this.dragLeftRef;
            dragLineRef.setShowLine(false);
        }
    };

    renderTable(options) {
        const {columns, fixed, isAnyColumnsFixed} = options;
        const {
            prefixCls, scroll = {},
            updateWidthChange, useStickyFixTop
        } = this.props;
        const tableClassName = scroll.x || fixed ? `${prefixCls}-fixed` : '';
        const headTable = (
            <HeadTable
                key="head"
                columns={columns}
                tableClassName={tableClassName}
                handleBodyScrollLeft={this.handleBodyScrollLeft}
                expander={this.expander}
                onDragStart={this.onDragStart}
                onDraging={this.onDraging}
                onDragEnd={this.onDragEnd}
                onHeaderCellMouseEnter={this.onHeaderCellMouseEnter}
                onHeaderCellMouseLeave={this.onHeaderCellMouseLeave}
                updateWidthChange={updateWidthChange}
                useStickyFixTop={useStickyFixTop}
            />
        );

        const bodyTable = (
            <BodyTable
                key="body"
                columns={columns}
                tableClassName={tableClassName}
                getRowKey={this.getRowKey}
                handleWheel={this.handleWheel}
                handleBodyScroll={this.handleBodyScroll}
                expander={this.expander}
                isAnyColumnsFixed={isAnyColumnsFixed}
                onDragStart={this.onDragStart}
                onDraging={this.onDraging}
                onDragEnd={this.onDragEnd}
                onHeaderCellMouseEnter={this.onHeaderCellMouseEnter}
                onHeaderCellMouseLeave={this.onHeaderCellMouseLeave}
            />
        );

        return [headTable, bodyTable];
    }

    renderBottomScroll() {
        const {bodyTable} = this;
        const prefixCls = this.props.prefixCls;
        const {style, bottom} = this.props.bottomScroll;
        const scrollContainerStyle = {
            ...style,
            bottom
        };
        if (bodyTable) {
            const {left, width} = bodyTable.getBoundingClientRect();
            scrollContainerStyle.width = width;
            scrollContainerStyle.left = left;
        }
        const allColumnsWidth = this.store.getState().allColumnsWidth;
        let tableWidth = 0;
        allColumnsWidth.forEach(col => {
            tableWidth += col.width;
        });
        const scrollContentStyle = {
            width: tableWidth
        };
        const bottomScroll = (
            <div
                className={`${prefixCls}-scroll-container`}
                style={scrollContainerStyle}
                ref={this.saveRef('bottomScroll')}
                onScroll={this.handleBodyScrollLeft}
            >
                <div
                    className={`${prefixCls}-scroll-content`}
                    style={scrollContentStyle}
                    ref={this.saveRef('bottomScrollContent')}
                />
            </div>
        );
        return bottomScroll;
    }

    renderTitle() {
        const {title, prefixCls} = this.props;
        return title ? (
            <div className={`${prefixCls}-title`} key="title">
                {title(this.props.data)}
            </div>
        ) : null;
    }

    renderFooter() {
        const {footer, prefixCls} = this.props;
        return footer ? (
            <div className={`${prefixCls}-footer`} key="footer">
                {footer(this.props.data)}
            </div>
        ) : null;
    }

    tableRef = ref => {
        this.tableContainerRef = ref;
    }

    saveDragLineRef = ref => {
        this.dragLeftRef = ref;
    }

    render() {
        const {
            prefixCls,
            className,
            children,
            columns,
            scroll,
            useFixedHeader,
            useStickyFixTop,
            headerFixTop,
            bottomScroll,
            id,
            style,
            loading,
            loadingOption,
            loadingText,
            size,
            ...resetProps
        } = this.props;
        if (this.state.columns) {
            this.columnManager.reset(columns);
        }

        const classNames = classnames(prefixCls, className, {
            [`${prefixCls}-fixed-header`]: useFixedHeader || (scroll && scroll.y),
            [`${prefixCls}-scroll-position-left`]: this.scrollPosition === 'both',
            [`${prefixCls}-scroll-position-right`]: this.scrollPosition === 'both',
            [`${prefixCls}-scroll-position-${this.scrollPosition}`]: this.scrollPosition !== 'both',
            [`${prefixCls}-sticky-top`]: useStickyFixTop && typeof headerFixTop === 'number'
        });
        const hasBottomScroll = this.state.isBottomScrollShow && bottomScroll.bottom !== null;

        return (
            <Provider store={this.store} ref={this.tableRef}>
                <Context.Provider value={this.getContext()}>
                    <div
                        ref={this.saveRef('tableNode')}
                        className={classNames}
                        style={style}
                        id={id}
                    >
                        {this.renderTitle()}
                        <div className={`${prefixCls}-content`}>
                            <ExpandableTable
                                prefixCls={prefixCls}
                                {...resetProps}
                                columns={columns}
                                columnManager={this.columnManager}
                                getRowKey={this.getRowKey}
                            >
                                {expander => this.renderMainTable(expander)}
                            </ExpandableTable>
                            {hasBottomScroll && this.renderBottomScroll()}
                            <DragLine prefixCls={prefixCls} ref={this.saveDragLineRef} />
                        </div>
                        {loading && loadingOption && loadingOption.type === 'spinner'
                            && (
                                <Loading
                                    className={`${prefixCls}-loading`}
                                    tip={loadingText}
                                    size={size}
                                >
                                    <span></span>
                                </Loading>
                            )
                        }
                    </div>
                </Context.Provider>
            </Provider>
        );
    }
}

export default ComponentTable;
