import React, { Component } from 'react';
import { FieldsStore } from './createFieldsStore';
import { FormField, FormOption, FormProps } from '../interface';
export interface FormState {
    fieldsStore: FieldsStore;
    submitting: boolean;
    formValidating: boolean;
    prevProps: FormProps;
    mapPropsToFields: (props: FormProps) => {
        [key: string]: FormField;
    };
}
export declare class BaseForm extends Component<FormProps, FormState> {
    static defaultProps: {
        mapProps: any;
        formPropName: string;
        size: string;
        fieldNameProp: string;
    };
    static contextType: React.Context<import("../context").FormContextProps>;
    constructor(props: any);
    form: any;
    fieldsStore: any;
    renderFields: any;
    domFields: any;
    clearedFieldMetaCache: any;
    instances: any;
    cachedBind: any;
    componentDidMount(): void;
    static getDerivedStateFromProps(props: any, state: any): {
        prevProps: any;
    };
    componentDidUpdate(): void;
    cleanUpUselessFields(): void;
    onCollectCommon(name: any, action: any, args: any): {
        name: any;
        field: any;
        fieldMeta: any;
    };
    onCollect(nameCurrent: any, action: any, ...args: any[]): void;
    onCollectValidate(nameCurrent: any, action: any, ...args: any[]): void;
    getCacheBind(name: any, action: any, fn: any): any;
    getFieldDecorator: (name: any, fieldOption: any) => (fieldElem: any) => React.DetailedReactHTMLElement<any, HTMLElement>;
    getFieldProps: (name: any, usersFieldOption: any) => any;
    getFieldInstance: (name: any) => any;
    getRules(fieldMeta: any, action: any): any;
    setFields: (maybeNestedFields: any, callback?: any) => void;
    setFieldsValue: (changedValues: any, callback: any) => void;
    setFieldsError: (errors: any, callback: any) => void;
    saveRef(name: any, _: any, component: any): void;
    clearField: (name: any) => void;
    resetFields: (ns?: any) => void;
    recoverClearedField(name: any): void;
    getAsyncValidator(rule: any, value: any, options: any): Promise<import("async-validator").Values>;
    mixValidateFields(rules: any, values: any, options: any): Promise<{
        errors: any[];
        warnings: any[];
        successes: any[];
    }>;
    validateFieldsInternal(fields: FormField[], fieldOptions: any, callback?: any): void;
    validateFields: (ns?: any, opt?: any, cb?: any) => Promise<unknown>;
    isSubmitting: () => boolean;
    submit: (callback: any) => void;
    validateFieldsAndScroll: (ns?: any, opt?: any, cb?: any) => Promise<unknown>;
    scrollToField: (name: string, options?: {
        container?: HTMLElement;
    }) => void;
    isFormValidating: () => boolean;
    validateForm: (scrollToError: any) => any;
    private getMessageGroup;
    private getFieldName;
    getForm(): {
        getFieldsValue: any;
        getFieldValue: any;
        getFieldInstance: (name: any) => any;
        setFieldsValue: (changedValues: any, callback: any) => void;
        setFieldsError: (errors: any, callback: any) => void;
        setFields: (maybeNestedFields: any, callback?: any) => void;
        setFieldsInitialValue: any;
        getFieldDecorator: (name: any, fieldOption: any) => (fieldElem: any) => React.DetailedReactHTMLElement<any, HTMLElement>;
        getFieldProps: (name: any, usersFieldOption: any) => any;
        getFieldsError: any;
        getFieldError: any;
        getFieldsSuccess: any;
        getFieldSuccess: any;
        getFieldsWarning: any;
        getFieldWarning: any;
        isFieldValidating: any;
        isFieldsValidating: any;
        isFieldsTouched: any;
        isFieldTouched: any;
        isSubmitting: () => boolean;
        submit: (callback: any) => void;
        validateForm: (scrollToError: any) => any;
        isFormValidating: () => boolean;
        validateFields: (ns?: any, opt?: any, cb?: any) => Promise<unknown>;
        resetFields: (ns?: any) => void;
        validateFieldsAndScroll: (ns?: any, opt?: any, cb?: any) => Promise<unknown>;
        scrollToField: (name: string, options?: {
            container?: HTMLElement;
        }) => void;
    };
    render(): JSX.Element;
}
declare const createBaseForm: (option?: FormOption) => (LegacyForm: any) => React.ForwardRefExoticComponent<React.RefAttributes<BaseForm>>;
export default createBaseForm;
