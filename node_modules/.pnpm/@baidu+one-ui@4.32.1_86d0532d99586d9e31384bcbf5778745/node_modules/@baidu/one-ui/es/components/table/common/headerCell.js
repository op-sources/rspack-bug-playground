import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _isEqual from "lodash/isEqual";
import React, { Component } from 'react';
import { onMouseDown as _onMouseDown } from '../../../core/dragTools';
import { classnames, isFocusable } from '../../../core/commonTools';
import shallowEqual from 'shallowequal';

var HeaderCell = /*#__PURE__*/function (_Component) {
  _inheritsLoose(HeaderCell, _Component);

  function HeaderCell() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.positionObj = void 0;
    _this.dragging = void 0;
    _this.cellRef = void 0;
    _this.customProps = void 0;

    _this.onDropped = function () {
      _this.positionObj = {
        position: {},
        cellWidth: _this.cellRef.offsetWidth
      };
      setTimeout(function () {
        _this.dragging = false;
      }, 0);

      _this.props.onDragEnd();
    };

    _this.onDragged = function (props) {
      _this.positionObj = {
        position: props.position,
        cellWidth: _this.cellRef.offsetWidth
      };
      _this.dragging = true;

      _this.props.onDragStart();
    };

    _this.onMoving = function (props) {
      var _this$props = _this.props,
          maxWidth = _this$props.maxWidth,
          minWidth = _this$props.minWidth;
      var mPos = props.position;
      var x = mPos.x;
      var _this$positionObj = _this.positionObj,
          position = _this$positionObj.position,
          cellWidth = _this$positionObj.cellWidth;
      var initialX = position.x;
      var newWidth;

      if (x > initialX) {
        newWidth = cellWidth + (x - initialX);
      } else if (x <= initialX) {
        newWidth = cellWidth - (initialX - x);
      }

      if (maxWidth && newWidth > maxWidth) {
        return;
      } else if (minWidth && newWidth < minWidth) {
        return;
      }

      _this.props.onMoving({
        key: _this.getKey(),
        width: newWidth
      });
    };

    _this.onMouseEnter = function () {
      if (typeof _this.props.onHeaderCellMouseEnter === 'function') {
        _this.props.onHeaderCellMouseEnter({
          key: _this.getKey()
        });
      }
    };

    _this.onMouseLeave = function () {
      if (typeof _this.props.onHeaderCellMouseLeave === 'function') {
        _this.props.onHeaderCellMouseLeave({
          key: _this.getKey()
        });
      }
    };

    _this.getCellRef = function (ref) {
      _this.cellRef = ref;
    };

    _this.onClick = function (e) {
      var _this$props2 = _this.props,
          column = _this$props2.column,
          prefixCls = _this$props2.prefixCls;

      if (!_this.dragging && e.target.className !== prefixCls + "-cell-drag-cursor" && insideUnfocusable(e.target, _this.cellRef) && column.toggleSortOrder) {
        column.toggleSortOrder(column);
      }

      if (_this.customProps.onClick) {
        _this.customProps.onClick(e);
      }
    };

    return _this;
  }

  var _proto = HeaderCell.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return !shallowEqual(nextProps, this.props, function (a, b, key) {
      if (key === 'column') {
        return _isEqual(a, b);
      }
    });
  };

  _proto.getKey = function getKey() {
    var _this$props$column = this.props.column,
        dataIndex = _this$props$column.dataIndex,
        key = _this$props$column.key;
    return key || dataIndex;
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props3 = this.props,
        className = _this$props3.className,
        render = _this$props3.render,
        prefixCls = _this$props3.prefixCls,
        column = _this$props3.column,
        index = _this$props3.index,
        left = _this$props3.left,
        width = _this$props3.width,
        dynamicWidth = _this$props3.dynamicWidth;
    var customProps = column.onHeaderCell ? column.onHeaderCell(column) : {};
    this.customProps = customProps;
    var cellStyle = customProps.style || {};

    if (left != null && column.fixed === 'left') {
      cellStyle.left = left - width;
    } else if (column.fixed === 'right' && left != null && dynamicWidth) {
      cellStyle.right = dynamicWidth - left < 0 ? 0 : dynamicWidth - left;
    }

    if (column.align) {
      cellStyle.textAlign = column.align;
    }

    var title = render ? render(column) : customProps.children;
    var Cell = /*#__PURE__*/React.createElement("th", _extends({}, customProps, {
      className: classnames(className, customProps.className),
      key: column.key || column.dataIndex || index,
      ref: this.getCellRef,
      style: cellStyle,
      onClick: this.onClick,
      rowSpan: column.rowSpan,
      colSpan: column.colSpan
    }), title, !column.colSpan && column.draggable ? /*#__PURE__*/React.createElement("span", {
      className: prefixCls + "-cell-drag-cursor",
      onMouseEnter: this.onMouseEnter,
      onMouseLeave: this.onMouseLeave,
      onMouseDown: function onMouseDown(event) {
        return _onMouseDown({
          event: event,
          onDropped: _this2.onDropped,
          onDragged: _this2.onDragged,
          onMoving: _this2.onMoving
        });
      }
    }) : null);
    return Cell;
  };

  return HeaderCell;
}(Component);

HeaderCell.defaultProps = {
  column: {}
};

function insideUnfocusable(el, context) {
  while (el) {
    if (isFocusable(el)) {
      return false;
    }

    if (el === context) {
      return true;
    }

    el = el.parentNode;
  }

  return false;
}

export default HeaderCell;