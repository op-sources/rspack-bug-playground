import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _identity from "lodash/identity";
import _noop from "lodash/noop";
import _findIndex from "lodash/findIndex";
import _map from "lodash/map";

var _dec, _class, _class2, _temp;

import React, { PureComponent } from 'react';
import UploaderAnchor from './common/uploaderAnchor';
import UploaderList from './common/uploaderList';
import Message from '../toast';
import { checkFileRules, originStatus, fileUploader, getUid, UPLOAD_STATUS_MAP, getAccept } from '../../core/uploaderTools';
import { classnames } from '../../core/commonTools';
import { withConfigConsumer } from '../providerConfig/context';
import omit from 'omit.js';
import { propChangeWarning } from '../../util/warning';

var defaultUploader = function defaultUploader(options) {
  var _options$file;

  var file = (_options$file = options.file) == null ? void 0 : _options$file.originFile;

  if (file) {
    options.file = file;
  }

  return fileUploader(options);
};

var Uploader = (_dec = withConfigConsumer('uploader'), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(Uploader, _PureComponent);

  function Uploader(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;
    _this.uploaderXhrMap = {};
    _this._fileList = void 0;
    _this.uploaderAnchorRef = void 0;
    _this.state = void 0;

    _this.onInputChange = function (e) {
      var files = e.target.files;
      var postFiles = Array.prototype.slice.call(files);
      var tempFiles = [];
      var _this$props = _this.props,
          maxParallelFileNumber = _this$props.maxParallelFileNumber,
          maxFileLength = _this$props.maxFileLength,
          maxFileLengthErrorMessage = _this$props.maxFileLengthErrorMessage;
      var _this$state = _this.state,
          insertImage = _this$state.insertImage,
          insetIndex = _this$state.insetIndex;

      if (maxParallelFileNumber && postFiles.length > maxParallelFileNumber) {
        Message.error({
          content: '超过最大可并行上传个数， 请重新选择...'
        });
        return;
      }

      var currentFileCount = !insertImage ? _this.state.fileList.length + postFiles.length : _this.state.fileList.length + postFiles.length - 1;

      if (maxFileLength && maxFileLength < currentFileCount) {
        // 存在限制文件上传的个数，并且不是图片重新上传的情况下，进行报错return
        Message.error({
          content: "" + maxFileLengthErrorMessage
        });
        return;
      }

      postFiles.forEach(function (file, index) {
        tempFiles.push({
          status: originStatus.WAITING,
          name: file.name,
          isNewUpload: true,
          originFile: file,
          uid: getUid(index),
          type: file.type
        });
      });

      var newFileList = _this._fileList.concat(tempFiles);

      if (insertImage) {
        var _newFileList;

        // 从中间插入
        newFileList = [].concat(_this._fileList);

        (_newFileList = newFileList).splice.apply(_newFileList, [insetIndex, 1].concat(tempFiles));
      }

      var _this$onValidatorFile = _this.onValidatorFiles(newFileList),
          _fileList = _this$onValidatorFile._fileList,
          allFailures = _this$onValidatorFile.allFailures;

      _this._fileList = _fileList;

      if (allFailures) {
        return;
      }

      var newUploadingFiles = _fileList.filter(function (file) {
        return file.status === originStatus.WAITING && file.isNewUpload;
      });

      newUploadingFiles.forEach(function (file) {
        _this.upload(file, newUploadingFiles);
      });
    };

    _this.upload = function (file, fileList) {
      if (!_this.props.beforeUpload) {
        return setTimeout(function () {
          return _this.post(file);
        }, 0);
      }

      var before = _this.props.beforeUpload(file, fileList);

      if (typeof before !== 'boolean' && before && before.then) {
        before.then(function (processedFile) {
          var processedFileType = Object.prototype.toString.call(processedFile);

          if (processedFileType === '[object File]' || processedFileType === '[object Blob]') {
            return _this.post(processedFile);
          }

          return _this.post(file);
        })["catch"](function (e) {});
      } else if (before !== false) {
        setTimeout(function () {
          return _this.post(file);
        }, 0);
      }
    };

    _this.post = function (file) {
      return new Promise(function () {
        var _this$props2 = _this.props,
            uploadResquestUrl = _this$props2.uploadResquestUrl,
            transformFile = _this$props2.transformFile,
            uploader = _this$props2.uploader,
            headers = _this$props2.headers,
            _this$props2$withCred = _this$props2.withCredentials,
            withCredentials = _this$props2$withCred === void 0 ? false : _this$props2$withCred,
            _this$props2$method = _this$props2.method,
            method = _this$props2$method === void 0 ? 'post' : _this$props2$method,
            reqData = _this$props2.reqData;
        var transform = Promise.resolve(transformFile(file));
        transform.then(function (transformedFile) {
          var requestOption = {
            action: uploadResquestUrl,
            filename: file.name,
            reqData: reqData,
            file: transformedFile,
            headers: headers,
            withCredentials: withCredentials,
            method: method || 'post',
            onProgress: function onProgress(e) {
              _this.onProgress(e, file);
            },
            onSuccess: function onSuccess(ret) {
              _this.onSuccess(ret, file);
            },
            onError: function onError(err, ret) {
              _this.onError(err, ret, file);
            }
          };
          _this.uploaderXhrMap[file && file.uid] = uploader(requestOption);

          _this.onStart(file);
        });
      });
    };

    _this.getFileIndex = function (file) {
      var uid = file.uid;
      var fileList = [].concat(_this.state.fileList);

      var currentFileIndex = _findIndex(fileList, function (file) {
        return file.uid === uid;
      });

      return currentFileIndex;
    };

    _this.onProgress = function (e, file) {
      var percent = e.percent;
      var fileList = [].concat(_this.state.fileList);

      var currentFileIndex = _this.getFileIndex(file);

      if (fileList[currentFileIndex]) {
        fileList[currentFileIndex].progressStep = percent - 1;
      }

      _this.props.onChange({
        index: currentFileIndex,
        file: file,
        fileList: fileList
      });

      if (!('fileList' in _this.props)) {
        _this.setState({
          fileList: fileList
        });
      }
    };

    _this.onSuccess = function (ret, file) {
      var fileList = [].concat(_this.state.fileList);

      var currentFileIndex = _this.getFileIndex(file);

      if (fileList[currentFileIndex]) {
        fileList[currentFileIndex].status = originStatus.SUCCESS;
      }

      var _this$props3 = _this.props,
          afterUpload = _this$props3.afterUpload,
          onChange = _this$props3.onChange;

      if (afterUpload) {
        Object.assign(file, afterUpload(ret, file, fileList));
      }

      onChange({
        index: currentFileIndex,
        file: file,
        fileList: fileList,
        response: ret
      });

      if (!('fileList' in _this.props)) {
        _this.setState({
          fileList: fileList
        });
      }
    };

    _this.onError = function (err, ret, file) {
      var fileList = [].concat(_this.state.fileList);

      var currentFileIndex = _this.getFileIndex(file);

      if (fileList[currentFileIndex]) {
        fileList[currentFileIndex].status = originStatus.ERROR;
        fileList[currentFileIndex].errorMessage = [UPLOAD_STATUS_MAP.UPLOAD_ERROR.error.msg];
      }

      _this.props.onChange({
        index: currentFileIndex,
        file: file,
        fileList: fileList,
        err: err,
        response: ret
      });

      if (!('fileList' in _this.props)) {
        _this.setState({
          fileList: fileList
        });
      }
    };

    _this.onStart = function (file) {
      var fileList = [].concat(_this.state.fileList);

      var currentFileIndex = _this.getFileIndex(file);

      if (fileList[currentFileIndex]) {
        fileList[currentFileIndex].status = originStatus.UPLOADING;
        fileList[currentFileIndex].progressStep = 0;
      }

      _this.props.onChange({
        index: currentFileIndex,
        file: file,
        fileList: fileList
      });

      if (!('fileList' in _this.props)) {
        _this.setState({
          fileList: fileList
        });
      }
    };

    _this.onValidatorFiles = function (files) {
      var _fileList = [].concat(files);

      var allFailures = true;

      _fileList.forEach(function (file, index) {
        if (file.status === originStatus.WAITING && file.isNewUpload) {
          var errors = _this.onValidatorSingleFile(file.originFile);

          var hasError = errors.length;
          _fileList[index] = _extends({}, _fileList[index], {
            status: hasError ? originStatus.ERROR : originStatus.WAITING
          });

          if (hasError) {
            _fileList[index].errorMessage = errors;
          } else {
            _fileList[index].progressStep = 0;
          }

          _this.props.onChange({
            index: index,
            fileList: _fileList,
            file: _fileList[index].originFile
          });

          if (!hasError) {
            allFailures = false;
          }
        }
      });

      if (!('fileList' in _this.props)) {
        _this.setState({
          fileList: _fileList
        });
      }

      return {
        allFailures: allFailures,
        _fileList: _fileList
      };
    };

    _this.onValidatorSingleFile = function (file) {
      var errorMessages = [];
      var _this$props4 = _this.props,
          accept = _this$props4.accept,
          maxSize = _this$props4.maxSize,
          validator = _this$props4.validator,
          listType = _this$props4.listType;

      _map(checkFileRules, function (checkFileRule) {
        if (checkFileRule.match({
          file: file,
          options: {
            accept: getAccept(accept, listType),
            maxSize: maxSize
          }
        })) {
          errorMessages.push(checkFileRule.error.error.msg);
        }
      });

      if (validator) {
        var msg = validator(file);

        if (msg) {
          errorMessages.push(msg);
        }
      }

      return errorMessages;
    };

    _this.onRemove = function (_ref) {
      var fileList = _ref.fileList,
          index = _ref.index,
          _ref$originFileList = _ref.originFileList,
          originFileList = _ref$originFileList === void 0 ? [] : _ref$originFileList;
      var curFile = originFileList[index];

      if (curFile && curFile.status === originStatus.UPLOADING && _this.uploaderXhrMap[curFile.uid] && typeof _this.uploaderXhrMap[curFile.uid].abort === 'function') {
        // 对于删除正在上传的组件，应该直接abort
        _this.uploaderXhrMap[curFile.uid].abort();
      }

      if (!('fileList' in _this.props)) {
        _this.setState({
          fileList: fileList
        });
      }

      _this._fileList = [].concat(fileList);

      if (_this.props.useInForm) {
        _this.props.onChange({
          fileList: fileList,
          index: index
        });
      }

      _this.props.onRemove({
        fileList: fileList,
        index: index
      });
    };

    _this.onSort = function (fileList) {
      _this.props.onChange({
        fileList: fileList
      });

      if (!('fileList' in _this.props)) {
        _this.setState({
          fileList: fileList
        });
      }
    };

    _this.onInsertImage = function (insertImage, index) {
      _this.setState({
        insertImage: insertImage,
        insetIndex: index
      });

      _this.uploaderAnchorRef.uploadInputRef.value = '';

      _this.uploaderAnchorRef.uploadInputRef.click();
    };

    _this.onPickerClick = function () {
      _this.setState({
        insertImage: false
      });

      var onPickerClick = _this.props.onPickerClick;

      if (onPickerClick) {
        return onPickerClick();
      }
    };

    _this.uploadAnchorRef = function (ref) {
      _this.uploaderAnchorRef = ref;
    };

    propChangeWarning('Uploader', props, {
      'helperTextPostion': 'helperTextPosition',
      'showUploadListIcon': 'controls',
      'customUploadListIcon': 'controls',
      'CustomUploadAnchor': 'CustomUploadPicker',
      'order': 'pickerPosition',
      'hideAnchor': 'hidePicker',
      'formatUploadAnchor': 'picker'
    });

    var _fileList2 = props.fileList || props.defaultFileList || [];

    _this.state = {
      fileList: _fileList2,
      insertImage: false,
      insetIndex: 0
    };
    _this._fileList = _fileList2;
    return _this;
  }

  var _proto = Uploader.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.fileList && this.props.fileList !== prevProps.fileList) {
      this._fileList = [].concat(this.props.fileList);
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.uploaderXhrMap = {};
  };

  _proto.normalizePickerPosition = function normalizePickerPosition() {
    var _this$props5 = this.props,
        hideAnchor = _this$props5.hideAnchor,
        hidePicker = _this$props5.hidePicker,
        order = _this$props5.order,
        pickerPosition = _this$props5.pickerPosition,
        listType = _this$props5.listType;

    if (hideAnchor === true || hidePicker === true) {
      return 'none';
    }

    if (listType === 'image' && order === 'reverse') {
      return 'before';
    }

    if (listType === 'file' && order === 'reverse') {
      return 'after';
    }

    if (!pickerPosition) {
      if (listType === 'file') {
        return 'before';
      }

      return 'after';
    }

    return pickerPosition;
  };

  _proto.render = function render() {
    var _classnames;

    var _this$props6 = this.props,
        prefixCls = _this$props6.prefixCls,
        className = _this$props6.className,
        listType = _this$props6.listType,
        onPreview = _this$props6.onPreview,
        onReUpload = _this$props6.onReUpload,
        size = _this$props6.size,
        formatUploadAnchor = _this$props6.formatUploadAnchor,
        picker = _this$props6.picker,
        sortable = _this$props6.sortable,
        helperTextPosition = _this$props6.helperTextPosition,
        helperTextPostion = _this$props6.helperTextPostion;
    var fileList = this.state.fileList;
    var pickerPosition = this.normalizePickerPosition();
    var showType = listType === 'file' ? 'file' : 'image';
    var uploadClassNames = classnames(prefixCls, className, prefixCls + "-picker-position-" + pickerPosition, (_classnames = {}, _classnames[prefixCls + "-" + size] = listType !== 'file', _classnames[prefixCls + "-image"] = showType === 'image', _classnames));
    var uploadPicker = /*#__PURE__*/React.createElement(UploaderAnchor, _extends({
      key: "uploader-anchor"
    }, this.props, {
      pickerPosition: pickerPosition,
      helperTextPosition: helperTextPostion || helperTextPosition,
      ref: this.uploadAnchorRef,
      onChange: this.onInputChange,
      onPickerClick: this.onPickerClick,
      listType: showType,
      realType: listType,
      fileList: fileList
    }));

    if (formatUploadAnchor && typeof formatUploadAnchor === 'function') {
      uploadPicker = formatUploadAnchor(uploadPicker);
    }

    if (picker && typeof picker === 'function') {
      uploadPicker = picker(uploadPicker);
    }

    if (showType === 'image') {
      return /*#__PURE__*/React.createElement("div", {
        className: uploadClassNames
      }, /*#__PURE__*/React.createElement(UploaderList, _extends({
        key: "uploader-list"
      }, this.props, {
        fileList: fileList,
        onRemove: this.onRemove,
        onPreview: onPreview,
        onReUpload: onReUpload,
        onSort: this.onSort,
        sortable: sortable,
        onInsertImage: this.onInsertImage,
        listType: showType,
        realType: listType,
        picker: uploadPicker,
        pickerPosition: pickerPosition
      })));
    }

    var renders = [uploadPicker, /*#__PURE__*/React.createElement(UploaderList, _extends({
      key: "upload-list"
    }, omit(this.props, ['picker']), {
      fileList: fileList,
      onSort: this.onSort,
      onRemove: this.onRemove,
      listType: showType,
      realType: listType,
      pickerPosition: pickerPosition
    }))];
    return /*#__PURE__*/React.createElement("div", {
      className: uploadClassNames
    }, pickerPosition === 'after' ? renders.reverse() : renders);
  };

  return Uploader;
}(PureComponent), _class2.defaultProps = {
  disabled: false,
  sortable: false,
  listType: 'file',
  timeout: 3000,
  multiple: false,
  className: '',
  prefixCls: 'one-uploader',
  inputControlName: 'file',
  loading: false,
  helperTextPosition: 'right',
  onRemove: _noop,
  onChange: _noop,
  transformFile: _identity,
  uploader: defaultUploader,
  maxFileLengthErrorMessage: '已超出文件最大上传个数，请删除后重新上传',
  useInForm: false,
  size: 'medium',
  errorDisplay: 'popup'
}, _class2.getDerivedStateFromProps = function (nextProps, prevState) {
  if ('fileList' in nextProps && nextProps.fileList !== prevState.fileList) {
    return {
      fileList: nextProps.fileList
    };
  }

  return null;
}, _temp)) || _class);
export default Uploader;