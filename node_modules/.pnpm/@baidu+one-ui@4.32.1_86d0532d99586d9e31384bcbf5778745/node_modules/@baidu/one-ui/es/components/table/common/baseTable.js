import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _findIndex from "lodash/findIndex";
import React, { PureComponent, useLayoutEffect, useState } from 'react';
import { connect } from 'mini-store';
import ColGroup from './colGroup';
import TableHeader from './tableHeader';
import TableRow from './tableRow';
import ExpandableRow from './expandableRow';
import { formatTableWidthWithAllColumnsWidth, formatCellLeft } from './utils';
import Context from './context';
import classNames from 'classnames';
;

var Empty = function Empty(_ref) {
  var _classNames;

  var empty = _ref.empty,
      containerWidth = _ref.containerWidth,
      prefixCls = _ref.prefixCls,
      loading = _ref.loading,
      table = _ref.table;

  var _useState = useState(containerWidth),
      width = _useState[0],
      setWidth = _useState[1];

  useLayoutEffect(function () {
    var handle;

    if (containerWidth === 0 && table.bodyTable) {
      handle = requestAnimationFrame(function () {
        handle = requestAnimationFrame(function () {
          setWidth(table.bodyTable.offsetWidth || 'auto');
        });
      });
    } else {
      setWidth(containerWidth);
    }

    return function () {
      return cancelAnimationFrame(handle);
    };
  }, [containerWidth]);
  return /*#__PURE__*/React.createElement("div", {
    className: classNames(prefixCls + "-placeholder", (_classNames = {}, _classNames[prefixCls + "-loading-tip"] = loading, _classNames)),
    style: {
      width: width
    }
  }, empty);
};

var BaseTable = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(BaseTable, _PureComponent);

  function BaseTable() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _PureComponent.call.apply(_PureComponent, [this].concat(args)) || this;

    _this.renderRows = function (renderData, indent, ancestorKeys) {
      if (ancestorKeys === void 0) {
        ancestorKeys = [];
      }

      var table = _this.context.table;
      var columnManager = table.columnManager;
      var _table$props = table.props,
          prefixCls = _table$props.prefixCls,
          childrenColumnName = _table$props.childrenColumnName,
          rowClassName = _table$props.rowClassName,
          rowRef = _table$props.rowRef,
          onRowClick = _table$props.onRowClick,
          onRowDoubleClick = _table$props.onRowDoubleClick,
          onRowContextMenu = _table$props.onRowContextMenu,
          onRowMouseEnter = _table$props.onRowMouseEnter,
          onRowMouseLeave = _table$props.onRowMouseLeave,
          onRow = _table$props.onRow;
      var _this$props = _this.props,
          getRowKey = _this$props.getRowKey,
          fixed = _this$props.fixed,
          expander = _this$props.expander,
          isAnyColumnsFixed = _this$props.isAnyColumnsFixed;
      var rows = [];
      var leafColumns;

      if (fixed === 'left') {
        leafColumns = columnManager.leftLeafColumns();
      } else if (fixed === 'right') {
        leafColumns = columnManager.rightLeafColumns();
      } else {
        leafColumns = columnManager.leafColumns();
      }

      var columns = leafColumns.map(function (o) {
        return {
          key: o.key,
          className: o.className,
          fixed: o.fixed,
          align: o.align,
          render: o.render,
          dataIndex: o.dataIndex,
          onCell: o.onCell,
          onCellClick: o.onCellClick
        };
      });
      var rowPrefixCls = prefixCls + "-row";

      var _loop = function _loop(i) {
        var record = renderData[i];
        var key = getRowKey(record, i);
        var className = typeof rowClassName === 'string' ? rowClassName : rowClassName(record, i, indent);
        var row = /*#__PURE__*/React.createElement(ExpandableRow, _extends({}, expander.props, {
          fixed: fixed,
          index: i,
          prefixCls: rowPrefixCls,
          record: record,
          key: key,
          rowKey: key,
          onRowClick: onRowClick,
          needIndentSpaced: expander.needIndentSpaced,
          onExpandedChange: expander.handleExpandChange,
          indent: indent
        }), function (expandableRow) {
          return /*#__PURE__*/React.createElement(TableRow, _extends({
            fixed: fixed,
            indent: indent,
            className: className,
            record: record,
            index: i,
            prefixCls: rowPrefixCls,
            childrenColumnName: childrenColumnName,
            columns: columns,
            onRow: onRow,
            onRowDoubleClick: onRowDoubleClick,
            onRowContextMenu: onRowContextMenu,
            onRowMouseEnter: onRowMouseEnter,
            onRowMouseLeave: onRowMouseLeave,
            rowKey: key,
            ancestorKeys: ancestorKeys,
            ref: rowRef(record, i, indent),
            isAnyColumnsFixed: isAnyColumnsFixed
          }, expandableRow));
        });
        rows.push(row);
        expander.renderRows(_this.renderRows, rows, record, i, indent, fixed, key, ancestorKeys);
      };

      for (var i = 0; i < renderData.length; i++) {
        _loop(i);
      }

      if (rows.length === 0) {
        rows.push(_this.renderEmpty(leafColumns.length));
      }

      return rows;
    };

    _this.renderEmpty = function (colSpan) {
      var table = _this.context.table;
      var props = table.props,
          containerWidth = table.containerWidth;
      var prefixCls = props.prefixCls,
          emptyText = props.emptyText,
          loading = props.loading,
          loadingOption = props.loadingOption,
          loadingText = props.loadingText;
      var empty;

      if (loading && (!loadingOption || loadingOption.type !== 'spinner')) {
        empty = loadingText;
      } else {
        empty = typeof emptyText === 'function' ? emptyText() : emptyText;
      }

      ;
      return /*#__PURE__*/React.createElement("tr", {
        key: "empty-row",
        className: prefixCls + "-row-placeholder"
      }, /*#__PURE__*/React.createElement("td", {
        colSpan: colSpan
      }, /*#__PURE__*/React.createElement(Empty, {
        prefixCls: prefixCls,
        loading: loading,
        empty: empty,
        containerWidth: containerWidth,
        table: table
      })));
    };

    _this.onMoving = function (props) {
      var _this$props2 = _this.props,
          allColumnsWidth = _this$props2.allColumnsWidth,
          onDraging = _this$props2.onDraging;
      var columnsWidth = [].concat(allColumnsWidth);
      var dynamicWidth = 0;

      var index = _findIndex(columnsWidth, {
        key: props.key
      });

      var newObj = _extends({}, columnsWidth[index], {
        width: props.width,
        dragged: true
      });

      columnsWidth.splice(index, 1, newObj);
      var prevLeft = 0;
      var curKeyLeft = 0;
      var newAllColumnsWidth = columnsWidth.map(function (col) {
        prevLeft = formatCellLeft(col.width, prevLeft);
        dynamicWidth += col.width;

        if (col.key === props.key) {
          curKeyLeft = prevLeft;
        }

        return _extends({}, col, {
          left: prevLeft
        });
      });

      if (typeof onDraging === 'function') {
        onDraging({
          curColumn: _extends({}, props, {
            fixed: newObj.fixed
          }),
          allColumns: newAllColumnsWidth,
          inner: {
            dynamicWidth: dynamicWidth,
            curKeyLeft: curKeyLeft
          }
        });
      }
    };

    _this.onDragEnd = function () {
      var onDragEnd = _this.props.onDragEnd;

      if (typeof onDragEnd === 'function') {
        onDragEnd({
          inner: {
            showLine: false
          }
        });
      }
    };

    _this.onDragStart = function (props) {
      var onDragStart = _this.props.onDragStart;

      if (typeof onDragStart === 'function') {
        onDragStart({
          inner: {
            showLine: true
          }
        });
      }
    };

    _this.onHeaderCellMouseEnter = function (props) {
      var _this$props3 = _this.props,
          allColumnsWidth = _this$props3.allColumnsWidth,
          onHeaderCellMouseEnter = _this$props3.onHeaderCellMouseEnter;

      if (typeof onHeaderCellMouseEnter === 'function') {
        var _index = _findIndex(allColumnsWidth, {
          key: props.key
        });

        var prevLeft = 0;
        var curKeyLeft = 0;
        allColumnsWidth.forEach(function (col) {
          prevLeft = formatCellLeft(col.width, prevLeft);

          if (col.key === props.key) {
            curKeyLeft = prevLeft;
          }
        });
        onHeaderCellMouseEnter({
          key: props.key,
          curKeyLeft: curKeyLeft,
          curColumn: allColumnsWidth[_index]
        });
      }
    };

    _this.onHeaderCellMouseLeave = function () {
      var onHeaderCellMouseLeave = _this.props.onHeaderCellMouseLeave;

      if (typeof onHeaderCellMouseLeave === 'function') {
        onHeaderCellMouseLeave({
          inner: {
            showLine: false
          }
        });
      }
    };

    _this.tableRef = void 0;

    _this.getRef = function (ref) {
      _this.tableRef = ref;
    };

    return _this;
  }

  var _proto = BaseTable.prototype;

  _proto.render = function render() {
    var table = this.context.table;
    var _table$props2 = table.props,
        prefixCls = _table$props2.prefixCls,
        scroll = _table$props2.scroll,
        data = _table$props2.data,
        getBodyWrapper = _table$props2.getBodyWrapper;
    var _this$props4 = this.props,
        expander = _this$props4.expander,
        tableClassName = _this$props4.tableClassName,
        hasHead = _this$props4.hasHead,
        hasBody = _this$props4.hasBody,
        fixed = _this$props4.fixed,
        columns = _this$props4.columns,
        dynamicWidth = _this$props4.dynamicWidth,
        allColumnsWidth = _this$props4.allColumnsWidth,
        fixedHeader = _this$props4.fixedHeader;
    var tableStyle = {};

    if (!fixed && scroll.x) {
      tableStyle.tableLayout = 'fixed';
    }

    tableStyle.width = dynamicWidth || scroll && scroll.x || formatTableWidthWithAllColumnsWidth(allColumnsWidth) || '100%';
    var body;

    if (hasBody) {
      body = /*#__PURE__*/React.createElement("tbody", {
        className: prefixCls + "-tbody"
      }, this.renderRows(data, 0));

      if (getBodyWrapper) {
        body = getBodyWrapper(body);
      }
    }

    return [/*#__PURE__*/React.createElement("table", {
      className: tableClassName,
      style: tableStyle,
      key: "table",
      ref: this.getRef
    }, /*#__PURE__*/React.createElement(ColGroup, {
      columns: columns,
      fixed: fixed
    }), hasHead && /*#__PURE__*/React.createElement(TableHeader, {
      expander: expander,
      columns: columns,
      fixed: fixed,
      fixedHeader: fixedHeader,
      onMoving: this.onMoving,
      onDragEnd: this.onDragEnd,
      onDragStart: this.onDragStart,
      onHeaderCellMouseEnter: this.onHeaderCellMouseEnter,
      onHeaderCellMouseLeave: this.onHeaderCellMouseLeave
    }), body)];
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    if (!this.props.hasBody) {
      return;
    }

    var trackBodyUpdate = this.context.table.props.trackBodyUpdate;

    if (trackBodyUpdate) {
      trackBodyUpdate();
    }
  };

  return BaseTable;
}(PureComponent);

BaseTable.contextType = Context;
export default connect(function (state) {
  return {
    allColumnsWidth: state.allColumnsWidth,
    dynamicWidth: state.dynamicWidth
  };
})(BaseTable);