import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _noop from "lodash/noop";
import _throttle from "lodash/throttle";

var _dec, _class, _class2, _temp;

import React, { Component } from 'react';
import addEventListener from 'rc-util/lib/Dom/addEventListener';
import shallowequal from 'shallowequal';
import omit from 'omit.js';
import { classnames } from '../../core/commonTools';
import { getScroll } from '../../core/affixTools';
import { withConfigConsumer } from '../providerConfig/context';

var getTargetRect = function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    left: 0,
    bottom: 0
  };
};

var getOffset = function getOffset(element, target) {
  var elemRect = element.getBoundingClientRect();
  var targetRect = getTargetRect(target);
  var scrollTop = getScroll(target, true);
  var scrollLeft = getScroll(target, false);
  var docElem = window.document.body;
  var clientTop = docElem.clientTop || 0;
  var clientLeft = docElem.clientLeft || 0;
  return {
    top: elemRect.top - targetRect.top + (scrollTop - clientTop),
    left: elemRect.left - targetRect.left + (scrollLeft - clientLeft),
    width: elemRect.width,
    height: elemRect.height
  };
};

var Affix = (_dec = withConfigConsumer('affix'), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(Affix, _Component);

  function Affix() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
    _this.timeout = void 0;
    _this.fixedNode = void 0;
    _this.affixNode = void 0;
    _this.state = {
      affixStyle: null,
      placeholderStyle: null
    };

    _this.setTargetEventListeners = function (getTarget) {
      var target = getTarget();

      if (!target) {
        return;
      }

      _this.clearEventListeners();

      _this.events.forEach(function (eventName) {
        _this.eventHandlers[eventName] = addEventListener(target, eventName, _throttle(_this.updatePosition, 10));
      });
    };

    _this.setAffixStyle = function (eventType, affixStyle) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          target = _this$props.target;
      var originalAffixStyle = _this.state.affixStyle;
      var isWindow = target() === window;

      if (eventType === 'scroll' && originalAffixStyle && affixStyle && isWindow) {
        return;
      }

      if (shallowequal(affixStyle, originalAffixStyle)) {
        return;
      }

      _this.setState({
        affixStyle: affixStyle
      }, function () {
        var affixed = !!_this.state.affixStyle;

        if (affixStyle && !originalAffixStyle || !affixStyle && originalAffixStyle) {
          onChange(affixed);
        }
      });
    };

    _this.saveAffixNode = function (affixNode) {
      _this.affixNode = affixNode;
    };

    _this.setPlaceholderStyle = function (placeholderStyle) {
      var originalPlaceholderStyle = _this.state.placeholderStyle;

      if (shallowequal(placeholderStyle, originalPlaceholderStyle)) {
        return;
      }

      _this.setState({
        placeholderStyle: placeholderStyle
      });
    };

    _this.getFixedNode = function (node) {
      _this.fixedNode = node;
    };

    _this.updatePosition = function (event) {
      if (!_this.fixedNode) {
        return;
      }

      var eventType = null;

      if (event) {
        eventType = event.type;
      }

      var _this$props2 = _this.props,
          offsetBottom = _this$props2.offsetBottom,
          target = _this$props2.target,
          zIndex = _this$props2.zIndex;
      var offsetTop = _this.props.offsetTop;
      var targetNode = target();
      var scrollTop = getScroll(targetNode, true);
      var elemOffset = getOffset(_this.affixNode, targetNode);
      var elemSize = {
        width: _this.fixedNode.offsetWidth,
        height: _this.fixedNode.offsetHeight
      };
      var offsetMode = {
        top: false,
        bottom: false
      };

      if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {
        offsetMode.top = true;
        offsetTop = 0;
      } else {
        offsetMode.top = typeof offsetTop === 'number';
        offsetMode.bottom = typeof offsetBottom === 'number';
      }

      var targetRect = getTargetRect(targetNode);
      var targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;

      if (offsetMode.top && scrollTop > elemOffset.top - offsetTop) {
        // Fixed Top
        var width = elemOffset.width;

        _this.setAffixStyle(eventType, {
          position: 'fixed',
          top: targetRect.top + offsetTop,
          left: targetRect.left + elemOffset.left,
          width: width,
          zIndex: zIndex
        });

        _this.setPlaceholderStyle({
          width: width,
          height: elemSize.height
        });
      } else if (offsetMode.bottom && scrollTop < elemOffset.top + elemSize.height + (offsetBottom - targetInnerHeight)) {
        var targetBottomOffet = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;
        var _width = elemOffset.width;

        _this.setAffixStyle(eventType, {
          position: 'fixed',
          bottom: targetBottomOffet + offsetBottom,
          left: targetRect.left + elemOffset.left,
          width: _width,
          zIndex: zIndex
        });

        _this.setPlaceholderStyle({
          width: _width,
          height: elemOffset.height
        });
      } else {
        var affixStyle = _this.state.affixStyle;
        var affixNodeOffsetWidth = _this.affixNode.offsetWidth;

        if (eventType === 'resize' && affixStyle && affixStyle.position === 'fixed' && affixNodeOffsetWidth) {
          _this.setAffixStyle(eventType, _extends({}, affixStyle, {
            width: affixNodeOffsetWidth
          }));
        } else {
          _this.setAffixStyle(eventType, null);
        }

        _this.setPlaceholderStyle(null);
      }
    };

    _this.eventHandlers = {};

    _this.clearEventListeners = function () {
      _this.events.forEach(function (eventName) {
        var handler = _this.eventHandlers[eventName];

        if (handler && handler.remove) {
          handler.remove();
        }
      });
    };

    _this.events = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];
    return _this;
  }

  var _proto = Affix.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var target = this.props.target;
    this.timeout = setTimeout(function () {
      _this2.setTargetEventListeners(target);

      _this2.updatePosition();
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.target !== prevProps.target) {
      this.clearEventListeners();
      this.setTargetEventListeners(this.props.target);
    }

    this.updatePosition();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.clearEventListeners();
    clearTimeout(this.timeout);
  };

  _proto.render = function render() {
    var _classnames;

    var _this$state = this.state,
        affixStyle = _this$state.affixStyle,
        placeholderStyle = _this$state.placeholderStyle;
    var _this$props3 = this.props,
        prefixCls = _this$props3.prefixCls,
        style = _this$props3.style,
        children = _this$props3.children;
    var className = classnames((_classnames = {}, _classnames[prefixCls] = affixStyle, _classnames));
    var props = omit(this.props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'zIndex']);
    return /*#__PURE__*/React.createElement("div", _extends({}, props, {
      style: style,
      ref: this.saveAffixNode
    }), placeholderStyle && /*#__PURE__*/React.createElement("div", {
      "aria-hidden": true,
      style: placeholderStyle
    }), /*#__PURE__*/React.createElement("div", {
      className: className,
      ref: this.getFixedNode,
      style: affixStyle
    }, children));
  };

  return Affix;
}(Component), _class2.defaultProps = {
  prefixCls: 'one-affix',
  target: function target() {
    return window;
  },
  onChange: _noop,
  zIndex: 1
}, _temp)) || _class);
export default Affix;