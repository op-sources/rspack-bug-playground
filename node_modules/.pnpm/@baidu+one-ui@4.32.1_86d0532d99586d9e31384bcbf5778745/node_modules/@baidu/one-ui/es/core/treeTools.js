function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import toArray from './childrenTools';
import warning from 'warning';
var DRAG_SIDE_RANGE = 0.25;
var DRAG_MIN_GAP = 2;
var onlyTreeNodeWarned = false;
export function warnOnlyTreeNode() {
  if (onlyTreeNodeWarned) {
    return;
  }

  ;
  onlyTreeNodeWarned = true;
  warning(false, 'Tree only accept TreeNode as children.');
}
export function arrDel(list, value) {
  var clone = list.slice();
  var index = clone.indexOf(value);

  if (index >= 0) {
    clone.splice(index, 1);
  }

  return clone;
}
export function arrAdd(list, value) {
  var clone = list.slice();

  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }

  return clone;
}
export function posToArr(pos) {
  return pos.split('-');
}
export function getPosition(level, index) {
  return level + "-" + index;
}
export function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
export function getNodeChildren(children) {
  return toArray(children).filter(isTreeNode);
}
export function isCheckDisabled(node) {
  var _ref = node.props || {},
      disabled = _ref.disabled,
      disableCheckbox = _ref.disableCheckbox;

  return !!(disabled || disableCheckbox);
}
export function traverseTreeNodes(treeNodes, callback) {
  function processNode(node, index, parent) {
    var children = node ? node.props.children : treeNodes;
    var pos = node ? getPosition(parent.pos, index) : 0; // Filter children

    var childList = getNodeChildren(children); // Process node if is not root

    if (node) {
      var data = {
        node: node,
        index: index,
        pos: pos,
        key: node.key || pos,
        pkey: parent.key
      };
      callback(data);
    } // Process children node


    childList.forEach(function (subNode, subIndex) {
      return processNode(subNode, subIndex, {
        key: node ? node.key || pos : null,
        pos: pos
      });
    });
  }

  processNode(null);
}
/**
 * Use `rc-util` `toArray` to get the children list which keeps the key.
 * And return single node if children is only one(This can avoid `key` missing check).
 */

export function mapChildren(children, func) {
  var list = toArray(children).map(func);

  if (list.length === 1) {
    return list[0];
  }

  return list;
}
export function getDragNodesKeys(treeNodes, node) {
  var _node$props = node.props,
      eventKey = _node$props.eventKey,
      pos = _node$props.pos;
  var dragNodesKeys = [];
  traverseTreeNodes(treeNodes, function (_ref2) {
    var key = _ref2.key;
    dragNodesKeys.push(key);
  });
  dragNodesKeys.push(eventKey || pos);
  return dragNodesKeys;
} // Only used when drag, not affect SSR.

export function calcDropPosition(event, treeNode) {
  var clientY = event.clientY;

  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),
      top = _treeNode$selectHandl.top,
      bottom = _treeNode$selectHandl.bottom,
      height = _treeNode$selectHandl.height;

  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);

  if (clientY <= top + des) {
    return -1;
  } else if (clientY >= bottom - des) {
    return 1;
  }

  return 0;
}
/**
 * Return selectedKeys according with multiple prop
 * @param selectedKeys
 * @param props
 * @returns [string]
 */

export function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) {
    return undefined;
  }

  var multiple = props.multiple;

  if (multiple) {
    return selectedKeys.slice();
  }

  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }

  return selectedKeys;
}
/**
 * Since React internal will convert key to string,
 * we need do this to avoid `checkStrictly` use number match
 */

function keyListToString(keyList) {
  if (!keyList) {
    return keyList;
  }

  return keyList.map(function (key) {
    return String(key);
  });
} // TODO: ========================= NEW LOGIC =========================

/**
 * Calculate treeNodes entities. `processTreeEntity` is used for `rc-tree-select`
 * @param treeNodes
 * @param processTreeEntity  User can customize the entity
 */


export function convertTreeToEntities(treeNodes, _temp) {
  var _ref3 = _temp === void 0 ? {} : _temp,
      initWrapper = _ref3.initWrapper,
      processEntity = _ref3.processEntity,
      onProcessFinished = _ref3.onProcessFinished;

  var keyEntities = {};
  var wrapper = {
    keyEntities: keyEntities
  };

  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }

  traverseTreeNodes(treeNodes, function (item) {
    var node = item.node,
        index = item.index,
        pos = item.pos,
        key = item.key,
        pkey = item.pkey;
    var entity = {
      node: node,
      index: index,
      key: key,
      pos: pos
    };
    keyEntities[key] = entity; // Fill children

    entity.parent = keyEntities[pkey];

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }

    if (processEntity) {
      processEntity(entity, wrapper);
    }
  });

  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }

  return wrapper;
}
/**
 * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
 */

export function parseCheckedKeys(keys) {
  if (!keys) {
    return null;
  } // Convert keys to object format


  var keyProps;

  if (Array.isArray(keys)) {
    // [Legacy] Follow the api doc
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: undefined
    };
  } else if (typeof keys === 'object') {
    keyProps = {
      checkedKeys: keys.checked || undefined,
      halfCheckedKeys: keys.halfChecked || undefined
    };
  } else {
    warning(false, '`checkedKeys` is not an array or an object');
    return null;
  }

  keyProps.checkedKeys = keyListToString(keyProps.checkedKeys);
  keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys);
  return keyProps;
}
export var filterCheckedKeysByDisabledCheckbox = function filterCheckedKeysByDisabledCheckbox(checkedKeys, halfCheckedKeys, disabledKeys, keyEntities, isCheck) {
  var disabledKs = Object.keys(disabledKeys) || [];
  var parentEntities = {};

  var conductUp = function conductUp(parentKey) {
    parentEntities[parentKey] = true;
    checkedKeys.set(parentKey, false);
    halfCheckedKeys.set(parentKey, true);

    if (keyEntities[parentKey] && keyEntities[parentKey].parent && keyEntities[parentKey].parent.key) {
      conductUp(keyEntities[parentKey].parent.key);
    }
  };

  disabledKs.forEach(function (dKey) {
    if (disabledKeys[dKey] && disabledKeys[dKey].parent && disabledKeys[dKey].parent.key && (isCheck ? !checkedKeys.get(dKey) : checkedKeys.get(dKey)) && !parentEntities[disabledKeys[dKey].parent.key]) {
      var parentKey = disabledKeys[dKey].parent.key;
      conductUp(parentKey);
    }
  });
};
/**
 * Conduct check state by the keyList. It will conduct up & from the provided key.
 * If the conduct path reach the disabled or already checked / unchecked node will stop conduct.
 * @param keyList       list of keys
 * @param isCheck       is check the node or not
 * @param keyEntities   parsed by `convertTreeToEntities` function in Tree
 * @param checkStatus   Can pass current checked status for process (usually for uncheck operation)
 * @returns {{checkedKeys: [], halfCheckedKeys: []}}
 */

export function conductCheck(keyList, isCheck, keyEntities, checkStatus) {
  if (checkStatus === void 0) {
    checkStatus = {};
  }

  var checkedKeys = new Map();
  var halfCheckedKeys = new Map(); // Record the key has some child checked (include child half checked)

  var disabledKeys = {};
  (checkStatus.checkedKeys || []).forEach(function (key) {
    checkedKeys.set(key, true);
  });
  (checkStatus.halfCheckedKeys || []).forEach(function (key) {
    halfCheckedKeys.set(key, true);
  }); // Conduct up

  function conductUp(key) {
    if (checkedKeys.get(key) === isCheck) {
      return;
    }

    var entity = keyEntities[key];

    if (!entity) {
      return;
    }

    var _entity$children = entity.children,
        children = _entity$children === void 0 ? [] : _entity$children,
        parent = entity.parent,
        node = entity.node;

    if (isCheckDisabled(node)) {
      disabledKeys[key] = entity; // return;
    } // Check child node checked status


    var everyChildChecked = true;
    var someChildChecked = false; // Child checked or half checked

    for (var i = 0; i < children.length; i++) {
      var childKey = children[i].key;
      var childChecked = checkedKeys.get(childKey);

      if (childChecked || halfCheckedKeys.get(childKey)) {
        someChildChecked = true;
      }

      if (!childChecked) {
        everyChildChecked = false;
      }
    } // Update checked status


    if (isCheck) {
      checkedKeys.set(key, everyChildChecked);
    } else {
      checkedKeys.set(key, false);
    }

    halfCheckedKeys.set(key, someChildChecked);

    if (parent) {
      conductUp(parent.key);
    }
  } // Conduct down


  function conductDown(key) {
    if (checkedKeys.get(key) === isCheck) {
      return;
    }

    var entity = keyEntities[key];

    if (!entity) {
      return;
    }

    var children = entity.children,
        node = entity.node;

    if (isCheckDisabled(node)) {
      if (isCheck) {
        checkedKeys.set(key, isCheck);
      }

      disabledKeys[key] = entity; // return;
    }

    checkedKeys.set(key, isCheck);
    (children || []).forEach(function (child) {
      conductDown(child.key);
    });
  }

  function conduct(key) {
    var entity = keyEntities[key];

    if (!entity) {
      return;
    }

    var children = entity.children,
        parent = entity.parent,
        node = entity.node;

    if (isCheckDisabled(node)) {
      if (isCheck) {
        checkedKeys.set(key, isCheck);
      }

      disabledKeys[key] = entity; // return;
    }

    checkedKeys.set(key, isCheck); // Conduct down

    (children || [] // .filter(child => !isCheckDisabled(child.node))
    ).forEach(function (child) {
      conductDown(child.key);
    }); // Conduct up

    if (parent) {
      conductUp(parent.key);
    }
  }

  (keyList || []).forEach(function (key) {
    conduct(String(key));
  });

  if (Object.keys(disabledKeys) && Object.keys(disabledKeys).length) {
    filterCheckedKeysByDisabledCheckbox(checkedKeys, halfCheckedKeys, disabledKeys, keyEntities, isCheck);
  }

  var checkedKeyList = [];
  var halfCheckedKeyList = []; // Fill checked list

  for (var _iterator = _createForOfIteratorHelperLoose(checkedKeys), _step; !(_step = _iterator()).done;) {
    var _step$value = _step.value,
        key = _step$value[0],
        checked = _step$value[1];

    if (checked) {
      checkedKeyList.push(key);
    }
  } // Fill half checked list


  for (var _iterator2 = _createForOfIteratorHelperLoose(halfCheckedKeys), _step2; !(_step2 = _iterator2()).done;) {
    var _step2$value = _step2.value,
        _key = _step2$value[0],
        _checked = _step2$value[1];

    if (!checkedKeys.get(_key) && _checked) {
      halfCheckedKeyList.push(_key);
    }
  }

  return {
    checkedKeys: checkedKeyList,
    halfCheckedKeys: halfCheckedKeyList
  };
}
/**
 * If user use `autoExpandParent` we should get the list of parent node
 * @param keyList
 * @param keyEntities
 */

export function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = {};

  function conductUp(key) {
    if (expandedKeys[key]) {
      return;
    }

    var entity = keyEntities[key];

    if (!entity) {
      return;
    }

    expandedKeys[key] = true;
    var parent = entity.parent; // if (isCheckDisabled(node)) {
    //     return;
    // }

    if (parent) {
      conductUp(parent.key);
    }
  }

  (keyList || []).forEach(function (key) {
    conductUp(key);
  });
  return Object.keys(expandedKeys);
}
/**
 * Returns only the data- and aria- key/value pairs
 * @param {Object} props
 */

export function getDataAndAria(props) {
  return Object.keys(props).reduce(function (prev, key) {
    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {
      prev[key] = props[key];
    }

    return prev;
  }, {});
}