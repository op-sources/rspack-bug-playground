"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.walk = walk;
exports.Tree = exports.ROOT_VALUE = void 0;

var _extends3 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _last2 = _interopRequireDefault(require("lodash/last"));

function walk(items, _ref, context) {
  var enter = _ref.enter,
      exit = _ref.exit,
      _ref$deepKey = _ref.deepKey,
      deepKey = _ref$deepKey === void 0 ? 'children' : _ref$deepKey;

  if (context === void 0) {
    context = {
      deep: 0,
      parents: []
    };
  }

  var results = [];
  items.forEach(function (item) {
    var result = enter(item, context);
    var children = item[deepKey];
    var childrenResult = null;

    if (children && children.length) {
      childrenResult = walk(children, {
        enter: enter,
        exit: exit,
        deepKey: deepKey
      }, (0, _extends3["default"])({}, context, {
        parentResult: result,
        parents: [].concat(context.parents, [result]),
        deep: context.deep + 1
      }));
    }

    if (exit) {
      exit(item, (0, _extends3["default"])({}, context, {
        result: result,
        childrenResult: childrenResult
      }));
    }

    results.push(result);
  });
  return results;
}

var ROOT_VALUE = '__ONE_TREE_ROOT_VALUE__';
exports.ROOT_VALUE = ROOT_VALUE;

var Tree = /*#__PURE__*/function () {
  function Tree(items, checkedKeys, names, leaf) {
    var _this$root,
        _extends2,
        _this = this;

    if (items === void 0) {
      items = [];
    }

    if (checkedKeys === void 0) {
      checkedKeys = [];
    }

    if (names === void 0) {
      names = {};
    }

    this.map = void 0;
    this.flatten = void 0;
    this.checkedKeys = void 0;
    this.tree = void 0;
    this.root = void 0;
    var map = {};
    var _names = names,
        _names$children = _names.children,
        childrenKey = _names$children === void 0 ? 'children' : _names$children,
        _names$value = _names.value,
        valueKey = _names$value === void 0 ? 'value' : _names$value,
        _names$label = _names.label,
        labelKey = _names$label === void 0 ? 'label' : _names$label,
        _names$title = _names.title,
        titleKey = _names$title === void 0 ? 'title' : _names$title,
        _names$disabled = _names.disabled,
        disabledKey = _names$disabled === void 0 ? 'disabled' : _names$disabled,
        _names$selectable = _names.selectable,
        selectableKey = _names$selectable === void 0 ? 'selectable' : _names$selectable,
        _names$isLeaf = _names.isLeaf,
        isLeafKey = _names$isLeaf === void 0 ? 'isLeaf' : _names$isLeaf,
        _names$loading = _names.loading,
        loadingKey = _names$loading === void 0 ? 'loading' : _names$loading,
        _names$icon = _names.icon,
        iconKey = _names$icon === void 0 ? 'icon' : _names$icon,
        _names$expandType = _names.expandType,
        expandTypeKey = _names$expandType === void 0 ? 'expandType' : _names$expandType;
    var normalizedCheckedKeys = [];
    this.root = (_this$root = {}, _this$root[labelKey] = '全选', _this$root[valueKey] = ROOT_VALUE, _this$root);
    var flatten = [];
    this.tree = walk([(0, _extends3["default"])({}, this.root, (_extends2 = {}, _extends2[childrenKey] = items, _extends2))], {
      deepKey: childrenKey,
      enter: function enter(item, _ref2) {
        var parentResult = _ref2.parentResult,
            parents = _ref2.parents;
        var key = item[valueKey];
        var label = item[labelKey];
        var title = item[titleKey] || (typeof label === 'string' ? label : null);
        var disabled = parentResult && parentResult.disabled || item[disabledKey];
        var selectable = item[selectableKey];
        var checked = parentResult && parentResult.checked || checkedKeys.includes(key);
        var isLeaf = item[isLeafKey];
        var loading = item[loadingKey];
        var icon = item[iconKey];
        var expandType = item[expandTypeKey];
        var children = item[childrenKey];
        var normalizedItem = {
          root: key === ROOT_VALUE,
          key: key,
          label: label,
          icon: icon,
          title: title,
          item: item,
          disabled: disabled,
          selectable: selectable,
          checked: checked,
          isLeaf: isLeaf,
          loading: loading,
          expandType: expandType,
          parent: parentResult,
          keyPath: null
        };

        var keyPath = _this.getKeyPath(normalizedItem);

        normalizedItem.keyPath = keyPath;

        if (map[key]) {
          // 允许重复key
          map[_this.keyPathToString(keyPath)] = normalizedItem;
        } else {
          map[key] = normalizedItem;
        }

        if (leaf && (!children || !children.length)) {
          flatten.push([].concat(parents.slice(1), [normalizedItem]));
        } else if (!leaf) {
          flatten.push([].concat(parents.slice(1), [normalizedItem]));
        }

        return normalizedItem;
      },
      exit: function exit(item, _ref3) {
        var result = _ref3.result,
            childrenResult = _ref3.childrenResult,
            parents = _ref3.parents;

        if (!result.checked && childrenResult) {
          result.checked = childrenResult.every(function (c) {
            return c.checked;
          });

          if (!result.checked) {
            result.indeterminate = childrenResult.some(function (c) {
              return c.checked || c.indeterminate;
            });
          }
        }

        if (result.checked && result.key !== ROOT_VALUE) {
          normalizedCheckedKeys.push(result.key);
        }

        result.children = childrenResult;
      }
    });
    this.map = map;
    this.flatten = flatten;
    this.checkedKeys = this.keepKeysOrder(normalizedCheckedKeys, checkedKeys);
  }

  var _proto = Tree.prototype;

  _proto.getKeyPath = function getKeyPath(option) {
    var keys = [option.key];
    option = option.parent;

    while (option && option.key !== ROOT_VALUE) {
      keys.unshift(option.key);
      option = option.parent;
    }

    return keys;
  };

  _proto.keyPathToString = function keyPathToString(keyPath) {
    return keyPath && '_ONE_' + keyPath.join('_');
  };

  _proto.getNormalizedOption = function getNormalizedOption(key, keyPath) {
    var path = this.keyPathToString(keyPath);
    var option = this.map[key];

    if (option && path && this.map[path]) {
      return this.map[path];
    }

    return option;
  };

  _proto.getNormalizedOptionWithParent = function getNormalizedOptionWithParent(key) {
    var option = this.getNormalizedOption(key);
    var path = [];

    while (option && option.key !== ROOT_VALUE) {
      path.unshift(option);
      option = option.parent;
    }

    return path.length ? path : null;
  };

  _proto.getKeyWithParent = function getKeyWithParent(key, keyPath) {
    var option = this.getNormalizedOption(key, keyPath);
    var path = [];

    while (option && option.key !== ROOT_VALUE) {
      path.unshift(option.key);
      option = option.parent;
    }

    return path.length ? path : null;
  };

  _proto.getNormalizedOptions = function getNormalizedOptions(keys, isPath) {
    var _this2 = this;

    return keys.map(function (key, index) {
      return _this2.getNormalizedOption(key, isPath ? keys.slice(0, index + 1) : undefined);
    }).filter(Boolean);
  };

  _proto.getOption = function getOption(key, keyPath) {
    var item = this.getNormalizedOption(key, keyPath);

    if (item) {
      return item.item;
    }
  };

  _proto.getOptions = function getOptions(keys) {
    var _this3 = this;

    return keys.map(function (key) {
      return _this3.getOption(key);
    }).filter(Boolean);
  };

  _proto.getPathOptions = function getPathOptions(keyPath) {
    var _this4 = this;

    return keyPath.map(function (key, i) {
      return _this4.getOption(key, keyPath.slice(0, i + 1));
    }).filter(Boolean);
  };

  _proto.getOptionWithParent = function getOptionWithParent(key, keyPath) {
    var option = this.getNormalizedOption(key, keyPath);
    var path = [];

    while (option && option.key !== ROOT_VALUE) {
      path.unshift(option.item);
      option = option.parent;
    }

    return path.length ? path : null;
  };

  _proto.getOptionsWithParent = function getOptionsWithParent(keys) {
    var _this5 = this;

    return keys.map(function (key) {
      return _this5.getOptionWithParent(key);
    }).filter(Boolean);
  }
  /**
   * 获取当前key路径中的兄弟节点
   */
  ;

  _proto.getColumns = function getColumns(key, keyPath, showCheckAll, group) {
    var item = this.getNormalizedOption(key, keyPath) || this.tree[0];
    var columns = [];

    while (item) {
      if (item.children && item.children.length && item.expandType !== 'inline' && item.expandType !== 'toggle') {
        columns.unshift([].concat(item.children));
      }

      item = item.parent;
    }

    if (showCheckAll) {
      var root = (0, _extends3["default"])({}, this.tree[0]);
      delete root.children;
      columns[0].unshift(root);
    }

    if (group) {
      columns.splice(1, 1);
    }

    return columns;
  };

  _proto.getCheckedKeys = function getCheckedKeys() {
    var _this6 = this;

    return this.checkedKeys.filter(function (key) {
      return _this6.getOption(key).selectable !== false;
    });
  }
  /**
   * 搜索
   *
   * @param {string} query
   * @returns
   */
  ;

  _proto.search = function search(query, config) {
    if (config === void 0) {
      config = {};
    }

    var _config = config,
        filter = _config.filter,
        sort = _config.sort;
    return this.flatten.filter(function (path) {
      if (filter) {
        return filter(query, path.map(function (node) {
          return node.item;
        }));
      }

      if ((0, _last2["default"])(path).selectable === false) {
        return false;
      }

      return path.some(function (option) {
        return typeof option.label === 'string' && option.label.includes(query);
      });
    }).sort(function (a, b) {
      if (sort) {
        return sort(a.item, b.item, query);
      }

      return a.findIndex(function (o) {
        return typeof o.label === 'string' && o.label.includes(query);
      }) - b.findIndex(function (o) {
        return typeof o.label === 'string' && o.label.includes(query);
      });
    });
  };

  _proto.toggleChecked = function toggleChecked(key, checkedKeys) {
    var item = this.getNormalizedOption(key);

    if (!item) {
      return checkedKeys || this.getCheckedKeys();
    }

    checkedKeys = checkedKeys || this.checkedKeys;
    var checked = !(item.checked || item.indeterminate); // 设置当前节点与子节点的状态

    walk([item], {
      enter: function enter(item) {
        if (item.disabled) {
          return;
        }

        item.checked = checked;
        var key = item.key;

        if (checked) {
          if (key !== ROOT_VALUE) {
            checkedKeys.push(key);
          }
        } else {
          checkedKeys = checkedKeys.filter(function (k) {
            return k !== key;
          });
        }
      }
    });
    var normalizedCheckedKeys = [];
    walk(this.tree, {
      enter: function enter(item) {
        if (!item.children || !item.children.length) {
          item.checked = checkedKeys.includes(item.key);

          if (item.checked && item.key !== ROOT_VALUE) {
            normalizedCheckedKeys.push(item.key);
          }
        }
      },
      exit: function exit(item) {
        var children = item.children;

        if (children && children.length) {
          item.checked = children.every(function (c) {
            return c.checked;
          });
          item.indeterminate = false;

          if (!item.checked) {
            item.indeterminate = children.some(function (c) {
              return c.checked || c.indeterminate;
            });
          } else if (item.key !== ROOT_VALUE) {
            normalizedCheckedKeys.push(item.key);
          }
        }
      }
    });
    this.checkedKeys = this.keepKeysOrder(normalizedCheckedKeys, checkedKeys);
    return this.getCheckedKeys();
  }
  /**
   * 保持选择顺序
   *
   * @param {Array} keys
   * @param {Array} orderedKeys
   * @returns
   */
  ;

  _proto.keepKeysOrder = function keepKeysOrder(keys, orderedKeys) {
    var resultKeys = orderedKeys.filter(function (key) {
      return keys.includes(key);
    });
    return resultKeys.concat(keys.filter(function (key) {
      return !resultKeys.includes(key);
    }));
  };

  return Tree;
}();

exports.Tree = Tree;