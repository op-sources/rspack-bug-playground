import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _map from "lodash/map";
import _has from "lodash/has";
import _isEqual from "lodash/isEqual";
import _set from "lodash/set";
import _get from "lodash/get";
import React, { Component, forwardRef } from 'react';
import ReactDOM from 'react-dom';
import AsyncValidator from './validator';
import scrollIntoView from 'dom-scroll-into-view';
import createFieldsStore from './createFieldsStore';
import { identity, normalizeValidateRules, getValidateTriggers, getValueFromEvent, hasRules, getParams, isEmptyObject, flattenArray } from '../../../core/formTools';
import { FIELD_META_PROP, FIELD_DATA_PROP } from '../formItem';
import shallowEqual from 'shallowequal';
import { LegacyFormContext, FormContext } from '../context';
import { getScrollableContainer } from '../../../util/dom';
var DEFAULT_TRIGGER = 'onChange';
;
export var BaseForm = /*#__PURE__*/function (_Component) {
  _inheritsLoose(BaseForm, _Component);

  function BaseForm(_props) {
    var _this;

    _this = _Component.call(this, _props) || this;
    _this.form = void 0;
    _this.fieldsStore = void 0;
    _this.renderFields = void 0;
    _this.domFields = void 0;
    _this.clearedFieldMetaCache = void 0;
    _this.instances = void 0;
    _this.cachedBind = void 0;

    _this.getFieldDecorator = function (name, fieldOption) {
      var props = _this.getFieldProps(name, fieldOption);

      return function (fieldElem) {
        _this.renderFields[name] = true;

        var fieldMeta = _this.fieldsStore.getFieldMeta(name);

        var originalProps = fieldElem.props;
        fieldMeta.originalProps = originalProps;
        fieldMeta.ref = fieldElem.ref;
        return /*#__PURE__*/React.cloneElement(fieldElem, _extends({
          size: originalProps.size || _this.props.size
        }, props, _this.fieldsStore.getFieldValuePropValue(fieldMeta)));
      };
    };

    _this.getFieldProps = function (name, usersFieldOption) {
      if (!name) {
        throw new Error('Must call `getFieldProps` with valid name string!');
      }

      delete _this.clearedFieldMetaCache[name];

      var fieldOption = _extends({
        name: name,
        trigger: DEFAULT_TRIGGER,
        valuePropName: 'value',
        validate: []
      }, usersFieldOption);

      var rules = fieldOption.rules,
          trigger = fieldOption.trigger,
          _fieldOption$validate = fieldOption.validateTrigger,
          validateTrigger = _fieldOption$validate === void 0 ? trigger : _fieldOption$validate,
          validate = fieldOption.validate;

      var fieldMeta = _this.fieldsStore.getFieldMeta(name);

      if ('initialValue' in fieldOption) {
        fieldMeta.initialValue = fieldOption.initialValue;
      }

      var inputProps = _extends({}, _this.fieldsStore.getFieldValuePropValue(fieldOption), {
        ref: _this.getCacheBind(name, name + "__ref", _this.saveRef)
      });

      var _this$props = _this.props,
          fieldNameProp = _this$props.fieldNameProp,
          formName = _this$props.name;

      if (fieldNameProp) {
        inputProps[fieldNameProp] = formName ? formName + "_" + name : name;
      }

      var validateRules = normalizeValidateRules(validate, rules, validateTrigger);
      var validateTriggers = getValidateTriggers(validateRules);
      validateTriggers.forEach(function (action) {
        if (inputProps[action]) {
          return;
        }

        inputProps[action] = _this.getCacheBind(name, action, _this.onCollectValidate);
      }); // make sure that the value will be collect

      if (trigger && validateTriggers.indexOf(trigger) === -1) {
        inputProps[trigger] = _this.getCacheBind(name, trigger, _this.onCollect);
      }

      var meta = _extends({}, fieldMeta, fieldOption, {
        validate: validateRules
      });

      _this.fieldsStore.setFieldMeta(name, meta);

      inputProps[FIELD_META_PROP] = meta;
      inputProps[FIELD_DATA_PROP] = _this.fieldsStore.getField(name); // This field is rendered, record it

      _this.renderFields[name] = true;
      return inputProps;
    };

    _this.getFieldInstance = function (name) {
      return _this.instances[name];
    };

    _this.setFields = function (maybeNestedFields, callback) {
      var fields = _this.fieldsStore.flattenRegisteredFields(maybeNestedFields);

      _this.fieldsStore.setFields(fields);

      var _this$props2 = _this.props,
          onFieldsChange = _this$props2.onFieldsChange,
          formPropName = _this$props2.formPropName;

      if (onFieldsChange) {
        var _extends2;

        var changedFields = Object.keys(fields).reduce(function (acc, name) {
          return _set(acc, name, _this.fieldsStore.getField(name));
        }, {});
        onFieldsChange(_extends((_extends2 = {}, _extends2[formPropName] = _this.form, _extends2), _this.props), changedFields, _this.fieldsStore.getNestedAllFields());
      }

      _this.forceUpdate(callback);
    };

    _this.setFieldsValue = function (changedValues, callback) {
      var fieldsMeta = _this.fieldsStore.fieldsMeta;

      var values = _this.fieldsStore.flattenRegisteredFields(changedValues);

      var newFields = Object.keys(values).reduce(function (acc, name) {
        var isRegistered = fieldsMeta[name];

        if (isRegistered) {
          var value = values[name];
          acc[name] = {
            value: value
          };
        }

        return acc;
      }, {});

      _this.setFields(newFields, callback);

      var _this$props3 = _this.props,
          onValuesChange = _this$props3.onValuesChange,
          formPropName = _this$props3.formPropName;

      if (onValuesChange) {
        var _extends3;

        var allValues = _this.fieldsStore.getAllValues();

        onValuesChange(_extends((_extends3 = {}, _extends3[formPropName] = _this.form, _extends3), _this.props), changedValues, allValues);
      }
    };

    _this.setFieldsError = function (errors, callback) {
      var fieldsMeta = _this.fieldsStore.fieldsMeta;

      var fieldsError = _this.fieldsStore.flattenRegisteredFields(errors);

      var newFields = Object.keys(fieldsError).reduce(function (fields, name) {
        var isRegistered = fieldsMeta[name];

        if (isRegistered) {
          var _errors = fieldsError[name];
          fields[name] = _extends({}, _this.fieldsStore.getField(name), {
            errors: _errors
          });
        }

        return fields;
      }, {});

      _this.setFields(newFields, callback);
    };

    _this.clearField = function (name) {
      _this.fieldsStore.clearField(name);

      delete _this.instances[name];
      delete _this.cachedBind[name];
    };

    _this.resetFields = function (ns) {
      var newFields = _this.fieldsStore.resetFields(ns);

      if (Object.keys(newFields).length > 0) {
        _this.setFields(newFields);
      }

      if (ns) {
        var names = Array.isArray(ns) ? ns : [ns];
        names.forEach(function (name) {
          return delete _this.clearedFieldMetaCache[name];
        });
      } else {
        _this.clearedFieldMetaCache = {};
      }
    };

    _this.validateFields = function (ns, opt, cb) {
      var pending = new Promise(function (resolve, reject) {
        var _getParams = getParams(ns, opt, cb),
            names = _getParams.names,
            options = _getParams.options;

        var _getParams2 = getParams(ns, opt, cb),
            callback = _getParams2.callback;

        if (!callback || typeof callback === 'function') {
          var oldCb = callback;

          callback = function callback(errors, values) {
            if (oldCb) {
              oldCb(errors, values);
            } else if (errors) {
              reject({
                errors: errors,
                values: values
              });
            } else {
              resolve(values);
            }
          };
        }

        var fieldNames = names ? _this.fieldsStore.getValidFieldsFullName(names) : _this.fieldsStore.getValidFieldsName();
        var fields = fieldNames.filter(function (name) {
          var fieldMeta = _this.fieldsStore.getFieldMeta(name);

          var field = _this.fieldsStore.getField(name); // 添加强制校验的场景


          return hasRules(fieldMeta.validate) || field.dirty || field.force;
        }).map(function (name) {
          var field = _this.fieldsStore.getField(name);

          field.value = _this.fieldsStore.getFieldValue(name);
          return field;
        });

        if (!fields.length) {
          callback(null, _this.fieldsStore.getFieldsValue(fieldNames));
          return;
        }

        if (!('firstFields' in options)) {
          options.firstFields = fieldNames.filter(function (name) {
            var fieldMeta = _this.fieldsStore.getFieldMeta(name);

            return !!fieldMeta.validateFirst;
          });
        }

        _this.validateFieldsInternal(fields, {
          fieldNames: fieldNames,
          options: options
        }, callback);
      });
      pending["catch"](function (e) {
        return e;
      });
      return pending;
    };

    _this.setFieldAsDirty = function (name) {
      var _this$setFields;

      _this.setFields((_this$setFields = {}, _this$setFields[name] = _extends({}, _this.fieldsStore.getField(name), {
        errors: undefined,
        warnings: undefined,
        successes: undefined,
        dirty: true // 标记dirty便于重新校验

      }), _this$setFields));
    };

    _this.isSubmitting = function () {
      return _this.state.submitting;
    };

    _this.submit = function (callback) {
      var fn = function fn() {
        _this.setState({
          submitting: false
        });
      };

      _this.setState({
        submitting: true
      });

      callback(fn);
    };

    _this.validateFieldsAndScroll = function (ns, opt, cb) {
      var _getParams3 = getParams(ns, opt, cb),
          names = _getParams3.names,
          callback = _getParams3.callback,
          options = _getParams3.options;

      var newCb = function newCb(_ref) {
        var errors = _ref.errors,
            values = _ref.values;

        if (errors) {
          var validNames = _this.fieldsStore.getValidFieldsName();

          var firstNode;
          var firstTop;
          validNames.forEach(function (name) {
            if (_has(errors, name)) {
              var instance = _this.getFieldInstance(name);

              if (instance) {
                var node = ReactDOM.findDOMNode(instance);
                var top = node.getBoundingClientRect().top;

                if (firstTop === undefined || firstTop > top) {
                  firstTop = top;
                  firstNode = node;
                }
              }
            }
          });

          if (firstNode) {
            var c = options.container || getScrollableContainer(firstNode);
            scrollIntoView(firstNode, c, _extends({
              onlyScrollIfNeeded: true
            }, options.scroll));
          }
        }

        if (typeof callback === 'function') {
          callback(errors, values);
        }
      };

      var validate = _this.validateFields(names, options);

      validate.then(function (values) {
        if (typeof callback === 'function') {
          callback(undefined, values);
        }
      }, newCb);
      return validate;
    };

    _this.scrollToField = function (name, options) {
      if (options === void 0) {
        options = {};
      }

      var instance = _this.getFieldInstance(name);

      if (instance) {
        var node = ReactDOM.findDOMNode(instance);
        var container = options.container || getScrollableContainer(node);
        scrollIntoView(node, container, {
          onlyScrollIfNeeded: true
        });
      }
    };

    _this.isFormValidating = function () {
      return _this.state.formValidating;
    };

    _this.validateForm = function (scrollToError) {
      _this.setState({
        formValidating: true
      });

      var validate;

      if (scrollToError) {
        validate = _this.validateFieldsAndScroll();
      }

      validate = _this.validateFields();
      validate["catch"](function () {})["finally"](function () {
        return _this.setState({
          formValidating: false
        });
      });
      return validate;
    };

    var mapPropsToFields = _this.props.mapPropsToFields;

    var _fields = mapPropsToFields && mapPropsToFields(_this.props);

    _this.fieldsStore = createFieldsStore(_fields || {});
    _this.instances = {};
    _this.cachedBind = {};
    _this.clearedFieldMetaCache = {};
    _this.renderFields = {};
    _this.domFields = {};
    ['getFieldsValue', 'getFieldValue', 'setFieldsInitialValue', 'getFieldsError', 'getFieldError', 'getFieldsWarning', 'getFieldWarning', 'getFieldsSuccess', 'getFieldSuccess', 'isFieldValidating', 'isFieldsValidating', 'isFieldsTouched', 'isFieldTouched'].forEach(function (key) {
      _this[key] = function () {
        var _this$fieldsStore;

        return (_this$fieldsStore = _this.fieldsStore)[key].apply(_this$fieldsStore, arguments);
      };
    });
    _this.state = {
      submitting: false,
      formValidating: false,
      fieldsStore: _this.fieldsStore,
      mapPropsToFields: mapPropsToFields,
      prevProps: _props
    };
    _this.form = _this.getForm();
    return _this;
  }

  var _proto = BaseForm.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.cleanUpUselessFields();
  };

  BaseForm.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    var mapPropsToFields = state.mapPropsToFields,
        fieldsStore = state.fieldsStore,
        prevProps = state.prevProps;

    if (mapPropsToFields && !shallowEqual(props, prevProps)) {
      fieldsStore.updateFields(mapPropsToFields(props));
    }

    return {
      prevProps: props
    };
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.cleanUpUselessFields();
  };

  _proto.cleanUpUselessFields = function cleanUpUselessFields() {
    var _this2 = this;

    var fieldList = this.fieldsStore.getAllFieldsName();
    var removedList = fieldList.filter(function (field) {
      var fieldMeta = _this2.fieldsStore.getFieldMeta(field);

      return !_this2.renderFields[field] && !_this2.domFields[field] && !fieldMeta.preserve;
    });

    if (removedList.length) {
      removedList.forEach(this.clearField);
    }

    this.renderFields = {};
  };

  _proto.onCollectCommon = function onCollectCommon(name, action, args) {
    var fieldMeta = this.fieldsStore.getFieldMeta(name);

    if (fieldMeta[action]) {
      fieldMeta[action].apply(fieldMeta, args);
    } else if (fieldMeta.originalProps && fieldMeta.originalProps[action]) {
      var _fieldMeta$originalPr;

      (_fieldMeta$originalPr = fieldMeta.originalProps)[action].apply(_fieldMeta$originalPr, args);
    }

    var value = fieldMeta.getValueFromEvent ? fieldMeta.getValueFromEvent.apply(fieldMeta, args) : getValueFromEvent.apply(void 0, args);
    var _this$props4 = this.props,
        onValuesChange = _this$props4.onValuesChange,
        formPropName = _this$props4.formPropName;

    if (onValuesChange && value !== this.fieldsStore.getFieldValue(name)) {
      var _extends4;

      var valuesAll = this.fieldsStore.getAllValues();
      var valuesAllSet = {};
      valuesAll[name] = value;
      Object.keys(valuesAll).forEach(function (key) {
        return _set(valuesAllSet, key, valuesAll[key]);
      });
      onValuesChange(_extends((_extends4 = {}, _extends4[formPropName] = this.form, _extends4), this.props), _set({}, name, value), valuesAllSet);
    }

    var field = this.fieldsStore.getField(name);
    return {
      name: name,
      field: _extends({}, field, {
        value: value,
        touched: true
      }),
      fieldMeta: fieldMeta
    };
  };

  _proto.onCollect = function onCollect(nameCurrent, action) {
    var _this$setFields2;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var _this$onCollectCommon = this.onCollectCommon(nameCurrent, action, args),
        name = _this$onCollectCommon.name,
        field = _this$onCollectCommon.field,
        fieldMeta = _this$onCollectCommon.fieldMeta;

    var validate = fieldMeta.validate;
    this.fieldsStore.setFieldsAsDirty();

    var newField = _extends({}, field, {
      dirty: hasRules(validate)
    });

    this.setFields((_this$setFields2 = {}, _this$setFields2[name] = newField, _this$setFields2));
  };

  _proto.onCollectValidate = function onCollectValidate(nameCurrent, action) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    var _this$onCollectCommon2 = this.onCollectCommon(nameCurrent, action, args),
        field = _this$onCollectCommon2.field,
        fieldMeta = _this$onCollectCommon2.fieldMeta;

    var newField = _extends({}, field, {
      dirty: true
    });

    this.fieldsStore.setFieldsAsDirty();
    this.validateFieldsInternal([newField], {
      action: action,
      options: {
        firstFields: !!fieldMeta.validateFirst
      }
    });
  };

  _proto.getCacheBind = function getCacheBind(name, action, fn) {
    if (!this.cachedBind[name]) {
      this.cachedBind[name] = {};
    }

    var cache = this.cachedBind[name];

    if (!cache[action] || cache[action].oriFn !== fn) {
      cache[action] = {
        fn: fn.bind(this, name, action),
        oriFn: fn
      };
    }

    return cache[action].fn;
  };

  _proto.getRules = function getRules(fieldMeta, action) {
    var actionRules = fieldMeta.validate.filter(function (item) {
      return !action || item.trigger.indexOf(action) >= 0;
    }).map(function (item) {
      return item.rules;
    });
    return flattenArray(actionRules);
  };

  _proto.saveRef = function saveRef(name, _, component) {
    if (!component) {
      var _fieldMeta = this.fieldsStore.getFieldMeta(name);

      if (!_fieldMeta.preserve) {
        // after destroy, delete data
        this.clearedFieldMetaCache[name] = {
          field: this.fieldsStore.getField(name),
          meta: _fieldMeta
        };
        this.clearField(name);
      }

      delete this.domFields[name];
      return;
    }

    this.domFields[name] = true;
    this.recoverClearedField(name);
    var fieldMeta = this.fieldsStore.getFieldMeta(name);

    if (fieldMeta) {
      var ref = fieldMeta.ref;

      if (ref) {
        if (typeof ref === 'string') {
          throw new Error("can not set ref string for " + name);
        } else if (typeof ref === 'function') {
          ref(component);
        } else if (Object.prototype.hasOwnProperty.call(ref, 'current')) {
          ref.current = component;
        }
      }
    }

    this.instances[name] = component;
  };

  _proto.recoverClearedField = function recoverClearedField(name) {
    if (this.clearedFieldMetaCache[name]) {
      var _this$fieldsStore$set;

      this.fieldsStore.setFields((_this$fieldsStore$set = {}, _this$fieldsStore$set[name] = this.clearedFieldMetaCache[name].field, _this$fieldsStore$set));
      this.fieldsStore.setFieldMeta(name, this.clearedFieldMetaCache[name].meta);
      delete this.clearedFieldMetaCache[name];
    }
  };

  _proto.getAsyncValidator = function getAsyncValidator(rule, value, options) {
    var validator = new AsyncValidator(rule);
    var validateMessages = this.props.validateMessages;

    if (validateMessages) {
      // @ts-ignore
      validator.messages(validateMessages);
    }

    return validator.validate(value, options);
  };

  _proto.mixValidateFields = function mixValidateFields(rules, values, options) {
    var _this3 = this;

    var errors = [];
    var warnings = [];
    var successes = [];
    return Promise.all(_map(values, function (value, key) {
      var _fieldValue, _this3$getAsyncValida;

      var fieldRules = rules[key];
      var errorRules = fieldRules.filter(function (rule) {
        return !rule.asyncValidator && rule.invalidType !== 'warning';
      });
      var warningRules = fieldRules.filter(function (rule) {
        return !rule.asyncValidator && rule.invalidType === 'warning';
      });
      var asyncRules = fieldRules.filter(function (rule) {
        return !!rule.asyncValidator;
      });
      var fieldValue = (_fieldValue = {}, _fieldValue[key] = value, _fieldValue);
      return _this3.getAsyncValidator((_this3$getAsyncValida = {}, _this3$getAsyncValida[key] = errorRules, _this3$getAsyncValida), fieldValue, options) // errors
      .then(function () {
        var _this3$getAsyncValida2;

        // warnings
        return _this3.getAsyncValidator((_this3$getAsyncValida2 = {}, _this3$getAsyncValida2[key] = warningRules, _this3$getAsyncValida2), fieldValue, options)["catch"](function (err) {
          var errors = err.errors || {
            field: key,
            message: String(err)
          };
          warnings = warnings.concat(errors);
        });
      }).then(function () {
        var _this3$getAsyncValida3;

        // async
        return _this3.getAsyncValidator((_this3$getAsyncValida3 = {}, _this3$getAsyncValida3[key] = asyncRules, _this3$getAsyncValida3), fieldValue, options);
      }).then(function () {
        // success message
        var success = fieldRules.filter(function (rule) {
          return rule.successMessage;
        }).map(function (rule) {
          return {
            field: key,
            message: rule.successMessage
          };
        });

        if (success.length) {
          successes = successes.concat(success);
        }
      })["catch"](function (err) {
        var errs = err.errors || {
          field: key,
          message: String(err)
        };
        errors = errors.concat(errs);
      });
    })).then(function () {
      return {
        errors: errors,
        warnings: warnings,
        successes: successes
      };
    });
  };

  _proto.validateFieldsInternal = function validateFieldsInternal(fields, fieldOptions, callback) {
    var _this4 = this;

    var fieldNames = fieldOptions.fieldNames,
        action = fieldOptions.action,
        _fieldOptions$options = fieldOptions.options,
        options = _fieldOptions$options === void 0 ? {} : _fieldOptions$options;
    var allRules = {};
    var allValues = {};
    var allFields = {};
    var alreadyErrors = {};
    var alreadyWarnings = {};
    var alreadySuccesses = {};
    fields.forEach(function (field) {
      var name = field.name,
          dirty = field.dirty,
          errors = field.errors,
          warnings = field.warnings,
          successes = field.successes,
          value = field.value;

      if (options.force !== true && dirty === false) {
        if (errors && errors.length) {
          _set(alreadyErrors, name, {
            errors: errors
          });
        }

        if (warnings && warnings.length) {
          _set(alreadyWarnings, name, {
            warnings: warnings
          });
        }

        if (successes && successes.length) {
          _set(alreadySuccesses, name, {
            successes: successes
          });
        }

        return;
      }

      var fieldMeta = _this4.fieldsStore.getFieldMeta(name);

      allRules[name] = _this4.getRules(fieldMeta, action);
      allValues[name] = value;
      allFields[name] = _extends({}, field, {
        errors: undefined,
        warnings: undefined,
        successes: undefined,
        validating: true,
        dirty: true
      });
    });
    this.setFields(allFields); // in case normalize

    Object.keys(allValues).forEach(function (f) {
      allValues[f] = _this4.fieldsStore.getFieldValue(f);
    });

    if (callback && isEmptyObject(allFields)) {
      callback(isEmptyObject(alreadyErrors) ? null : alreadyErrors, this.fieldsStore.getFieldsValue(fieldNames));
      return;
    }

    this.mixValidateFields(allRules, allValues, options).then(function (messages) {
      var errorsGroup = _this4.getMessageGroup('errors', messages, allRules, alreadyErrors);

      var warningsGroup = _this4.getMessageGroup('warnings', messages, allRules, alreadyWarnings);

      var successesGroup = _this4.getMessageGroup('successes', messages, allRules, alreadySuccesses);

      var expired = [];
      var nowAllFields = {};
      Object.keys(allRules).forEach(function (name) {
        var fieldErrors = _get(errorsGroup, name);

        var fieldWarnings = _get(warningsGroup, name);

        var fieldSuccesses = _get(successesGroup, name);

        var nowField = _this4.fieldsStore.getField(name); // avoid concurrency problems


        if (!_isEqual(nowField.value, allValues[name])) {
          expired.push({
            name: name
          });
        } else {
          nowField.errors = fieldErrors && fieldErrors.errors;
          nowField.warnings = fieldWarnings && fieldWarnings.warnings;
          nowField.successes = fieldSuccesses && fieldSuccesses.successes;
          nowField.value = allValues[name];
          nowField.validating = false;
          nowField.dirty = false;
          nowAllFields[name] = nowField;
        }
      });

      _this4.setFields(nowAllFields);

      if (callback) {
        if (expired.length) {
          expired.forEach(function (_ref2) {
            var name = _ref2.name;
            var fieldErrors = [{
              message: name + " need to revalidate",
              field: name
            }];

            _set(errorsGroup, name, {
              expired: true,
              errors: fieldErrors
            });
          });
        }

        callback(isEmptyObject(errorsGroup) ? null : errorsGroup, _this4.fieldsStore.getFieldsValue(fieldNames));
      }
    });
  };

  _proto.getMessageGroup = function getMessageGroup(type, messages, allRules, typedMessages) {
    var _this5 = this;

    var newMessages = messages[type];

    var messagesGroup = _extends({}, typedMessages);

    newMessages.forEach(function (e) {
      var fieldName = _this5.getFieldName(e.field, allRules);

      var field = _get(messagesGroup, fieldName);

      if (typeof field !== 'object' || Array.isArray(field)) {
        var _set2;

        _set(messagesGroup, fieldName, (_set2 = {}, _set2[type] = [], _set2));
      }

      var data = _get(messagesGroup, fieldName.concat("." + type));

      data.push(e);
    });
    return messagesGroup;
  };

  _proto.getFieldName = function getFieldName(errorFieldName, allRules) {
    var fieldName = errorFieldName;
    Object.keys(allRules).some(function (ruleFieldName) {
      var rules = allRules[ruleFieldName] || []; // Exist if match rule

      if (ruleFieldName === errorFieldName) {
        fieldName = ruleFieldName;
        return true;
      } // Skip if not match array type


      if (rules.every(function (_ref3) {
        var type = _ref3.type;
        return type !== 'array';
      }) && errorFieldName.indexOf(ruleFieldName) !== 0) {
        return false;
      } // Exist if match the field name


      var restPath = errorFieldName.slice(ruleFieldName.length + 1);

      if (/^\d+$/.test(restPath)) {
        fieldName = ruleFieldName;
        return true;
      }

      return false;
    });
    return fieldName;
  };

  _proto.getForm = function getForm() {
    return {
      getFieldsValue: this.fieldsStore.getFieldsValue,
      getFieldValue: this.fieldsStore.getFieldValue,
      getFieldInstance: this.getFieldInstance,
      setFieldsValue: this.setFieldsValue,
      setFieldsError: this.setFieldsError,
      setFields: this.setFields,
      setFieldsInitialValue: this.fieldsStore.setFieldsInitialValue,
      getFieldDecorator: this.getFieldDecorator,
      getFieldProps: this.getFieldProps,
      getFieldsError: this.fieldsStore.getFieldsError,
      getFieldError: this.fieldsStore.getFieldError,
      getFieldsSuccess: this.fieldsStore.getFieldsSuccess,
      getFieldSuccess: this.fieldsStore.getFieldSuccess,
      getFieldsWarning: this.fieldsStore.getFieldsWarning,
      getFieldWarning: this.fieldsStore.getFieldWarning,
      isFieldValidating: this.fieldsStore.isFieldValidating,
      isFieldsValidating: this.fieldsStore.isFieldsValidating,
      isFieldsTouched: this.fieldsStore.isFieldsTouched,
      isFieldTouched: this.fieldsStore.isFieldTouched,
      isSubmitting: this.isSubmitting,
      submit: this.submit,
      validateForm: this.validateForm,
      isFormValidating: this.isFormValidating,
      validateFields: this.validateFields,
      resetFields: this.resetFields,
      validateFieldsAndScroll: this.validateFieldsAndScroll,
      scrollToField: this.scrollToField
    };
  };

  _proto.render = function render() {
    var _formProps;

    var _this$props5 = this.props,
        wrappedComponentRef = _this$props5.wrappedComponentRef,
        LegacyForm = _this$props5.LegacyForm,
        formPropName = _this$props5.formPropName,
        mapProps = _this$props5.mapProps,
        lightPrefix = _this$props5.lightPrefix,
        restProps = _objectWithoutPropertiesLoose(_this$props5, ["wrappedComponentRef", "LegacyForm", "formPropName", "mapProps", "lightPrefix"]);

    var formProps = (_formProps = {}, _formProps[formPropName] = this.getForm(), _formProps);
    formProps.ref = wrappedComponentRef;
    var props = mapProps.call(this, _extends({}, formProps, restProps));

    if (LegacyForm) {
      return /*#__PURE__*/React.createElement(LegacyForm, props);
    }

    return /*#__PURE__*/React.createElement(FormContext.Provider, {
      value: _extends({}, this.context, {
        form: this
      })
    }, this.props.children);
  };

  return BaseForm;
}(Component);
BaseForm.defaultProps = {
  mapProps: identity,
  formPropName: 'form',
  size: 'medium',
  fieldNameProp: 'id'
};
BaseForm.contextType = FormContext;
;

var createBaseForm = function createBaseForm(option) {
  if (option === void 0) {
    option = {};
  }

  return function (LegacyForm) {
    return /*#__PURE__*/forwardRef(function (props, ref) {
      return /*#__PURE__*/React.createElement(LegacyFormContext.Provider, {
        value: {
          legacy: true
        }
      }, /*#__PURE__*/React.createElement(BaseForm, _extends({}, option, props, {
        LegacyForm: LegacyForm,
        ref: ref
      })));
    });
  };
};

export default createBaseForm;