import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _extends from "@babel/runtime/helpers/extends";

var _dec, _class, _class2, _temp;

import React, { PureComponent, cloneElement } from 'react';
import { classnames } from '../../core/commonTools';
import CommonTooltip from './common/tooltip';
import _getPlacements from './placements';
import { withConfigConsumer } from '../providerConfig/context';

var splitObject = function splitObject(obj, keys) {
  var picked = {};

  var omited = _extends({}, obj);

  keys.forEach(function (key) {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omited[key];
    }
  });
  return {
    picked: picked,
    omited: omited
  };
};

var Tooltip = (_dec = withConfigConsumer('tooltip'), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(Tooltip, _PureComponent);

  function Tooltip(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;

    _this.onVisibleChange = function (visible) {
      var onVisibleChange = _this.props.onVisibleChange;

      if (!('visible' in _this.props)) {
        _this.setState({
          visible: visible
        });
      }

      if (onVisibleChange) {
        onVisibleChange(visible);
      }
    };

    _this.tooltipRef = void 0;

    _this.getTooltipRef = function (ref) {
      _this.tooltipRef = ref;
    };

    _this.onPopupAlign = function (domNode, align) {
      var placements = _this.getPlacements(); // 当前返回的位置


      var placement = Object.keys(placements).filter(function (key) {
        return placements[key].points[0] === align.points[0] && placements[key].points[1] === align.points[1];
      })[0];

      if (!placement) {
        return;
      } // 根据当前坐标设置动画点


      var rect = domNode.getBoundingClientRect();
      var transformOrigin = {
        top: '50%',
        left: '50%'
      };

      if (placement.indexOf('top') >= 0 || placement.indexOf('Bottom') >= 0) {
        transformOrigin.top = rect.height - align.offset[1] + "px";
      } else if (placement.indexOf('Top') >= 0 || placement.indexOf('bottom') >= 0) {
        transformOrigin.top = -align.offset[1] + "px";
      }

      if (placement.indexOf('left') >= 0 || placement.indexOf('Right') >= 0) {
        transformOrigin.left = rect.width - align.offset[0] + "px";
      } else if (placement.indexOf('right') >= 0 || placement.indexOf('Left') >= 0) {
        transformOrigin.left = -align.offset[0] + "px";
      }

      if (placement.indexOf('top') >= 0) {
        domNode.style.top = domNode.style.top.split('px') && +domNode.style.top.split('px')[0] + 4 + "px" || domNode.style.top;
      } else if (placement.indexOf('bottom') >= 0) {
        domNode.style.top = domNode.style.top.split('px') && +domNode.style.top.split('px')[0] - 4 + "px" || domNode.style.top;
      } else if (placement.indexOf('right') >= 0) {
        domNode.style.left = domNode.style.left.split('px') && +domNode.style.left.split('px')[0] - 4 + "px" || domNode.style.left;
      } else if (placement.indexOf('left') >= 0) {
        domNode.style.left = domNode.style.left.split('px') && +domNode.style.left.split('px')[0] + 4 + "px" || domNode.style.left;
      }

      domNode.style.transformOrigin = transformOrigin.left + " " + transformOrigin.top;
    };

    _this.state = {
      visible: !!props.visible || !!props.defaultVisible
    };
    return _this;
  }

  var _proto = Tooltip.prototype;

  _proto.getPlacements = function getPlacements() {
    var _this$props = this.props,
        arrowPointAtCenter = _this$props.arrowPointAtCenter,
        autoAdjustOverflow = _this$props.autoAdjustOverflow;
    return _getPlacements({
      arrowPointAtCenter: arrowPointAtCenter,
      verticalArrowShift: 8,
      autoAdjustOverflow: autoAdjustOverflow
    });
  } // Fix Tooltip won't hide at disabled button
  ;

  _proto.getDisabledCompatibleChildren = function getDisabledCompatibleChildren(element) {
    if ((element.type === 'button' || element.type.displayName === 'Button' || element.type.displayName === 'Switch') && element.props.disabled && this.isHoverTrigger()) {
      // Pick some layout related style properties up to span
      var _splitObject = splitObject(element.props.style, ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex']),
          picked = _splitObject.picked,
          omited = _splitObject.omited;

      var spanStyle = _extends({
        display: 'inline-block'
      }, picked, {
        cursor: 'not-allowed'
      });

      var buttonStyle = _extends({}, omited, {
        pointerEvents: 'none'
      });

      var child = /*#__PURE__*/cloneElement(element, {
        style: buttonStyle,
        className: null
      });
      return /*#__PURE__*/React.createElement("span", {
        style: spanStyle,
        className: element.props.className
      }, child);
    }

    return element;
  };

  _proto.isHoverTrigger = function isHoverTrigger() {
    var trigger = this.props.trigger;

    if (!trigger || trigger === 'hover') {
      return true;
    }

    if (Array.isArray(trigger)) {
      return trigger.indexOf('hover') >= 0;
    }

    return false;
  };

  _proto.isNoTitle = function isNoTitle() {
    var _this$props2 = this.props,
        title = _this$props2.title,
        overlay = _this$props2.overlay;
    return !title && !overlay; // overlay for old version compatibility
  };

  _proto.render = function render() {
    var _classnames;

    var props = this.props,
        state = this.state;
    var prefixCls = props.prefixCls,
        title = props.title,
        overlay = props.overlay,
        openClassName = props.openClassName,
        getPopupContainer = props.getPopupContainer,
        getTooltipContainer = props.getTooltipContainer,
        overlayClassName = props.overlayClassName,
        type = props.type;
    var children = props.children;
    var visible = this.isNoTitle() ? false : state.visible;
    var child = this.getDisabledCompatibleChildren( /*#__PURE__*/React.isValidElement(children) ? children : /*#__PURE__*/React.createElement("span", null, children));
    var childProps = child.props;
    var childCls = classnames(childProps.className, (_classnames = {}, _classnames[openClassName || prefixCls + "-open"] = true, _classnames));
    var tooltipOverlayClass = classnames(overlayClassName, prefixCls + "-" + type);
    return /*#__PURE__*/React.createElement(CommonTooltip, _extends({}, this.props, {
      ref: this.props.toolTipRef || this.getTooltipRef,
      getTooltipContainer: getPopupContainer || getTooltipContainer,
      builtinPlacements: this.getPlacements(),
      overlay: overlay || title || '',
      visible: visible,
      onVisibleChange: this.onVisibleChange // onPopupAlign={this.onPopupAlign}
      ,
      overlayClassName: tooltipOverlayClass
    }), visible ? /*#__PURE__*/cloneElement(child, {
      className: childCls
    }) : child);
  };

  return Tooltip;
}(PureComponent), _class2.defaultProps = {
  prefixCls: 'one-tooltip',
  placement: 'top',
  transitionName: 'zoom-big-fast',
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: false,
  autoAdjustOverflow: true,
  type: 'light'
}, _class2.getDerivedStateFromProps = function (nextProps, prevState) {
  if ('visible' in nextProps) {
    return {
      visible: nextProps.visible
    };
  }

  return null;
}, _temp)) || _class);
export default Tooltip;