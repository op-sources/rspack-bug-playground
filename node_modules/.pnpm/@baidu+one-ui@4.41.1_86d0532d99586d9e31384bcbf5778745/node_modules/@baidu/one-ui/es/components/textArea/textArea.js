import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

var _dec, _class, _class2, _temp;

import React, { PureComponent } from 'react';
import omit from 'omit.js';
import { handleErrorMessage, fixControlledValue, commonRemoveProps } from '../../core/inputTools';
import { classnames, locationRemoveProps, handleCountTips, CHINA_COUNT_MODE, getRealLength } from '../../core/commonTools';
import calculateNodeHeight from '../../core/textAreaTools';
import Popover from '../popover';
import { getPopoverProps, tipsAndErrorRender } from '../../core/tipsAndErrorTools';
import { withConfigConsumer } from '../providerConfig/context';
import { COMPONENT_INVALID, COMPONENT_MAIN } from '../config';

function onNextFrame(cb) {
  if (window.requestAnimationFrame) {
    return window.requestAnimationFrame(cb);
  }

  return window.setTimeout(cb, 1);
}

function clearNextFrameAction(nextFrameId) {
  if (window.cancelAnimationFrame) {
    window.cancelAnimationFrame(nextFrameId);
  } else {
    window.clearTimeout(nextFrameId);
  }
}

var TextArea = (_dec = withConfigConsumer('textarea'), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(TextArea, _PureComponent);

  function TextArea(_props) {
    var _this;

    _this = _PureComponent.call(this, _props) || this;
    _this.___imeStart___ = void 0;
    _this.nextFrameActionId = void 0;
    _this.textAreaRef = void 0;
    _this.counterRef = void 0;

    _this.onInputCompositionStart = function () {
      _this.___imeStart___ = true;
    };

    _this.onInputCompositionEnd = function (e) {
      _this.___imeStart___ = false;

      _this.onChange(e);
    };

    _this.onChange = function (e) {
      _this.resizeTextarea();

      if (_this.___imeStart___) {
        _this.setState({
          inputValue: e.target.value
        });

        return;
      }

      _this.handleError(e, 'onChange', false);
    };

    _this.resizeTextarea = function () {
      var _this$props = _this.props,
          minRows = _this$props.minRows,
          maxRows = _this$props.maxRows;

      _this.setState({
        textareaStyles: calculateNodeHeight(_this.textAreaRef, _this.counterRef, false, minRows, maxRows)
      });
    };

    _this.handleError = function (e, funcName, isHandleMin) {
      if (isHandleMin === void 0) {
        isHandleMin = true;
      }

      var props = _this.props;
      var value = e && e.target && e.target.value;
      var errorMessage = handleErrorMessage(_extends({}, props, {
        value: value
      }), isHandleMin, true);
      var result = {
        value: value,
        errorMessage: errorMessage,
        event: e,
        target: e && e.target
      };
      var newState = {
        errorMessage: errorMessage
      };

      if (!('value' in _this.props)) {
        // this.setState(result);
        newState.value = value;
        newState.inputValue = value;
      } else {
        newState.inputValue = _this.state.value;
      }

      _this.setState(newState);

      var func = props[funcName];

      if (func) {
        func(result, e);
      }
    };

    _this.focus = function () {
      _this.textAreaRef && _this.textAreaRef.focus();
    };

    _this.blur = function () {
      _this.textAreaRef && _this.textAreaRef.blur();
    };

    _this.onBlur = function (e) {
      _this.setState({
        hasFocus: false
      });

      _this.handleError(e, 'onBlur', true);
    };

    _this.onFocus = function (e) {
      _this.setState({
        hasFocus: true
      });

      _this.handleError(e, 'onFocus', true);
    };

    _this.saveTextAreaRef = function (textArea) {
      _this.textAreaRef = textArea;
    };

    _this.saveCounterRef = function (node) {
      _this.counterRef = node;
    };

    var _value = typeof _props.value === 'undefined' ? _props.defaultValue : _props.value;

    _this.state = {
      prevProps: _props,
      hasFocus: false,
      textareaStyles: null,
      value: _value,
      inputValue: _value,
      errorMessage: ''
    };
    return _this;
  }

  var _proto = TextArea.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.resizeTextarea();
    this.setContainerRef();
  };

  _proto.setContainerRef = function setContainerRef() {
    var containerRef = this.props.containerRef;

    if (containerRef) {
      return containerRef(this);
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this$props2 = this.props,
        value = _this$props2.value,
        minRows = _this$props2.minRows,
        maxRows = _this$props2.maxRows;

    if (value !== prevProps.value || minRows !== prevProps.minRows || maxRows !== prevProps.maxRows) {
      if (this.nextFrameActionId) {
        clearNextFrameAction(this.nextFrameActionId);
      }

      this.nextFrameActionId = onNextFrame(this.resizeTextarea);
    }

    this.setContainerRef();
  };

  TextArea.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    var newState = {
      prevProps: nextProps
    };
    var value = nextProps.value;

    if ('value' in nextProps && value !== (prevState.prevProps || {}).value) {
      newState.value = value;
      newState.inputValue = value;
    }

    return newState;
  };

  _proto.render = function render() {
    var _classnames, _classnames2, _classnames3;

    var props = this.props;
    var propsErrorMessage = props.errorMessage;
    var otherProps = omit(props, ['prefixCls', 'maxRows', 'minRows', 'filterArray', 'defaultValue', 'showErrorWithoutErrorMessage', 'showErrorMessage', 'originTextAreaProps', 'containerRef', 'width', 'lightPrefix'].concat(commonRemoveProps, locationRemoveProps));
    var width = props.width,
        prefixCls = props.prefixCls,
        maxLen = props.maxLen,
        className = props.className,
        disabled = props.disabled,
        readOnly = props.readOnly,
        showErrorMessage = props.showErrorMessage,
        showErrorWithoutErrorMessage = props.showErrorWithoutErrorMessage,
        tipText = props.tipText,
        location = props.location,
        tipLocation = props.tipLocation,
        errorLocation = props.errorLocation,
        _props$style = props.style,
        style = _props$style === void 0 ? {} : _props$style,
        size = props.size,
        lightPrefix = props.lightPrefix;
    var _this$state = this.state,
        textareaStyles = _this$state.textareaStyles,
        hasFocus = _this$state.hasFocus,
        value = _this$state.value,
        inputValue = _this$state.inputValue,
        stateErrorMessage = _this$state.errorMessage;
    var errorMessage = propsErrorMessage == null ? stateErrorMessage : propsErrorMessage;
    var error = errorMessage || showErrorWithoutErrorMessage;

    var defaultProps = _extends({
      value: fixControlledValue(inputValue),
      style: _extends({
        width: width
      }, style, textareaStyles),
      className: classnames(prefixCls, className, COMPONENT_MAIN(lightPrefix), (_classnames = {}, _classnames[prefixCls + "-disabled"] = disabled, _classnames[prefixCls + "-readOnly"] = readOnly, _classnames[COMPONENT_INVALID(lightPrefix)] = error, _classnames)),
      ref: this.saveTextAreaRef,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      onChange: this.onChange,
      onCompositionStart: this.onInputCompositionStart,
      onCompositionEnd: this.onInputCompositionEnd
    }, props.originTextAreaProps);

    var containerProps = {
      className: classnames(prefixCls + "-container", (_classnames2 = {}, _classnames2[prefixCls + "-error"] = error, _classnames2))
    };

    var popParams = _extends({}, props, {
      errorMessage: errorMessage
    });

    var wrapperClass = prefixCls + "-wrapper";
    var showSideMessage = showErrorMessage && ((tipText || errorMessage) && location === 'right' || tipText && tipLocation === 'right' || errorMessage && errorLocation === 'right');
    var wrapperProps = {
      className: classnames(wrapperClass, (_classnames3 = {}, _classnames3[wrapperClass + "-" + size] = size, _classnames3)),
      style: {
        width: !showSideMessage ? style.width || width : undefined
      }
    };
    return /*#__PURE__*/React.createElement("div", wrapperProps, /*#__PURE__*/React.createElement("div", containerProps, /*#__PURE__*/React.createElement(Popover, getPopoverProps(popParams, {
      hasFocus: hasFocus
    }), /*#__PURE__*/React.createElement("textarea", _extends({}, _extends({}, otherProps, defaultProps), {
      "data-type": "textarea"
    }))), maxLen ? /*#__PURE__*/React.createElement("span", {
      className: prefixCls + "-count-tips",
      ref: this.saveCounterRef
    }, handleCountTips(getRealLength(props, value), maxLen)) : null), showErrorMessage ? tipsAndErrorRender(popParams) : null);
  };

  return TextArea;
}(PureComponent), _class2.defaultProps = {
  prefixCls: 'one-textarea',
  width: 300,
  maxRows: 8,
  minRows: 3,
  maxLen: null,
  errorMessage: null,
  location: 'right',
  tipLocation: null,
  errorLocation: null,
  tipText: null,
  onChange: function onChange() {},
  onBlur: function onBlur() {},
  onFocus: function onFocus() {},
  size: 'medium',
  isRequired: false,
  filterArray: [],
  countMode: CHINA_COUNT_MODE,
  getLength: null,
  disabled: false,
  readOnly: false,
  showErrorMessage: true,
  showErrorWithoutErrorMessage: false,
  originTextAreaProps: {}
}, _temp)) || _class);
export default TextArea;