import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";

var _dec, _class, _class2, _temp;

import React, { PureComponent } from 'react';
import { withConfigConsumer } from '../providerConfig/context';
import Progress from '../progress';
import classnames from 'classnames';
var INTERVAL_RANGE = [200, 500];
var ROUND_STOPS = [0.4, 0.7, 0.8];
var ROUND_DELTA_RANGE = [-0.05, 0.1];
var STEP_VALUE = 0.05;
var MIN_STEP_VALUE = 0.005;
var LoadingBar = (_dec = withConfigConsumer('loading-bar'), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(LoadingBar, _PureComponent);

  function LoadingBar() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _PureComponent.call.apply(_PureComponent, [this].concat(args)) || this;
    _this.state = {
      value: 0
    };
    _this.stepTimer = void 0;
    _this.durationTimer = void 0;
    _this.round = 0;
    _this.stepValue = STEP_VALUE;
    _this.startHandle = void 0;
    return _this;
  }

  LoadingBar.getDerivedStateFromProps = function getDerivedStateFromProps(props) {
    if ('value' in props) {
      return {
        value: props.value
      };
    }

    return null;
  };

  var _proto = LoadingBar.prototype;

  _proto.render = function render() {
    var _classnames;

    var _this$props = this.props,
        prefixCls = _this$props.prefixCls,
        loading = _this$props.loading,
        className = _this$props.className,
        lightPrefix = _this$props.lightPrefix,
        restProps = _objectWithoutPropertiesLoose(_this$props, ["prefixCls", "loading", "className", "lightPrefix"]);

    var value = this.state.value;
    return /*#__PURE__*/React.createElement(Progress, _extends({
      className: classnames(prefixCls, className, (_classnames = {}, _classnames[prefixCls + "-done"] = !loading, _classnames))
    }, restProps, {
      showInfo: false,
      width: "100%",
      status: "normal",
      percent: value * 100
    }));
  };

  _proto.valueControlled = function valueControlled() {
    return 'value' in this.props;
  };

  _proto.componentDidMount = function componentDidMount() {
    if (!this.valueControlled() && this.props.loading) {
      this.start();
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var loading = this.props.loading;
    var preLoading = prevProps.loading;
    var stop = preLoading === true && loading === false;
    var start = preLoading === false && loading === true;
    var valueControlled = this.valueControlled();

    if (!valueControlled && stop) {
      this.stop(true);
    } else if (!valueControlled && start) {
      this.start();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (!this.valueControlled()) {
      this.stop(true);
    }

    if (this.startHandle) {
      cancelAnimationFrame(this.startHandle);
      this.startHandle = null;
    }
  };

  _proto.start = function start() {
    var _this2 = this;

    this.stop();
    this.startHandle = requestAnimationFrame(function () {
      _this2.startHandle = null;

      _this2.step();

      var duration = _this2.props.duration;

      if (duration) {
        _this2.durationTimer = setTimeout(function () {
          _this2.stop(true);
        }, duration);
      }
    });
  };

  _proto.step = function step() {
    var _this3 = this;

    var round = this.round,
        stepValue = this.stepValue;
    var value = this.state.value;
    var newValue;

    if (round < ROUND_STOPS.length) {
      var minDelta = ROUND_DELTA_RANGE[0],
          maxDelta = ROUND_DELTA_RANGE[1];
      var delta = minDelta + Math.random() * (maxDelta - minDelta);
      newValue = Math.max(ROUND_STOPS[round] + delta, value);
    } else {
      newValue = Math.min(value + Math.max(MIN_STEP_VALUE, stepValue), 1 - MIN_STEP_VALUE);
      this.stepValue /= 2;
    }

    this.setState({
      value: newValue
    });
    this.onChange(newValue);

    if (newValue < 1) {
      var minInterval = INTERVAL_RANGE[0],
          maxInterval = INTERVAL_RANGE[1];
      var interval = minInterval + Math.random() * (maxInterval - minInterval);
      this.stepTimer = setTimeout(function () {
        _this3.round++;

        _this3.step();
      }, interval);
    } else {
      this.stop(true);
    }
  };

  _proto.stop = function stop(done) {
    clearTimeout(this.stepTimer);
    clearTimeout(this.durationTimer);
    this.stepTimer = null;
    this.durationTimer = null;
    this.round = 0;
    this.stepValue = STEP_VALUE;
    var value = done ? 1 : 0;
    this.setState({
      value: value
    });
    this.onChange(value);
  };

  _proto.onChange = function onChange(value) {
    var onChange = this.props.onChange;

    if (onChange) {
      onChange(value);
    }
  };

  return LoadingBar;
}(PureComponent), _class2.defaultProps = {
  loading: true,
  prefixCls: 'one-loading-bar',
  size: 'medium'
}, _temp)) || _class);
export default LoadingBar;