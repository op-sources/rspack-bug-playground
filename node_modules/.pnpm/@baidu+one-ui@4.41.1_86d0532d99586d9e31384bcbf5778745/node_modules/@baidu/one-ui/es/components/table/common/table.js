import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _extends from "@babel/runtime/helpers/extends";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _throttle from "lodash/throttle";
import _findIndex from "lodash/findIndex";
import _debounce from "lodash/debounce";
import React, { PureComponent } from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import addEventListener from 'rc-util/lib/Dom/addEventListener';
import { Provider, create } from 'mini-store';
import { classnames, getWindowHeight } from '../../../core/commonTools';
import classes from 'component-classes';
import Loading from '../../loading';
import ColumnManager from './columnManager';
import HeadTable from './headTable';
import BodyTable from './bodyTable';
import ExpandableTable from './expandableTable';
import DragLine from './dragLine';
import { formatTableWidth, isColumnWidthChange, recalcWidthWhenColumnsChange, resetWidthByColumnsWidth, uniformCalcWidth } from './utils';
import Context from './context';
import classNames from 'classnames';

var ComponentTable = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(ComponentTable, _PureComponent);

  function ComponentTable(_props) {
    var _this;

    _this = _PureComponent.call(this, _props) || this;
    _this.columnManager = void 0;
    _this.store = void 0;
    _this.debouncedWindowResize = void 0;
    _this.debouncedWindowScroll = void 0;
    _this.resizeEvent = void 0;
    _this.scrollEvent = void 0;
    _this.headTableWheelEvent = void 0;
    _this.headTable = void 0;
    _this.bottomScroll = void 0;
    _this.scrollPosition = void 0;
    _this.bodyTable = void 0;
    _this.tableNode = void 0;
    _this.fixedHeadTable = void 0;
    _this.lastScrollLeft = void 0;
    _this.lastScrollTop = void 0;
    _this.expander = void 0;
    _this.tableContainerRef = void 0;
    _this.dragLeftRef = void 0;
    _this.curAllColumnsWidth = void 0;
    _this.curDynamicWidth = void 0;
    _this.resizeObserver = null;

    _this.handleHeadWheel = function (event) {
      var deltaX = event.deltaX,
          currentTarget = event.currentTarget;

      if (deltaX) {
        currentTarget.scrollLeft = currentTarget.scrollLeft + deltaX;
        event.preventDefault();

        _this.handleBodyScrollLeft({
          currentTarget: currentTarget,
          target: currentTarget
        });
      }
    };

    _this.getRowKey = function (record, index) {
      var rowKey = _this.props.rowKey;
      var key = typeof rowKey === 'function' ? rowKey(record, index) : record[rowKey];
      return key === undefined ? index : key;
    };

    _this.handleWindowResize = function () {
      _this.setScrollPositionClassName();
    };

    _this.handleWindowScroll = function () {
      if (_this.props.bottomScroll.bottom == null) {
        return null;
      }

      var _assertThisInitialize = _assertThisInitialized(_this),
          headTable = _assertThisInitialize.headTable,
          bodyTable = _assertThisInitialize.bodyTable;

      if (headTable && bodyTable) {
        var bodyTableRect = bodyTable.getBoundingClientRect();

        var allColumnsWidth = _this.store.getState().allColumnsWidth;

        var tableWidth = 0;
        allColumnsWidth.forEach(function (col) {
          tableWidth += col.width;
        });
        var isBottomScrollShow = bodyTableRect.bottom > getWindowHeight() - _this.props.bottomScroll.bottom && tableWidth > bodyTableRect.width;

        if (isBottomScrollShow !== _this.state.isBottomScrollShow) {
          _this.setState({
            isBottomScrollShow: isBottomScrollShow
          });
        }
      }
    };

    _this.handleBodyScrollLeft = function (e) {
      if (e.currentTarget !== e.target) {
        return;
      }

      var target = e.target;
      var _this$props$scroll = _this.props.scroll,
          scroll = _this$props$scroll === void 0 ? {} : _this$props$scroll;

      var dynamicWidth = _this.store.getState().dynamicWidth;

      var _assertThisInitialize2 = _assertThisInitialized(_this),
          headTable = _assertThisInitialize2.headTable,
          bodyTable = _assertThisInitialize2.bodyTable,
          fixedHeadTable = _assertThisInitialize2.fixedHeadTable,
          bottomScroll = _assertThisInitialize2.bottomScroll;

      var scrollX = scroll.x === undefined ? true : scroll.x;

      if (target.scrollLeft !== _this.lastScrollLeft && (scrollX || dynamicWidth >= bodyTable.getBoundingClientRect().width)) {
        if (target === bodyTable) {
          if (headTable) {
            headTable.scrollLeft = target.scrollLeft;
          }

          if (fixedHeadTable) {
            fixedHeadTable.scrollLeft = target.scrollLeft;
          }

          if (bottomScroll) {
            bottomScroll.scrollLeft = target.scrollLeft;
          }
        } else if (target === headTable) {
          if (fixedHeadTable) {
            fixedHeadTable.scrollLeft = target.scrollLeft;
          }

          if (bodyTable) {
            bodyTable.scrollLeft = target.scrollLeft;
          }

          if (bottomScroll) {
            bottomScroll.scrollLeft = target.scrollLeft;
          }
        } else if (target === fixedHeadTable) {
          if (headTable) {
            headTable.scrollLeft = target.scrollLeft;
          }

          if (bodyTable) {
            bodyTable.scrollLeft = target.scrollLeft;
          }

          if (bottomScroll) {
            bottomScroll.scrollLeft = target.scrollLeft;
          }
        } else if (target === bottomScroll) {
          if (headTable) {
            headTable.scrollLeft = target.scrollLeft;
          }

          if (bodyTable) {
            bodyTable.scrollLeft = target.scrollLeft;
          }

          if (fixedHeadTable) {
            fixedHeadTable.scrollLeft = target.scrollLeft;
          }
        }

        _this.setScrollPositionClassName();
      } // Remember last scrollLeft for scroll direction detecting.


      _this.lastScrollLeft = target.scrollLeft;
    };

    _this.handleBodyScrollTop = function (e) {
      var target = e.target;

      if (e.currentTarget !== target) {
        return;
      }

      var _this$props$scroll2 = _this.props.scroll,
          scroll = _this$props$scroll2 === void 0 ? {} : _this$props$scroll2;

      var _assertThisInitialize3 = _assertThisInitialized(_this),
          headTable = _assertThisInitialize3.headTable,
          bodyTable = _assertThisInitialize3.bodyTable;

      if (target.scrollTop !== _this.lastScrollTop && scroll.y && target !== headTable) {
        var scrollTop = target.scrollTop;

        if (bodyTable && target !== bodyTable) {
          bodyTable.scrollTop = scrollTop;
        }
      } // Remember last scrollTop for scroll direction detecting.


      _this.lastScrollTop = target.scrollTop;
    };

    _this.handleBodyScroll = function (e) {
      _this.handleBodyScrollLeft(e);

      _this.handleBodyScrollTop(e);
    };

    _this.handleWheel = function (event) {
      var _this$props$scroll3 = _this.props.scroll,
          scroll = _this$props$scroll3 === void 0 ? {} : _this$props$scroll3;

      if (window.navigator.userAgent.match(/Trident\/7\./) && scroll.y) {
        event.preventDefault();
        var wd = event.deltaY;
        var target = event.target;

        var _assertThisInitialize4 = _assertThisInitialized(_this),
            bodyTable = _assertThisInitialize4.bodyTable;

        var scrollTop = 0;

        if (_this.lastScrollTop) {
          scrollTop = _this.lastScrollTop + wd;
        } else {
          scrollTop = wd;
        }

        if (bodyTable && target !== bodyTable) {
          bodyTable.scrollTop = scrollTop;
        }
      }
    };

    _this.saveRef = function (name) {
      return function (node) {
        _this[name] = node;

        _this.props.saveRef(name, node);
      };
    };

    _this.getContainerWidth = function () {
      return _this.bodyTable && _this.bodyTable.getBoundingClientRect().width;
    };

    _this.renderMainTable = function (expander) {
      var _classNames;

      _this.expander = expander;
      var _this$props = _this.props,
          scroll = _this$props.scroll,
          prefixCls = _this$props.prefixCls;

      var isAnyColumnsFixed = _this.columnManager.isAnyColumnsFixed();

      var scrollable = isAnyColumnsFixed || scroll.x || scroll.y;
      var table = [_this.renderTable({
        columns: _this.columnManager.groupedColumns(),
        isAnyColumnsFixed: isAnyColumnsFixed
      }), _this.renderFooter()];
      return /*#__PURE__*/React.createElement("div", {
        className: classNames(prefixCls + "-main", (_classNames = {}, _classNames[prefixCls + "-scroll"] = scrollable, _classNames))
      }, table);
    };

    _this.calcDragLeft = function (dragLeft, isMovingFixedKey) {
      var curDragLeft = dragLeft - (isMovingFixedKey ? 0 : _this.lastScrollLeft || 0);
      return curDragLeft;
    };

    _this.onDragStart = function (props) {
      if (typeof _this.props.onDragStart === 'function') {
        _this.props.onDragStart(props);
      }

      var dragLineRef = _this.dragLeftRef;
      dragLineRef.setShowLine(true);

      _this.store.setState({
        dragging: true
      });
    };

    _this.onDraging = function (props) {
      var allColumns = props.allColumns,
          inner = props.inner,
          curColumn = props.curColumn;
      var isMovingFixedKey = curColumn.fixed;
      var dragLineRef = _this.dragLeftRef;
      dragLineRef.setShowLine(true);

      if (typeof _this.props.onDraging === 'function') {
        _this.props.onDraging(props);
      }

      var tableWidth = _this.bodyTable && _this.bodyTable.clientWidth;
      var gapWidth = tableWidth > inner.dynamicWidth ? tableWidth - inner.dynamicWidth : 0;
      allColumns[allColumns.length - 1].width = allColumns[allColumns.length - 1].width + gapWidth;
      _this.curAllColumnsWidth = [].concat(allColumns);
      _this.curDynamicWidth = tableWidth > inner.dynamicWidth ? tableWidth : inner.dynamicWidth;

      var curDragLeft = _this.calcDragLeft(inner.curKeyLeft, isMovingFixedKey);

      dragLineRef.setDragLeft(curDragLeft);
    };

    _this.onDragEnd = function (props) {
      var _assertThisInitialize5 = _assertThisInitialized(_this),
          curAllColumnsWidth = _assertThisInitialize5.curAllColumnsWidth,
          curDynamicWidth = _assertThisInitialize5.curDynamicWidth;

      var dragLineRef = _this.dragLeftRef;
      dragLineRef.setShowLine(false);

      var _this$store$getState = _this.store.getState(),
          allColumnsWidth = _this$store$getState.allColumnsWidth,
          dynamicWidth = _this$store$getState.dynamicWidth;

      _this.store.setState({
        allColumnsWidth: curAllColumnsWidth || allColumnsWidth,
        dynamicWidth: curDynamicWidth || dynamicWidth,
        dragging: false
      });

      if (typeof _this.props.onDragEnd === 'function') {
        _this.props.onDragEnd(curAllColumnsWidth);
      }

      _this.handleWindowScroll();
    };

    _this.onHeaderCellMouseEnter = function (props) {
      if (!_this.store.getState().dragging) {
        var curKeyLeft = props.curKeyLeft,
            curColumn = props.curColumn;
        var dragLineRef = _this.dragLeftRef;

        var curDragLeft = _this.calcDragLeft(curKeyLeft, curColumn.fixed);

        dragLineRef.setDragLeft(curDragLeft);
        dragLineRef.setShowLine(true);
      }
    };

    _this.onHeaderCellMouseLeave = function () {
      if (!_this.store.getState().dragging) {
        var dragLineRef = _this.dragLeftRef;
        dragLineRef.setShowLine(false);
      }
    };

    _this.tableRef = function (ref) {
      _this.tableContainerRef = ref;
    };

    _this.saveDragLineRef = function (ref) {
      _this.dragLeftRef = ref;
    };

    _this.columnManager = new ColumnManager(_props.columns);
    _this.store = create({
      fixedColumnsHeadRowsHeight: [],
      fixedColumnsBodyRowsHeight: [],
      dynamicWidth: 0,
      allColumnsWidth: [],
      dragging: false
    });
    _this.state = {};

    _this.setScrollPosition('left');

    _this.debouncedWindowResize = _debounce(_this.handleWindowResize, 150);
    _this.debouncedWindowScroll = _this.handleWindowScroll.bind(_assertThisInitialized(_this));
    _this.renderBottomScroll = _this.renderBottomScroll.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = ComponentTable.prototype;

  _proto.getContext = function getContext() {
    return {
      table: {
        props: this.props,
        columnManager: this.columnManager,
        saveRef: this.saveRef,
        headTable: this.headTable,
        bottomScroll: this.bottomScroll,
        bodyTable: this.bodyTable,
        containerWidth: this.getContainerWidth()
      }
    };
  };

  ComponentTable.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.columns && nextProps.columns !== prevState.columns) {
      return {
        columns: nextProps.columns
      };
    }

    return null;
  };

  _proto.setTableScrollbar = function setTableScrollbar() {
    // 当body scrollY有占位时候，head会出现对齐问题，所以同时设定为scroll保持一致占位
    if (this.headTable && this.bodyTable) {
      if (this.bodyTable.scrollHeight > this.bodyTable.offsetHeight) {
        this.headTable.style.overflowY = 'scroll';
        this.bodyTable.style.overflowY = 'scroll';
      } else {
        this.headTable.style.overflowY = '';
        this.bodyTable.style.overflowY = this.props.bodyStyle.overflowY || 'auto';
      }
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var bodyTable = this.bodyTable;
    this.setState({
      containerWidth: this.getContainerWidth()
    });
    var scroll = this.props.scroll || {};
    var bodyWidth = formatTableWidth(bodyTable, scroll, this.props.expandedRowRender);
    var allColumnsWidth = this.columnManager.allColumnsWidth(bodyWidth);
    this.store.setState({
      allColumnsWidth: uniformCalcWidth(allColumnsWidth, bodyWidth)
    });

    if (this.columnManager.isAnyColumnsFixed()) {
      var that = this;
      that.handleWindowResize();
      this.resizeEvent = addEventListener(window, 'resize', this.debouncedWindowResize);
    }

    if (this.props.headerFixTop !== null || this.props.bottomScroll.bottom !== null) {
      this.handleWindowScroll();
      this.scrollEvent = addEventListener(window, 'scroll', this.debouncedWindowScroll);
    }

    if (this.headTable) {
      this.headTableWheelEvent = addEventListener(this.headTable, 'wheel', this.handleHeadWheel);
    }

    this.setTableScrollbar();

    if (this.props.updateWidthChange) {
      var resize = _throttle(function () {
        var _this2$props = _this2.props,
            scroll = _this2$props.scroll,
            expandedRowRender = _this2$props.expandedRowRender;
        var curBodyWidth = formatTableWidth(_this2.bodyTable, scroll, expandedRowRender);

        if (curBodyWidth === bodyWidth) {
          return;
        } // 宽度发生变化的时候的时候，强制重绘


        var allColumnsWidth = recalcWidthWhenColumnsChange(_this2.store.getState().allColumnsWidth, _this2.props.columns, _this2.props.columns, curBodyWidth);

        _this2.store.setState({
          dynamicWidth: 0,
          allColumnsWidth: uniformCalcWidth(allColumnsWidth, curBodyWidth)
        });

        _this2.forceUpdate();

        bodyWidth = curBodyWidth;
      }, 16);

      this.resizeObserver = new ResizeObserver(function (entries) {
        entries.forEach(function (_ref) {
          var target = _ref.target,
              contentRect = _ref.contentRect;

          if (target === _this2.tableNode) {
            resize();
          }
        });
      });

      if (this.tableNode) {
        this.resizeObserver.observe(this.tableNode);
      }
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.columnManager.isAnyColumnsFixed()) {
      this.handleWindowResize();

      if (!this.resizeEvent) {
        this.resizeEvent = addEventListener(window, 'resize', this.debouncedWindowResize);
      }
    } // when table changes to empty, reset scrollLeft


    if (prevProps.data.length > 0 && this.props.data.length === 0 && this.hasScrollX()) {
      this.resetScrollX();
    }

    if (this.props.headerFixTop !== null || this.props.bottomScroll.bottom !== null) {
      this.handleWindowScroll();

      if (!this.scrollEvent) {
        this.scrollEvent = addEventListener(window, 'scroll', this.debouncedWindowScroll);
      }

      if (this.headTable) {
        this.headTable.scrollLeft = this.lastScrollLeft;
      }

      if (this.fixedHeadTable) {
        this.fixedHeadTable.scrollLeft = this.lastScrollLeft;
      }

      if (this.bottomScroll) {
        this.bottomScroll.scrollLeft = this.lastScrollLeft;
      }
    }

    if (!this.headTable && this.headTableWheelEvent) {
      this.headTableWheelEvent.remove();
      this.headTableWheelEvent = null;
    } else if (this.headTable && !this.headTableWheelEvent) {
      this.headTableWheelEvent = addEventListener(this.headTable, 'wheel', this.handleHeadWheel);
    }

    this.setTableScrollbar();

    if (this.props.columns && prevProps.columns !== this.props.columns && isColumnWidthChange(prevProps.columns, this.props.columns)) {
      var bodyTable = this.bodyTable;
      var bodyWidth = formatTableWidth(bodyTable, this.props.scroll, this.props.expandedRowRender);
      var allColumnsWidth = this.store.getState().allColumnsWidth;
      var columns = recalcWidthWhenColumnsChange(allColumnsWidth, this.props.columns, prevProps.columns, bodyWidth);
      var newColumns = uniformCalcWidth(columns, bodyWidth);
      this.store.setState({
        dynamicWidth: 0,
        allColumnsWidth: newColumns
      });
      this.forceUpdate();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.resizeEvent) {
      this.resizeEvent.remove();
      this.resizeEvent = null;
    }

    if (this.debouncedWindowResize) {
      this.debouncedWindowResize.cancel();
      this.debouncedWindowResize = null;
    }

    if (this.scrollEvent) {
      this.scrollEvent.remove();
      this.scrollEvent = null;
    }

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }

    if (this.headTableWheelEvent) {
      this.headTableWheelEvent.remove();
      this.headTableWheelEvent = null;
    }
  };

  _proto.updateColumnWidths = function updateColumnWidths(columns) {
    var bodyTable = this.bodyTable;
    var bodyWidth = formatTableWidth(bodyTable, this.props.scroll, this.props.expandedRowRender);
    var resetColumns = columns || this.props.columns;
    var resetColumnsSelection = resetColumns.filter(function (col) {
      return col.key === 'selection-column';
    })[0];
    var oriAllColumnsWidth = this.store.getState().allColumnsWidth;
    var oriSelection = oriAllColumnsWidth.filter(function (col) {
      return col.key === 'selection-column';
    })[0];

    if (oriSelection && !resetColumnsSelection) {
      var index = _findIndex(oriAllColumnsWidth, {
        key: 'selection-column'
      });

      resetColumns.splice(index, 0, oriSelection);
    }

    var allColumnsWidth = resetWidthByColumnsWidth(resetColumns, bodyWidth);
    var newColumns = uniformCalcWidth(allColumnsWidth, bodyWidth);
    this.store.setState({
      dynamicWidth: 0,
      allColumnsWidth: newColumns
    });
  };

  _proto.setScrollPosition = function setScrollPosition(position) {
    this.scrollPosition = position;

    if (this.tableNode) {
      var prefixCls = this.props.prefixCls;

      if (position === 'both') {
        classes(this.tableNode).remove(new RegExp("^" + prefixCls + "-scroll-position-.+$")).add(prefixCls + "-scroll-position-left").add(prefixCls + "-scroll-position-right");
      } else {
        classes(this.tableNode).remove(new RegExp("^" + prefixCls + "-scroll-position-.+$")).add(prefixCls + "-scroll-position-" + position);
      }
    }
  };

  _proto.setScrollPositionClassName = function setScrollPositionClassName() {
    var node = this.bodyTable;
    var scrollToLeft = node.scrollLeft === 0;
    var scrollToRight = node.scrollLeft >= node.children[0].getBoundingClientRect().width - node.getBoundingClientRect().width;

    if (scrollToLeft && scrollToRight) {
      this.setScrollPosition('both');
    } else if (scrollToLeft) {
      this.setScrollPosition('left');
    } else if (scrollToRight) {
      this.setScrollPosition('right');
    } else if (this.scrollPosition !== 'middle') {
      this.setScrollPosition('middle');
    }
  };

  _proto.resetScrollX = function resetScrollX() {
    if (this.headTable) {
      this.headTable.scrollLeft = 0;
    }

    if (this.fixedHeadTable) {
      this.fixedHeadTable.scrollLeft = 0;
    }

    if (this.bodyTable) {
      this.bodyTable.scrollLeft = 0;
    }

    if (this.bottomScroll) {
      this.bottomScroll.scrollLeft = 0;
    }
  };

  _proto.hasScrollX = function hasScrollX() {
    var _this$props$scroll4 = this.props.scroll,
        scroll = _this$props$scroll4 === void 0 ? {} : _this$props$scroll4;
    return 'x' in scroll;
  };

  _proto.renderTable = function renderTable(options) {
    var columns = options.columns,
        fixed = options.fixed,
        isAnyColumnsFixed = options.isAnyColumnsFixed;
    var _this$props2 = this.props,
        prefixCls = _this$props2.prefixCls,
        _this$props2$scroll = _this$props2.scroll,
        scroll = _this$props2$scroll === void 0 ? {} : _this$props2$scroll,
        updateWidthChange = _this$props2.updateWidthChange,
        useStickyFixTop = _this$props2.useStickyFixTop;
    var tableClassName = scroll.x || fixed ? prefixCls + "-fixed" : '';
    var headTable = /*#__PURE__*/React.createElement(HeadTable, {
      key: "head",
      columns: columns,
      tableClassName: tableClassName,
      handleBodyScrollLeft: this.handleBodyScrollLeft,
      expander: this.expander,
      onDragStart: this.onDragStart,
      onDraging: this.onDraging,
      onDragEnd: this.onDragEnd,
      onHeaderCellMouseEnter: this.onHeaderCellMouseEnter,
      onHeaderCellMouseLeave: this.onHeaderCellMouseLeave,
      updateWidthChange: updateWidthChange,
      useStickyFixTop: useStickyFixTop
    });
    var bodyTable = /*#__PURE__*/React.createElement(BodyTable, {
      key: "body",
      columns: columns,
      tableClassName: tableClassName,
      getRowKey: this.getRowKey,
      handleWheel: this.handleWheel,
      handleBodyScroll: this.handleBodyScroll,
      expander: this.expander,
      isAnyColumnsFixed: isAnyColumnsFixed,
      onDragStart: this.onDragStart,
      onDraging: this.onDraging,
      onDragEnd: this.onDragEnd,
      onHeaderCellMouseEnter: this.onHeaderCellMouseEnter,
      onHeaderCellMouseLeave: this.onHeaderCellMouseLeave
    });
    return [headTable, bodyTable];
  };

  _proto.renderBottomScroll = function renderBottomScroll() {
    var bodyTable = this.bodyTable;
    var prefixCls = this.props.prefixCls;
    var _this$props$bottomScr = this.props.bottomScroll,
        style = _this$props$bottomScr.style,
        bottom = _this$props$bottomScr.bottom;

    var scrollContainerStyle = _extends({}, style, {
      bottom: bottom
    });

    if (bodyTable) {
      var _bodyTable$getBoundin = bodyTable.getBoundingClientRect(),
          left = _bodyTable$getBoundin.left,
          width = _bodyTable$getBoundin.width;

      scrollContainerStyle.width = width;
      scrollContainerStyle.left = left;
    }

    var allColumnsWidth = this.store.getState().allColumnsWidth;
    var tableWidth = 0;
    allColumnsWidth.forEach(function (col) {
      tableWidth += col.width;
    });
    var scrollContentStyle = {
      width: tableWidth
    };
    var bottomScroll = /*#__PURE__*/React.createElement("div", {
      className: prefixCls + "-scroll-container",
      style: scrollContainerStyle,
      ref: this.saveRef('bottomScroll'),
      onScroll: this.handleBodyScrollLeft
    }, /*#__PURE__*/React.createElement("div", {
      className: prefixCls + "-scroll-content",
      style: scrollContentStyle,
      ref: this.saveRef('bottomScrollContent')
    }));
    return bottomScroll;
  };

  _proto.renderTitle = function renderTitle() {
    var _this$props3 = this.props,
        title = _this$props3.title,
        prefixCls = _this$props3.prefixCls;
    return title ? /*#__PURE__*/React.createElement("div", {
      className: prefixCls + "-title",
      key: "title"
    }, title(this.props.data)) : null;
  };

  _proto.renderFooter = function renderFooter() {
    var _this$props4 = this.props,
        footer = _this$props4.footer,
        prefixCls = _this$props4.prefixCls;
    return footer ? /*#__PURE__*/React.createElement("div", {
      className: prefixCls + "-footer",
      key: "footer"
    }, footer(this.props.data)) : null;
  };

  _proto.render = function render() {
    var _classnames,
        _this3 = this;

    var _this$props5 = this.props,
        prefixCls = _this$props5.prefixCls,
        className = _this$props5.className,
        children = _this$props5.children,
        columns = _this$props5.columns,
        scroll = _this$props5.scroll,
        useFixedHeader = _this$props5.useFixedHeader,
        useStickyFixTop = _this$props5.useStickyFixTop,
        headerFixTop = _this$props5.headerFixTop,
        bottomScroll = _this$props5.bottomScroll,
        id = _this$props5.id,
        style = _this$props5.style,
        loading = _this$props5.loading,
        loadingOption = _this$props5.loadingOption,
        loadingText = _this$props5.loadingText,
        size = _this$props5.size,
        resetProps = _objectWithoutPropertiesLoose(_this$props5, ["prefixCls", "className", "children", "columns", "scroll", "useFixedHeader", "useStickyFixTop", "headerFixTop", "bottomScroll", "id", "style", "loading", "loadingOption", "loadingText", "size"]);

    if (this.state.columns) {
      this.columnManager.reset(columns);
    }

    var classNames = classnames(prefixCls, className, (_classnames = {}, _classnames[prefixCls + "-fixed-header"] = useFixedHeader || scroll && scroll.y, _classnames[prefixCls + "-scroll-position-left"] = this.scrollPosition === 'both', _classnames[prefixCls + "-scroll-position-right"] = this.scrollPosition === 'both', _classnames[prefixCls + "-scroll-position-" + this.scrollPosition] = this.scrollPosition !== 'both', _classnames[prefixCls + "-sticky-top"] = useStickyFixTop && typeof headerFixTop === 'number', _classnames));
    var hasBottomScroll = this.state.isBottomScrollShow && bottomScroll.bottom !== null;
    return /*#__PURE__*/React.createElement(Provider, {
      store: this.store,
      ref: this.tableRef
    }, /*#__PURE__*/React.createElement(Context.Provider, {
      value: this.getContext()
    }, /*#__PURE__*/React.createElement("div", {
      ref: this.saveRef('tableNode'),
      className: classNames,
      style: style,
      id: id
    }, this.renderTitle(), /*#__PURE__*/React.createElement("div", {
      className: prefixCls + "-content"
    }, /*#__PURE__*/React.createElement(ExpandableTable, _extends({
      prefixCls: prefixCls
    }, resetProps, {
      columns: columns,
      columnManager: this.columnManager,
      getRowKey: this.getRowKey
    }), function (expander) {
      return _this3.renderMainTable(expander);
    }), hasBottomScroll && this.renderBottomScroll(), /*#__PURE__*/React.createElement(DragLine, {
      prefixCls: prefixCls,
      ref: this.saveDragLineRef
    })), loading && loadingOption && loadingOption.type === 'spinner' && /*#__PURE__*/React.createElement(Loading, {
      className: prefixCls + "-loading",
      tip: loadingText,
      size: size
    }, /*#__PURE__*/React.createElement("span", null)))));
  };

  return ComponentTable;
}(PureComponent);

ComponentTable.defaultProps = {
  headerFixTop: null,
  data: [],
  useFixedHeader: false,
  rowKey: 'key',
  rowClassName: function rowClassName() {
    return '';
  },
  onRow: function onRow() {},
  onHeaderRow: function onHeaderRow() {},
  prefixCls: 'one-table',
  bodyStyle: {},
  style: {},
  showHeader: true,
  scroll: {},
  bottomScroll: {
    bottom: null,
    style: {}
  },
  rowRef: function rowRef() {
    return null;
  },
  emptyText: function emptyText() {
    return '暂无数据';
  },
  updateWidthChange: false,
  useStickyFixTop: true
};
export default ComponentTable;