import _extends from "@babel/runtime/helpers/extends";

/**
 * @file 表格内部工具方法
 * @author huangshiming
 * @date 2020-05-15
 */
export var expandIconWidth = 38;
export var formatCellWidth = function formatCellWidth(width, totalWidth) {
  if (typeof width === 'string') {
    if (width.indexOf('%') > -1) {
      return Math.floor(+width.split('%')[0] / 100 * totalWidth);
    } else if (width.indexOf('px') > -1) {
      return +width.split('px')[0];
    }

    return +width;
  }

  return width;
};
export var formatNormalWidth = function formatNormalWidth(tableWidth, leftColumns) {
  if (leftColumns === void 0) {
    leftColumns = [];
  }

  var noWidthColumns = leftColumns.filter(function (col) {
    return !col.width;
  }) || [];
  var hasWidthColumns = leftColumns.filter(function (col) {
    return col.width;
  }) || [];
  var spitWidth = 0;
  hasWidthColumns.forEach(function (col) {
    spitWidth += formatCellWidth(col.width, tableWidth);
  });
  var remainWidth = tableWidth - spitWidth;
  return remainWidth / (noWidthColumns || []).length;
};
export var formatCellLeft = function formatCellLeft(width, prevWidth, totalWidth) {
  if (!width) {
    return prevWidth;
  }

  if (typeof width === 'string') {
    if (width.indexOf('%') > -1 && totalWidth) {
      var calWidth = Math.floor(+width.split('%')[0] / 100 * totalWidth);
      return calWidth + prevWidth;
    } else if (width.indexOf('px') > -1) {
      return +width.split('px')[0] + prevWidth;
    }
  }

  return width + prevWidth;
};
export var formatTableWidthWithAllColumnsWidth = function formatTableWidthWithAllColumnsWidth(allColumnsWidth) {
  if (!(allColumnsWidth && allColumnsWidth.length)) {
    return null;
  }

  var tableWidth = 0;
  allColumnsWidth.forEach(function (col) {
    tableWidth += col.width;
  });
  return tableWidth;
};
export var formatTableWidth = function formatTableWidth(bodyTable, scroll, expandedRowRender) {
  var bodyWidth;
  var width = bodyTable.getBoundingClientRect().width;

  if (typeof scroll.x === 'number') {
    bodyWidth = scroll.x;
  } else if (typeof scroll.x === 'string') {
    if (scroll.x.indexOf('px') > -1) {
      bodyWidth = +scroll.x.split('px')[0];
    } else if (scroll.x.indexOf('%') > -1) {
      bodyWidth = Math.floor(width * (+scroll.x.split('%')[0] / 100));
    }
  } else {
    bodyWidth = width;
  }

  return bodyWidth;
};
export var isColumnWidthChange = function isColumnWidthChange(originColumns, newColumns) {
  if (originColumns === void 0) {
    originColumns = [];
  }

  if (newColumns === void 0) {
    newColumns = [];
  }

  if (originColumns.length !== newColumns.length) {
    return true;
  }

  return newColumns.some(function (_ref, index) {
    var width = _ref.width,
        fixed = _ref.fixed,
        maxWidth = _ref.maxWidth,
        minWidth = _ref.minWidth,
        children = _ref.children;
    var col = originColumns[index];

    if (!col || width !== col.width || fixed !== col.fixed || maxWidth !== col.maxWidth || minWidth !== col.minWidth) {
      return true;
    }

    if ((col.children || children) && isColumnWidthChange(col.children, children)) {
      return true;
    }
  });
};
export var leafColumns = function leafColumns(columns) {
  var leafColumn = [];
  columns.forEach(function (column) {
    if (!column.children) {
      leafColumn.push(column);
    } else {
      leafColumn.push.apply(leafColumn, leafColumns(column.children));
    }
  });
  return leafColumn;
};
export var recalcWidthWhenColumnsChange = function recalcWidthWhenColumnsChange(allColumnsWidth, newColumns, oldColumns, tableWidth) {
  if (allColumnsWidth === void 0) {
    allColumnsWidth = [];
  }

  if (newColumns === void 0) {
    newColumns = [];
  }

  if (oldColumns === void 0) {
    oldColumns = [];
  }

  var columsMap = {};
  var oldColumnsMap = {};
  allColumnsWidth.forEach(function (col) {
    columsMap[col.key || col.dataIndex] = col;
  });
  leafColumns(oldColumns).forEach(function (col) {
    oldColumnsMap[col.key || col.dataIndex] = col;
  });
  var curWidth = 0;
  var leftColumns = leafColumns(newColumns);
  ;
  var fixedWidth = leftColumns.filter(function (col) {
    return col.fixedWidth;
  }).reduce(function (width, col) {
    return col.width + width;
  }, 0);
  var tableCalcWidth = tableWidth - fixedWidth;
  var normalWidth = formatNormalWidth(tableWidth, leftColumns);
  var prevCol;
  return leftColumns.map(function (column, index) {
    var key = column.key || column.dataIndex;
    var oldCol = oldColumnsMap[key];
    var col = columsMap[key];
    var keepLastWidth = leftColumns.length - 1 === index && prevCol && prevCol.dragged;
    var width = column.fixedWidth ? column.width : formatCellWidth(column.draggable && oldCol && oldCol.width === column.width ? col && (col.dragged || keepLastWidth) && col.width || column.width || normalWidth : column.width || normalWidth, tableCalcWidth);
    var minWidth = column.fixedWidth ? width : formatCellWidth(column.minWidth || column.width || normalWidth, tableCalcWidth);
    var maxWidth = column.fixedWidth ? width : formatCellWidth(column.maxWidth, tableCalcWidth) || null;
    curWidth = formatCellLeft(width, curWidth, tableCalcWidth);
    prevCol = col;
    return _extends({}, col, {
      key: key,
      width: width,
      minWidth: minWidth,
      maxWidth: maxWidth,
      left: curWidth,
      fixed: column.fixed
    });
  });
};
export var resetWidthByColumnsWidth = function resetWidthByColumnsWidth(newColumns, tableWidth) {
  if (newColumns === void 0) {
    newColumns = [];
  }

  var leftColumns = leafColumns(newColumns);
  var fixedWidth = leftColumns.filter(function (col) {
    return col.fixedWidth;
  }).reduce(function (width, col) {
    return col.width + width;
  }, 0);
  var tableCalcWidth = tableWidth - fixedWidth;
  var normalWidth = formatNormalWidth(tableWidth, leftColumns);
  var curWidth = 0;
  return leftColumns.map(function (column) {
    var key = column.key || column.dataIndex;
    var width = column.fixedWidth ? column.width : formatCellWidth(column.width || normalWidth, tableCalcWidth);
    var minWidth = column.fixedWidth ? column.width : formatCellWidth(column.minWidth || column.width || normalWidth, tableCalcWidth);
    var maxWidth = column.fixedWidth ? column.width : formatCellWidth(column.maxWidth, tableCalcWidth) || null;
    curWidth = formatCellLeft(width, curWidth, tableCalcWidth);
    return {
      key: key,
      width: width,
      minWidth: minWidth,
      maxWidth: maxWidth,
      left: curWidth,
      fixed: column.fixed,
      fixedWidth: column.fixedWidth
    };
  });
};
export var uniformCalcWidth = function uniformCalcWidth(columns, tableWidth) {
  if (!columns || !columns.length) {
    return columns;
  }

  var newColumnsWidth = 0;
  columns.forEach(function (col) {
    newColumnsWidth += col.width;
  });

  if (newColumnsWidth >= tableWidth) {
    return columns;
  }

  var gapWidth = tableWidth - newColumnsWidth;
  var fixedWidthColumns = columns.filter(function (col) {
    return col.fixedWidth;
  });
  var everyColAddWidth = 0;

  if (columns.length > fixedWidthColumns.length) {
    everyColAddWidth = gapWidth / (columns.length - fixedWidthColumns.length);
  }

  var curWidth = 0;
  var newColumns = columns.map(function (column) {
    var key = column.key || column.dataIndex;
    var width = column.fixedWidth ? column.width : formatCellWidth(column.width + everyColAddWidth, tableWidth);
    var minWidth = column.fixedWidth ? column.width : formatCellWidth(column.minWidth, tableWidth);
    var maxWidth = column.fixedWidth ? column.width : formatCellWidth(column.maxWidth, tableWidth) || null;
    curWidth = formatCellLeft(width, curWidth, tableWidth);
    return _extends({}, column, {
      key: key,
      width: width,
      minWidth: minWidth,
      maxWidth: maxWidth,
      left: curWidth
    });
  });
  var columnsWidth = 0;
  newColumns.forEach(function (col) {
    columnsWidth += col.width;
  });

  if (columnsWidth < tableWidth) {
    newColumns[newColumns.length - 1].width += tableWidth - columnsWidth;
  }

  return newColumns;
};