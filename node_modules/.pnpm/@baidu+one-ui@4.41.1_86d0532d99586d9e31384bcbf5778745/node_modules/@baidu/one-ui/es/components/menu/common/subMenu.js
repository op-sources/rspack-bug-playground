import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _extends from "@babel/runtime/helpers/extends";
import React from 'react';
import { IconChevronDown, IconChevronRight } from 'dls-icons-react';
import Trigger from 'rc-trigger';
import KeyCode from 'rc-util/lib/KeyCode';
import CSSMotion from 'rc-animate/lib/CSSMotion';
import { classnames } from '../../../core/commonTools';
import { connect } from 'mini-store';
import SubPopupMenu from './subPopupMenu';
import placements from './placements';
import { loopMenuItemRecursively, getMenuIdFromSubMenuEventKey } from './util';
import Context from '../context';
import omit from 'omit.js';
import ReactDOM from 'react-dom';
var guid = 0;
var popupPlacementMap = {
  horizontal: 'bottomLeft',
  vertical: 'rightTop',
  'vertical-left': 'rightTop',
  'vertical-right': 'leftTop'
};

var updateDefaultActiveFirst = function updateDefaultActiveFirst(store, eventKey, defaultActiveFirst) {
  var _extends2;

  var menuId = getMenuIdFromSubMenuEventKey(eventKey);
  var state = store.getState();
  store.setState({
    defaultActiveFirst: _extends({}, state.defaultActiveFirst, (_extends2 = {}, _extends2[menuId] = defaultActiveFirst, _extends2))
  });
};

export var SubMenu = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(SubMenu, _React$Component);

  function SubMenu(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.isRootMenu = void 0;
    _this.mouseenterTimeout = void 0;
    _this.minWidthTimeout = void 0;
    _this.subMenuTitle = void 0;
    _this.menuInstance = void 0;
    _this.haveRendered = void 0;
    _this.haveOpened = void 0;

    _this.onDestroy = function (key) {
      _this.props.onDestroy(key);
    };

    _this.onKeyDown = function (e) {
      var keyCode = e.keyCode;
      var menu = _this.menuInstance;
      var _this$props = _this.props,
          isOpen = _this$props.isOpen,
          store = _this$props.store;

      if (keyCode === KeyCode.ENTER) {
        _this.onTitleClick(e);

        updateDefaultActiveFirst(store, _this.props.eventKey, true);
        return true;
      }

      if (keyCode === KeyCode.RIGHT) {
        if (isOpen) {
          menu.onKeyDown(e);
        } else {
          _this.triggerOpenChange(true); // need to update current menu's defaultActiveFirst value


          updateDefaultActiveFirst(store, _this.props.eventKey, true);
        }

        return true;
      }

      if (keyCode === KeyCode.LEFT) {
        var handled;

        if (isOpen) {
          handled = menu.onKeyDown(e);
        } else {
          return undefined;
        }

        if (!handled) {
          _this.triggerOpenChange(false);

          handled = true;
        }

        return handled;
      }

      if (isOpen && (keyCode === KeyCode.UP || keyCode === KeyCode.DOWN)) {
        return menu.onKeyDown(e);
      }

      return undefined;
    };

    _this.onOpenChange = function (e) {
      _this.props.onOpenChange(e);
    };

    _this.onPopupVisibleChange = function (visible) {
      _this.triggerOpenChange(visible, visible ? 'mouseenter' : 'mouseleave');
    };

    _this.onMouseEnter = function (e) {
      var _this$props2 = _this.props,
          key = _this$props2.eventKey,
          onMouseEnter = _this$props2.onMouseEnter,
          store = _this$props2.store;
      updateDefaultActiveFirst(store, _this.props.eventKey, false);
      onMouseEnter({
        key: key,
        domEvent: e
      });
    };

    _this.onMouseLeave = function (e) {
      var _this$props3 = _this.props,
          parentMenu = _this$props3.parentMenu,
          eventKey = _this$props3.eventKey,
          onMouseLeave = _this$props3.onMouseLeave;
      parentMenu.subMenuInstance = _assertThisInitialized(_this);
      onMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    _this.onTitleMouseEnter = function (domEvent) {
      var _this$props4 = _this.props,
          key = _this$props4.eventKey,
          onItemHover = _this$props4.onItemHover,
          onTitleMouseEnter = _this$props4.onTitleMouseEnter;
      onItemHover({
        key: key,
        hover: true
      });
      onTitleMouseEnter({
        key: key,
        domEvent: domEvent
      });
    };

    _this.onTitleMouseLeave = function (e) {
      var _this$props5 = _this.props,
          parentMenu = _this$props5.parentMenu,
          eventKey = _this$props5.eventKey,
          onItemHover = _this$props5.onItemHover,
          onTitleMouseLeave = _this$props5.onTitleMouseLeave;
      parentMenu.subMenuInstance = _assertThisInitialized(_this);
      onItemHover({
        key: eventKey,
        hover: false
      });
      onTitleMouseLeave({
        key: eventKey,
        domEvent: e
      });
    };

    _this.onTitleClick = function (e) {
      var _this$props6 = _this.props,
          onTitleClick = _this$props6.onTitleClick,
          eventKey = _this$props6.eventKey,
          mode = _this$props6.mode,
          isOpen = _this$props6.isOpen,
          store = _this$props6.store;
      onTitleClick({
        key: eventKey,
        domEvent: e
      });

      if (mode !== 'inline') {
        return;
      }

      _this.triggerOpenChange(!isOpen, 'click');

      updateDefaultActiveFirst(store, eventKey, false);
    };

    _this.onSubMenuClick = function (info) {
      // in the case of overflowed submenu
      // onClick is not copied over
      if (typeof _this.props.onClick === 'function') {
        _this.props.onClick(_this.addKeyPath(info));
      }
    };

    _this.onSelect = function (info) {
      _this.props.onSelect(info);
    };

    _this.onDeselect = function (info) {
      _this.props.onDeselect(info);
    };

    _this.getPrefixCls = function () {
      return _this.props.prefixCls + "-submenu";
    };

    _this.getActiveClassName = function () {
      return _this.getPrefixCls() + "-active";
    };

    _this.getDisabledClassName = function () {
      return _this.getPrefixCls() + "-disabled";
    };

    _this.getSelectedClassName = function () {
      return _this.getPrefixCls() + "-selected";
    };

    _this.getOpenClassName = function () {
      return _this.props.prefixCls + "-submenu-open";
    };

    _this.saveMenuInstance = function (c) {
      // children menu instance
      _this.menuInstance = c;
    };

    _this.addKeyPath = function (info) {
      return _extends({}, info, {
        keyPath: (info.keyPath || []).concat(_this.props.eventKey)
      });
    };

    _this.triggerOpenChange = function (open, type) {
      var key = _this.props.eventKey;

      var openChange = function openChange() {
        _this.onOpenChange({
          key: key,
          item: _assertThisInitialized(_this),
          trigger: type,
          open: open
        });
      };

      if (type === 'mouseenter') {
        // make sure mouseenter happen after other menu item's mouseleave
        _this.mouseenterTimeout = setTimeout(function () {
          openChange();
        }, 0);
      } else {
        openChange();
      }
    };

    _this.isChildrenSelected = function () {
      var ret = {
        find: false
      };
      loopMenuItemRecursively(_this.props.children, _this.props.selectedKeys, ret);
      return ret.find;
    };

    _this.adjustWidth = function () {
      if (!_this.subMenuTitle || !_this.menuInstance) {
        return;
      }

      var popupMenu = ReactDOM.findDOMNode(_this.menuInstance);

      if (popupMenu.offsetWidth >= _this.subMenuTitle.offsetWidth) {
        return;
      }

      popupMenu.style.minWidth = _this.subMenuTitle.offsetWidth + "px";
    };

    _this.saveSubMenuTitle = function (subMenuTitle) {
      _this.subMenuTitle = subMenuTitle;
    };

    _this.internalMenuId = void 0;
    var _store = props.store,
        _eventKey = props.eventKey;

    var _store$getState = _store.getState(),
        defaultActiveFirst = _store$getState.defaultActiveFirst;

    _this.isRootMenu = false;
    var value = false;

    if (defaultActiveFirst) {
      value = defaultActiveFirst[_eventKey];
    }

    updateDefaultActiveFirst(_store, _eventKey, value);
    return _this;
  }

  var _proto = SubMenu.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.componentDidUpdate();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    var _this2 = this;

    var _this$props7 = this.props,
        mode = _this$props7.mode,
        parentMenu = _this$props7.parentMenu,
        manualRef = _this$props7.manualRef,
        isOpen = _this$props7.isOpen; // invoke customized ref to expose component to mixin

    if (manualRef) {
      manualRef(this);
    } // @ts-ignore 暂时保留horizontal逻辑


    if (mode !== 'horizontal' || !parentMenu.isRootMenu || !isOpen) {
      return;
    }

    this.minWidthTimeout = setTimeout(function () {
      return _this2.adjustWidth();
    }, 0);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var _this$props8 = this.props,
        onDestroy = _this$props8.onDestroy,
        eventKey = _this$props8.eventKey;

    if (onDestroy) {
      onDestroy(eventKey);
    }

    clearTimeout(this.minWidthTimeout);
    clearTimeout(this.mouseenterTimeout);
  };

  _proto.renderChildren = function renderChildren(children) {
    var _this3 = this;

    var _this$props9 = this.props,
        mode = _this$props9.mode,
        isOpen = _this$props9.isOpen,
        level = _this$props9.level,
        inlineIndent = _this$props9.inlineIndent,
        selectedKeys = _this$props9.selectedKeys,
        eventKey = _this$props9.eventKey,
        openKeys = _this$props9.openKeys,
        motion = _this$props9.motion,
        subMenuOpenDelay = _this$props9.subMenuOpenDelay,
        subMenuCloseDelay = _this$props9.subMenuCloseDelay,
        forceSubMenuRender = _this$props9.forceSubMenuRender,
        triggerSubMenuAction = _this$props9.triggerSubMenuAction,
        builtinPlacements = _this$props9.builtinPlacements,
        multiple = _this$props9.multiple,
        prefixCls = _this$props9.prefixCls,
        store = _this$props9.store;
    var baseProps = {
      mode: mode === 'horizontal' ? 'vertical' : mode,
      visible: isOpen,
      level: level + 1,
      inlineIndent: inlineIndent,
      focusable: false,
      onClick: this.onSubMenuClick,
      onSelect: this.onSelect,
      onDeselect: this.onDeselect,
      onDestroy: this.onDestroy,
      selectedKeys: selectedKeys,
      eventKey: eventKey + "-menu-",
      openKeys: openKeys,
      motion: motion,
      onOpenChange: this.onOpenChange,
      subMenuOpenDelay: subMenuOpenDelay,
      parentMenu: this,
      subMenuCloseDelay: subMenuCloseDelay,
      forceSubMenuRender: forceSubMenuRender,
      triggerSubMenuAction: triggerSubMenuAction,
      builtinPlacements: builtinPlacements,
      defaultActiveFirst: store.getState().defaultActiveFirst[getMenuIdFromSubMenuEventKey(eventKey)],
      multiple: multiple,
      prefixCls: prefixCls,
      id: this.internalMenuId,
      manualRef: this.saveMenuInstance
    };
    var haveRendered = this.haveRendered;
    this.haveRendered = true;
    this.haveOpened = this.haveOpened || baseProps.visible || baseProps.forceSubMenuRender; // never rendered not planning to, don't render

    if (!this.haveOpened) {
      return /*#__PURE__*/React.createElement("div", null);
    } // ================== Motion ==================
    // don't show transition on first rendering (no animation for opened menu)
    // show appear transition if it's not visible (not sure why)
    // show appear transition if it's not inline mode


    var mergedMotion = _extends({}, motion, {
      leavedClassName: prefixCls + "-hidden",
      removeOnLeave: false,
      motionAppear: haveRendered || !baseProps.visible || baseProps.mode !== 'inline'
    });

    return /*#__PURE__*/React.createElement(CSSMotion, _extends({
      visible: baseProps.visible
    }, mergedMotion), function (_ref) {
      var className = _ref.className,
          style = _ref.style;
      var mergedClassName = classnames(baseProps.prefixCls + "-sub", className);
      return /*#__PURE__*/React.createElement(SubPopupMenu, _extends({}, baseProps, {
        id: _this3.internalMenuId,
        className: mergedClassName,
        style: style
      }), children);
    });
  };

  _proto.render = function render() {
    var _classnames, _classnames2;

    var _this$props10 = this.props,
        isOpen = _this$props10.isOpen,
        className = _this$props10.className,
        active = _this$props10.active,
        disabled = _this$props10.disabled,
        mode = _this$props10.mode,
        eventKey = _this$props10.eventKey,
        level = _this$props10.level,
        title = _this$props10.title,
        parentMenu = _this$props10.parentMenu,
        children = _this$props10.children,
        popupOffset = _this$props10.popupOffset,
        popupClassName = _this$props10.popupClassName,
        triggerSubMenuAction = _this$props10.triggerSubMenuAction,
        subMenuOpenDelay = _this$props10.subMenuOpenDelay,
        forceSubMenuRender = _this$props10.forceSubMenuRender,
        subMenuCloseDelay = _this$props10.subMenuCloseDelay,
        builtinPlacements = _this$props10.builtinPlacements,
        onClick = _this$props10.onClick,
        lightPrefix = _this$props10.lightPrefix,
        restProps = _objectWithoutPropertiesLoose(_this$props10, ["isOpen", "className", "active", "disabled", "mode", "eventKey", "level", "title", "parentMenu", "children", "popupOffset", "popupClassName", "triggerSubMenuAction", "subMenuOpenDelay", "forceSubMenuRender", "subMenuCloseDelay", "builtinPlacements", "onClick", "lightPrefix"]);

    var prefixCls = this.getPrefixCls();
    var isInlineMode = mode === 'inline';

    if (!this.internalMenuId) {
      if (eventKey) {
        this.internalMenuId = eventKey + "$Menu";
      } else {
        guid += 1;
        this.internalMenuId = "$__$" + guid + "$Menu";
      }
    }

    var mouseEvents = {};
    var titleClickEvents = {};
    var titleMouseEvents = {};

    if (!disabled) {
      mouseEvents = {
        onMouseLeave: this.onMouseLeave,
        onMouseEnter: this.onMouseEnter
      }; // only works in title, not outer li

      titleClickEvents = {
        onClick: this.onTitleClick
      };
      titleMouseEvents = {
        onMouseEnter: this.onTitleMouseEnter,
        onMouseLeave: this.onTitleMouseLeave
      };
    }

    var style = {};

    if (isInlineMode) {
      style.paddingLeft = this.context.inlineIndent * (level - 1) + this.context.inlinePaddingLeft;
    }

    var ariaOwns = {}; // only set aria-owns when menu is open
    // otherwise it would be an invalid aria-owns value
    // since corresponding node cannot be found

    if (isOpen) {
      ariaOwns = {
        'aria-owns': this.internalMenuId
      };
    } // expand custom icon should NOT be displayed in menu with horizontal mode.


    var icon = null;

    if (mode !== 'horizontal') {
      icon = mode !== 'vertical' ? /*#__PURE__*/React.createElement(IconChevronDown, {
        className: prefixCls + "-down-icon"
      }) : /*#__PURE__*/React.createElement(IconChevronRight, {
        className: prefixCls + "-right-icon"
      });
    }

    var titleNode = /*#__PURE__*/React.createElement("div", _extends({
      ref: this.saveSubMenuTitle,
      style: style,
      className: classnames(prefixCls + "-title", (_classnames = {}, _classnames[prefixCls + "-title-disabled"] = disabled, _classnames))
    }, titleMouseEvents, titleClickEvents, {
      "aria-expanded": isOpen
    }, ariaOwns, {
      "aria-haspopup": "true",
      title: typeof title === 'string' ? title : undefined
    }), title, icon || /*#__PURE__*/React.createElement("i", {
      className: prefixCls + "-arrow"
    }));
    var childrenNode = this.renderChildren(children);
    var getPopupContainer = parentMenu.isRootMenu ? parentMenu.props.getPopupContainer : function (triggerNode) {
      return triggerNode.parentNode;
    };
    var popupPlacement = popupPlacementMap[mode];
    var popupAlign = Object.assign({
      ignoreShake: true
    }, popupOffset ? {
      offset: popupOffset
    } : {});
    var popupCls = mode === 'inline' ? '' : popupClassName;
    var cls = classnames(prefixCls, className, prefixCls + "-" + mode, (_classnames2 = {}, _classnames2[this.getOpenClassName()] = isOpen, _classnames2[this.getActiveClassName()] = active || isOpen && !isInlineMode, _classnames2[this.getDisabledClassName()] = disabled, _classnames2[this.getSelectedClassName()] = this.isChildrenSelected(), _classnames2));
    return /*#__PURE__*/React.createElement("li", _extends({}, omit(restProps, ['renderMenuItem', 'onDestroy', 'manualRef', 'selectedKeys', 'openKeys', 'onMouseEnter', 'onMouseLeave', 'onTitleMouseEnter', 'prefixCls', 'inlineIndent', 'onItemHover', 'onOpenChange', 'onDeselect', 'onTitleMouseLeave', 'onTitleClick', 'subMenuKey']), mouseEvents, {
      className: cls,
      role: "menuitem"
    }), isInlineMode && titleNode, isInlineMode && childrenNode, !isInlineMode && /*#__PURE__*/React.createElement(Trigger, {
      prefixCls: prefixCls,
      popupClassName: prefixCls + "-popup " + popupCls,
      getPopupContainer: getPopupContainer,
      builtinPlacements: Object.assign({}, placements, builtinPlacements),
      popupPlacement: popupPlacement,
      popupVisible: isOpen,
      popupAlign: popupAlign,
      popup: childrenNode,
      action: disabled ? [] : [triggerSubMenuAction],
      mouseEnterDelay: subMenuOpenDelay,
      mouseLeaveDelay: subMenuCloseDelay,
      onPopupVisibleChange: this.onPopupVisibleChange,
      forceRender: forceSubMenuRender
    }, titleNode));
  };

  return SubMenu;
}(React.Component);
SubMenu.defaultProps = {
  onMouseEnter: function onMouseEnter() {},
  onMouseLeave: function onMouseLeave() {},
  onTitleMouseEnter: function onTitleMouseEnter() {},
  onTitleMouseLeave: function onTitleMouseLeave() {},
  onTitleClick: function onTitleClick() {},
  manualRef: function manualRef() {},
  mode: 'vertical',
  title: '',
  prefixCls: 'one-menu'
};
SubMenu.contextType = Context;
var connected = connect(function (_ref2, _ref3) {
  var openKeys = _ref2.openKeys,
      activeKey = _ref2.activeKey,
      selectedKeys = _ref2.selectedKeys;
  var eventKey = _ref3.eventKey,
      subMenuKey = _ref3.subMenuKey;
  return {
    isOpen: openKeys.indexOf(eventKey) > -1,
    active: activeKey[subMenuKey] === eventKey,
    selectedKeys: selectedKeys
  };
})(SubMenu);
connected.isSubMenu = true;
export default connected;