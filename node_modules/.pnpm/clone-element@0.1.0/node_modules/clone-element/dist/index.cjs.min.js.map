{"version":3,"file":"index.cjs.min.js","sources":["../src/util.ts","../src/style.ts","../src/id.ts","../src/input.ts","../src/context.ts","../src/element.ts","../src/canvas.ts","../src/video.ts","../src/index.ts"],"sourcesContent":["import {\n  SupportedElement,\n  SupportedElementTagName,\n  SupportedElementTagNameMap,\n} from \"./types\";\n\nexport function isTagName<T extends SupportedElementTagName>(\n  el: SupportedElement,\n  tagNames: T[]\n): el is SupportedElementTagNameMap[T] {\n  return (tagNames as string[]).indexOf(el.tagName.toLowerCase()) !== -1;\n}\n","import { isTagName } from \"./util\";\nimport {\n  StyleInfo,\n  ElementStyleInfo,\n  PesudoStyleInfoMap,\n  SupportedElement,\n  StyleSnapshot,\n  SupportedElementTagName,\n} from \"./types\";\n\n/**\n * Surprisingly, <style> element can be appended to <input> and <textarea>\n * so we can support ::placeholder, and ::selection even for them.\n */\nconst SUPPORTED_PSEUDO_SELECTORS = [\n  \"::after\",\n  \"::before\",\n  \"::first-letter\",\n  \"::first-line\",\n  \"::marker\",\n  \"::placeholder\",\n  \"::selection\",\n];\n\nconst REPLACED_ELEMENTS: SupportedElementTagName[] = [\n  \"iframe\",\n  \"video\",\n  \"embed\",\n  \"img\",\n  \"audio\",\n  \"option\",\n  \"canvas\",\n  \"object\",\n  \"applet\",\n];\n\nconst VOID_ELEMENTS: SupportedElementTagName[] = [\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\",\n];\n\nconst NO_GENERATE_CONTENT_ELEMENTS = REPLACED_ELEMENTS.concat(VOID_ELEMENTS);\n\nconst PLACEHOLDER_ELEMENTS: SupportedElementTagName[] = [\"input\", \"textarea\"];\n\nconst SKIPPED_PROPERTIES = [\"-webkit-locale\"];\n\nfunction setDefault(elem: SupportedElement): () => void {\n  const style = elem.getAttribute(\"style\");\n  elem.style.setProperty(\"all\", \"revert\", \"important\");\n\n  return () => {\n    if (style) {\n      elem.setAttribute(\"style\", style);\n    } else {\n      elem.removeAttribute(\"style\");\n    }\n  };\n}\n\nexport function getDefaultStyleInfo(\n  source: SupportedElement,\n  pseudoSelector?: string\n): StyleInfo {\n  const dispose = setDefault(source);\n  const info = getStyleInfo(source, pseudoSelector);\n  dispose();\n\n  return info;\n}\n\nexport function getStyleInfo(\n  source: SupportedElement,\n  pseudoSelector?: string\n): StyleInfo {\n  const computed = window.getComputedStyle(source, pseudoSelector);\n  const style = getStyleSnapshot(computed);\n  const { display, content } = style;\n\n  if (display === \"none\" || (pseudoSelector && content === \"none\")) {\n    return null;\n  }\n\n  if (!pseudoSelector) {\n    const { width, height } = source.getBoundingClientRect();\n\n    if (width * height === 0) {\n      return null;\n    }\n\n    const allPseudoStyleInfo: PesudoStyleInfoMap = Object.create(null);\n\n    for (const selector of SUPPORTED_PSEUDO_SELECTORS) {\n      const pseudoStyleInfo = getStyleInfo(source, selector);\n\n      if (pseudoStyleInfo) {\n        allPseudoStyleInfo[selector] = pseudoStyleInfo;\n      }\n    }\n\n    return {\n      style,\n      width: `${width}px`,\n      height: `${height}px`,\n      pseudo: allPseudoStyleInfo,\n    };\n  }\n\n  // pseudo elements\n  if (\n    content === \"none\" ||\n    (pseudoSelector === \"::marker\" && display !== \"list-item\") ||\n    ((pseudoSelector === \"::before\" || pseudoSelector === \"::after\") &&\n      isTagName(source as SupportedElement, NO_GENERATE_CONTENT_ELEMENTS)) ||\n    (pseudoSelector === \"::placeholder\" &&\n      !isTagName(source as SupportedElement, PLACEHOLDER_ELEMENTS))\n  ) {\n    return null;\n  }\n\n  return {\n    style,\n  };\n}\n\nexport function patchStyle(\n  target: SupportedElement,\n  styleInfo: StyleInfo,\n  defaultStyleInfo: StyleInfo\n): void {\n  if (!styleInfo) {\n    return;\n  }\n\n  const { style, width, height, pseudo } = styleInfo as ElementStyleInfo;\n  const defaultStyle = defaultStyleInfo?.style;\n  const pseudoDefault = (defaultStyleInfo as ElementStyleInfo).pseudo;\n\n  const cssText = generateCssText(\n    getStyleDiff(style, defaultStyle as StyleSnapshot)\n  );\n  target.style.cssText = cssText + target.style.cssText;\n\n  /**\n   * Patch size\n   *\n   * TODO: how to deal with inline elements?\n   */\n  if (style.display !== \"inline\") {\n    target.style.boxSizing = \"border-box\";\n    target.style.width = width;\n    target.style.height = height;\n    target.style.maxWidth = \"none\";\n    target.style.minWidth = \"auto\";\n  }\n\n  const pseudoCssTextList = [];\n\n  for (const selector in pseudo) {\n    const pseudoStyleInfo = pseudo[selector];\n    const pseudoDefaultStyleInfo = pseudoDefault[selector];\n\n    const pseudoStyle = pseudoStyleInfo.style;\n    const pseudoDefaultStyle = pseudoDefaultStyleInfo.style;\n    const cssText = generateCssText(\n      getStyleDiff(pseudoStyle, pseudoDefaultStyle)\n    );\n\n    const css = generatePseudoElementCSS(target, selector, cssText);\n\n    if (css) {\n      pseudoCssTextList.push(css);\n    }\n  }\n\n  if (pseudoCssTextList.length) {\n    const style = createStyleElement(pseudoCssTextList.join(\"\\n\"));\n\n    target.appendChild(style);\n  }\n}\n\nfunction generatePseudoElementCSS(\n  target: SupportedElement,\n  selector: string,\n  cssText: string\n): string {\n  if (!cssText) {\n    return \"\";\n  }\n\n  return `#${target.id}${selector}{${cssText}}`;\n}\n\nfunction createStyleElement(css: string): HTMLStyleElement {\n  const style = document.createElement(\"style\");\n  style.appendChild(document.createTextNode(css));\n\n  return style;\n}\n\nfunction getStyleSnapshot(style: CSSStyleDeclaration): StyleSnapshot {\n  const snapshot = Object.create({});\n  for (let i = 0; i < style.length; i++) {\n    const prop = style[i];\n    snapshot[prop] = style.getPropertyValue(prop);\n  }\n\n  return snapshot;\n}\n\nfunction getStyleDiff(\n  currentStyle: StyleSnapshot,\n  defaultStyle: StyleSnapshot\n): StyleSnapshot {\n  const diff = Object.create({});\n\n  for (const key in currentStyle) {\n    if (\n      SKIPPED_PROPERTIES.indexOf(key) === -1 &&\n      currentStyle[key] !== defaultStyle[key]\n    ) {\n      diff[key] = currentStyle[key];\n    }\n  }\n\n  return diff;\n}\n\nfunction generateCssText(style: StyleSnapshot): string {\n  const declarations = [];\n\n  for (const key in style) {\n    declarations.push(`${key}:${style[key]};`);\n  }\n\n  return declarations.join(\"\");\n}\n","let counter = Math.floor(Math.random() * 667384);\n\nexport function getUniqueId(prefix?: string): string {\n  const leading = prefix ? `${prefix}-` : \"\";\n  return leading + (counter++).toString(36);\n}\n\nexport function patchId(target: Element): void {\n  target.id = getUniqueId(\"clone-id\");\n}\n","import { getUniqueId } from \"./id\";\nimport { InputElement } from \"./types\";\n\nconst nameMap = Object.create(null);\n\nexport function patchInput(target: InputElement, source: InputElement): void {\n  const { name, type } = target;\n\n  /**\n   * Sync input values because they are not cloned with cloneNode.\n   */\n  if (type !== \"file\") {\n    target.value = source.value;\n  }\n\n  /**\n   * Patch `name` as only one of radio buttons that share the\n   * same name can be checked.\n   */\n  if (name && type === \"radio\") {\n    let mapped = nameMap[name];\n\n    if (!mapped) {\n      mapped = nameMap[name] = getUniqueId(\"clone-name\");\n    }\n\n    target.name = mapped;\n  }\n\n  if (source.disabled) {\n    target.disabled = true;\n  }\n}\n","const INHERITED_ATTRS = [\"dir\", \"lang\", \"disabled\"];\n\nexport function patchContext(target: Element, source: Element): void {\n  const attrs = INHERITED_ATTRS.concat([]);\n  const seen = Object.create(null);\n  let current: Element | null = source;\n\n  patch: while (current) {\n    for (let i = 0; i < attrs.length; i++) {\n      const key = attrs[i];\n\n      if (seen[key]) {\n        return;\n      }\n\n      const attr = current.getAttribute(key);\n      if (attr !== null) {\n        target.setAttribute(key, attr);\n        seen[key] = true;\n\n        if (Object.keys(seen).length === attrs.length) {\n          break patch;\n        }\n      }\n    }\n\n    current = current.parentElement;\n  }\n}\n\n/**\n * Context\n *\n * dir -> :dir\n * lang -> :lang\n * disabled\n */\n","import { patchInput } from \"./input\";\nimport { patchCanvas } from \"./canvas\";\nimport { patchVideo } from \"./video\";\nimport { SupportedElement, StyleInfo } from \"./types\";\nimport { patchId } from \"./id\";\nimport { isTagName } from \"./util\";\nimport { patchContext } from \"./context\";\n\nexport function patchElement(\n  target: SupportedElement,\n  source: SupportedElement,\n  styleInfo: StyleInfo\n): void {\n  if (!styleInfo) {\n    // invisible elements don't need to be patched\n    return;\n  }\n  patchId(target);\n  patchContext(target, source);\n\n  if (isTagName(target, [\"input\", \"textarea\", \"select\"])) {\n    patchInput(target, source as typeof target);\n  } else if (isTagName(target, [\"canvas\"])) {\n    patchCanvas(target, source as typeof target);\n  } else if (isTagName(target, [\"video\"])) {\n    patchVideo(target, source as typeof target);\n  }\n}\n","export function patchCanvas(\n  target: HTMLCanvasElement,\n  source: HTMLCanvasElement\n): void {\n  const targetCtx = target.getContext(\"2d\");\n  targetCtx?.drawImage(source, 0, 0);\n}\n","declare global {\n  interface HTMLVideoElement {\n    captureStream(): MediaStream;\n    mozCaptureStream(): MediaStream;\n  }\n}\n\nexport function patchVideo(\n  target: HTMLVideoElement,\n  source: HTMLVideoElement\n): void {\n  const method = source.captureStream || source.mozCaptureStream;\n\n  target.controls = source.controls && source.paused;\n\n  if (!method) {\n    const sync = () => {\n      target.currentTime = source.currentTime;\n      if (source.paused) {\n        target.pause();\n      } else {\n        target.play();\n      }\n\n      target.removeEventListener(\"canplay\", sync);\n    };\n\n    target.addEventListener(\"canplay\", sync);\n\n    return;\n  }\n\n  const stream = method.call(source);\n\n  target.srcObject = stream;\n}\n","import { getDefaultStyleInfo, getStyleInfo, patchStyle } from \"./style\";\nimport { patchElement } from \"./element\";\nimport { SupportedElement } from \"./types\";\n\nexport default function cloneElement(source: Element): Element {\n  const target = source.cloneNode(true) as Element;\n\n  const targetElements = [target].concat(\n    Array.from(target.querySelectorAll(\"*\"))\n  );\n  const sourceElements = [source].concat(\n    Array.from(source.querySelectorAll(\"*\"))\n  );\n\n  if (targetElements.length !== sourceElements.length) {\n    throw new Error(\n      \"[clone-element] Cannot correctly clone the given element.\"\n    );\n  }\n\n  const styleInfoList = sourceElements.map((s) =>\n    getStyleInfo(s as SupportedElement)\n  );\n\n  targetElements.forEach((t, i) => {\n    const s = sourceElements[i];\n    patchElement(\n      t as SupportedElement,\n      s as SupportedElement,\n      styleInfoList[i]\n    );\n  });\n\n  document.body.appendChild(target);\n  const defaultStyleInfoList = targetElements.map((t) =>\n    getDefaultStyleInfo(t as SupportedElement)\n  );\n  document.body.removeChild(target);\n\n  targetElements.forEach((t, i) => {\n    patchStyle(\n      t as SupportedElement,\n      styleInfoList[i],\n      defaultStyleInfoList[i]\n    );\n  });\n\n  return target;\n}\n"],"names":["isTagName","el","tagNames","indexOf","tagName","toLowerCase","SUPPORTED_PSEUDO_SELECTORS","NO_GENERATE_CONTENT_ELEMENTS","concat","PLACEHOLDER_ELEMENTS","SKIPPED_PROPERTIES","getStyleInfo","source","pseudoSelector","style","snapshot","Object","create","i","length","prop","getPropertyValue","getStyleSnapshot","window","getComputedStyle","display","content","_a","getBoundingClientRect","width","height","allPseudoStyleInfo","SUPPORTED_PSEUDO_SELECTORS_1","_i","selector","pseudoStyleInfo","pseudo","patchStyle","target","styleInfo","defaultStyleInfo","defaultStyle","pseudoDefault","cssText","generateCssText","getStyleDiff","boxSizing","maxWidth","minWidth","pseudoCssTextList","pseudoDefaultStyleInfo","css","generatePseudoElementCSS","push","style_1","document","createElement","appendChild","createTextNode","createStyleElement","join","id","currentStyle","diff","key","declarations","counter","Math","floor","random","getUniqueId","prefix","toString","nameMap","INHERITED_ATTRS","patchElement","patchId","attrs","seen","current","patch","attr","getAttribute","setAttribute","keys","parentElement","patchContext","name","type","value","mapped","disabled","patchInput","targetCtx","getContext","drawImage","patchCanvas","method","captureStream","mozCaptureStream","controls","paused","stream","call","srcObject","sync_1","currentTime","pause","play","removeEventListener","addEventListener","patchVideo","cloneNode","targetElements","Array","from","querySelectorAll","sourceElements","Error","styleInfoList","map","s","forEach","t","body","defaultStyleInfoList","elem","dispose","setProperty","removeAttribute","info","getDefaultStyleInfo","removeChild"],"mappings":"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"}