(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.cloneElement = factory());
}(this, (function () { 'use strict';

  function isTagName(el, tagNames) {
      return tagNames.indexOf(el.tagName.toLowerCase()) !== -1;
  }

  /**
   * Surprisingly, <style> element can be appended to <input> and <textarea>
   * so we can support ::placeholder, and ::selection even for them.
   */
  var SUPPORTED_PSEUDO_SELECTORS = [
      "::after",
      "::before",
      "::first-letter",
      "::first-line",
      "::marker",
      "::placeholder",
      "::selection",
  ];
  var REPLACED_ELEMENTS = [
      "iframe",
      "video",
      "embed",
      "img",
      "audio",
      "option",
      "canvas",
      "object",
      "applet",
  ];
  var VOID_ELEMENTS = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
  ];
  var NO_GENERATE_CONTENT_ELEMENTS = REPLACED_ELEMENTS.concat(VOID_ELEMENTS);
  var PLACEHOLDER_ELEMENTS = ["input", "textarea"];
  var SKIPPED_PROPERTIES = ["-webkit-locale"];
  function setDefault(elem) {
      var style = elem.getAttribute("style");
      elem.style.setProperty("all", "revert", "important");
      return function () {
          if (style) {
              elem.setAttribute("style", style);
          }
          else {
              elem.removeAttribute("style");
          }
      };
  }
  function getDefaultStyleInfo(source, pseudoSelector) {
      var dispose = setDefault(source);
      var info = getStyleInfo(source, pseudoSelector);
      dispose();
      return info;
  }
  function getStyleInfo(source, pseudoSelector) {
      var computed = window.getComputedStyle(source, pseudoSelector);
      var style = getStyleSnapshot(computed);
      var display = style.display, content = style.content;
      if (display === "none" || (pseudoSelector && content === "none")) {
          return null;
      }
      if (!pseudoSelector) {
          var _a = source.getBoundingClientRect(), width = _a.width, height = _a.height;
          if (width * height === 0) {
              return null;
          }
          var allPseudoStyleInfo = Object.create(null);
          for (var _i = 0, SUPPORTED_PSEUDO_SELECTORS_1 = SUPPORTED_PSEUDO_SELECTORS; _i < SUPPORTED_PSEUDO_SELECTORS_1.length; _i++) {
              var selector = SUPPORTED_PSEUDO_SELECTORS_1[_i];
              var pseudoStyleInfo = getStyleInfo(source, selector);
              if (pseudoStyleInfo) {
                  allPseudoStyleInfo[selector] = pseudoStyleInfo;
              }
          }
          return {
              style: style,
              width: width + "px",
              height: height + "px",
              pseudo: allPseudoStyleInfo,
          };
      }
      // pseudo elements
      if (content === "none" ||
          (pseudoSelector === "::marker" && display !== "list-item") ||
          ((pseudoSelector === "::before" || pseudoSelector === "::after") &&
              isTagName(source, NO_GENERATE_CONTENT_ELEMENTS)) ||
          (pseudoSelector === "::placeholder" &&
              !isTagName(source, PLACEHOLDER_ELEMENTS))) {
          return null;
      }
      return {
          style: style,
      };
  }
  function patchStyle(target, styleInfo, defaultStyleInfo) {
      if (!styleInfo) {
          return;
      }
      var _a = styleInfo, style = _a.style, width = _a.width, height = _a.height, pseudo = _a.pseudo;
      var defaultStyle = defaultStyleInfo === null || defaultStyleInfo === void 0 ? void 0 : defaultStyleInfo.style;
      var pseudoDefault = defaultStyleInfo.pseudo;
      var cssText = generateCssText(getStyleDiff(style, defaultStyle));
      target.style.cssText = cssText + target.style.cssText;
      /**
       * Patch size
       *
       * TODO: how to deal with inline elements?
       */
      if (style.display !== "inline") {
          target.style.boxSizing = "border-box";
          target.style.width = width;
          target.style.height = height;
          target.style.maxWidth = "none";
          target.style.minWidth = "auto";
      }
      var pseudoCssTextList = [];
      for (var selector in pseudo) {
          var pseudoStyleInfo = pseudo[selector];
          var pseudoDefaultStyleInfo = pseudoDefault[selector];
          var pseudoStyle = pseudoStyleInfo.style;
          var pseudoDefaultStyle = pseudoDefaultStyleInfo.style;
          var cssText_1 = generateCssText(getStyleDiff(pseudoStyle, pseudoDefaultStyle));
          var css = generatePseudoElementCSS(target, selector, cssText_1);
          if (css) {
              pseudoCssTextList.push(css);
          }
      }
      if (pseudoCssTextList.length) {
          var style_1 = createStyleElement(pseudoCssTextList.join("\n"));
          target.appendChild(style_1);
      }
  }
  function generatePseudoElementCSS(target, selector, cssText) {
      if (!cssText) {
          return "";
      }
      return "#" + target.id + selector + "{" + cssText + "}";
  }
  function createStyleElement(css) {
      var style = document.createElement("style");
      style.appendChild(document.createTextNode(css));
      return style;
  }
  function getStyleSnapshot(style) {
      var snapshot = Object.create({});
      for (var i = 0; i < style.length; i++) {
          var prop = style[i];
          snapshot[prop] = style.getPropertyValue(prop);
      }
      return snapshot;
  }
  function getStyleDiff(currentStyle, defaultStyle) {
      var diff = Object.create({});
      for (var key in currentStyle) {
          if (SKIPPED_PROPERTIES.indexOf(key) === -1 &&
              currentStyle[key] !== defaultStyle[key]) {
              diff[key] = currentStyle[key];
          }
      }
      return diff;
  }
  function generateCssText(style) {
      var declarations = [];
      for (var key in style) {
          declarations.push(key + ":" + style[key] + ";");
      }
      return declarations.join("");
  }

  var counter = Math.floor(Math.random() * 667384);
  function getUniqueId(prefix) {
      var leading = prefix ? prefix + "-" : "";
      return leading + (counter++).toString(36);
  }
  function patchId(target) {
      target.id = getUniqueId("clone-id");
  }

  var nameMap = Object.create(null);
  function patchInput(target, source) {
      var name = target.name, type = target.type;
      /**
       * Sync input values because they are not cloned with cloneNode.
       */
      if (type !== "file") {
          target.value = source.value;
      }
      /**
       * Patch `name` as only one of radio buttons that share the
       * same name can be checked.
       */
      if (name && type === "radio") {
          var mapped = nameMap[name];
          if (!mapped) {
              mapped = nameMap[name] = getUniqueId("clone-name");
          }
          target.name = mapped;
      }
      if (source.disabled) {
          target.disabled = true;
      }
  }

  function patchCanvas(target, source) {
      var targetCtx = target.getContext("2d");
      targetCtx === null || targetCtx === void 0 ? void 0 : targetCtx.drawImage(source, 0, 0);
  }

  function patchVideo(target, source) {
      var method = source.captureStream || source.mozCaptureStream;
      target.controls = source.controls && source.paused;
      if (!method) {
          var sync_1 = function () {
              target.currentTime = source.currentTime;
              if (source.paused) {
                  target.pause();
              }
              else {
                  target.play();
              }
              target.removeEventListener("canplay", sync_1);
          };
          target.addEventListener("canplay", sync_1);
          return;
      }
      var stream = method.call(source);
      target.srcObject = stream;
  }

  var INHERITED_ATTRS = ["dir", "lang", "disabled"];
  function patchContext(target, source) {
      var attrs = INHERITED_ATTRS.concat([]);
      var seen = Object.create(null);
      var current = source;
      patch: while (current) {
          for (var i = 0; i < attrs.length; i++) {
              var key = attrs[i];
              if (seen[key]) {
                  return;
              }
              var attr = current.getAttribute(key);
              if (attr !== null) {
                  target.setAttribute(key, attr);
                  seen[key] = true;
                  if (Object.keys(seen).length === attrs.length) {
                      break patch;
                  }
              }
          }
          current = current.parentElement;
      }
  }
  /**
   * Context
   *
   * dir -> :dir
   * lang -> :lang
   * disabled
   */

  function patchElement(target, source, styleInfo) {
      if (!styleInfo) {
          // invisible elements don't need to be patched
          return;
      }
      patchId(target);
      patchContext(target, source);
      if (isTagName(target, ["input", "textarea", "select"])) {
          patchInput(target, source);
      }
      else if (isTagName(target, ["canvas"])) {
          patchCanvas(target, source);
      }
      else if (isTagName(target, ["video"])) {
          patchVideo(target, source);
      }
  }

  function cloneElement(source) {
      var target = source.cloneNode(true);
      var targetElements = [target].concat(Array.from(target.querySelectorAll("*")));
      var sourceElements = [source].concat(Array.from(source.querySelectorAll("*")));
      if (targetElements.length !== sourceElements.length) {
          throw new Error("[clone-element] Cannot correctly clone the given element.");
      }
      var styleInfoList = sourceElements.map(function (s) {
          return getStyleInfo(s);
      });
      targetElements.forEach(function (t, i) {
          var s = sourceElements[i];
          patchElement(t, s, styleInfoList[i]);
      });
      document.body.appendChild(target);
      var defaultStyleInfoList = targetElements.map(function (t) {
          return getDefaultStyleInfo(t);
      });
      document.body.removeChild(target);
      targetElements.forEach(function (t, i) {
          patchStyle(t, styleInfoList[i], defaultStyleInfoList[i]);
      });
      return target;
  }

  return cloneElement;

})));
//# sourceMappingURL=index.umd.js.map
